<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: dataRenderer/HavokRenderer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: dataRenderer/HavokRenderer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
Copyright Â© Tyria3DLibrary project contributors

This file is part of the Tyria 3D Library.

Tyria 3D Library is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Tyria 3D Library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with the Tyria 3D Library. If not, see &lt;http://www.gnu.org/licenses/>.
*/

const DataRenderer = require('./DataRenderer');

/**
 *
 * A renderer that generates meshes describing the collisions of a map.
 * 
 * @class HavokRenderer
 * @constructor
 * @extends DataRenderer
 * @param  {LocalReader} localReader  The LocalReader instance to read data from.
 * @param  {Object} settings     Any settings used by this renderer.
 * *Must* specify "mapFile", a GW2File. If "visible" is specified and true, the generated meshes will be textured
 * with a MeshNormalMaterial, otherwise they will not be visible.
 * @param  {Object} context      Shared value object between renderers.
 * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.
 */
function HavokRenderer(localReader, settings, context, logger){
	DataRenderer.call(this, localReader, settings, context, logger);

	this.mapFile = this.settings.mapFile;

	this.lastP = -1;
	this.seed = 1;
	this.meshes = [];

	/**
	 * TODO
	 * 
	 * @param  {Function} callback         [description]
	 * @async
	 */
	this.renderModels = function(models, title, callback){
		var mat;
		if(this.settings &amp;&amp; this.settings.visible){
			mat = new THREE.MeshNormalMaterial( { side: THREE.DoubleSide } ); 
		}
		else{
			mat = new THREE.MeshBasicMaterial( { visible: false } );			
		}

		this.parseAllModels(models, mat, title, 200, 0, callback);
	}


	/**
	 * TODO
	 * 
	 * @param  {*} animation  [description]
	 * @param  {*} collisions [description]
	 * @return {*}            [description]
	 */
	this.getCollisionsForAnimation = function(animation, collisions){
		var ret = [];
		
		for (var i = 0; i &lt; animation.collisionIndices.length; i++) {
			var index = animation.collisionIndices[i];
			var collision = collisions[ index ];
			collision.index = index;
			ret.push( collision );
		}
		
		return ret;
	};

	/**
	 * TODO
	 * 
	 * @param  {*} models       [description]
	 * @param  {*} mat       [description]
	 * @param  {*} title     [description]
	 * @param  {*} chunkSize [description]
	 * @param  {*} offset    [description]
	 * @return {*} callback          [description]
	 * @async
	 */
	this.parseAllModels = function(models, mat, title, chunkSize, offset, callback){
		var i = offset;		

		for(; i &lt; offset+chunkSize &amp;&amp; i &lt; models.length; i++){
			
			var p = Math.round(i*100/ models.length );
			if( p != this.lastP){

				this.logger.log(
					T3D.Logger.TYPE_PROGRESS,
					"Loading Collision Models ("+title+")",
					p
				);
				this.lastP = p;
			}	
		
			/// Get animation object
			var animation =  this.animationFromGeomIndex(
				models[i].geometryIndex,
				this.geometries,
				this.animations
			);
			
			var collisions = this.getCollisionsForAnimation( animation, this.havokChunkData.collisions);
			
			for(var j=0; j&lt; collisions.length; j++){
				var collision = collisions[j];			
		 		this.renderMesh( collision, models[i], mat );
			}
		}

		if(i&lt;models.length){
			window.setTimeout(
				this.parseAllModels.bind(this, models, mat, title, chunkSize, offset+chunkSize, callback),
				10 /*time in ms to next call*/
			);
		}
		else{
			callback();
		}
	}

	/**
	 * TODO
	 * 
	 * @param  {*} propGeomIndex [description]
	 * @param  {*} geometries    [description]
	 * @param  {*} animations    [description]
	 * @return {*}               [description]
	 */
	this.animationFromGeomIndex = function(propGeomIndex, geometries, animations){
		
		// geometries is just list of all geometries.animations[end] for now
		var l = geometries[propGeomIndex].animations.length;
		
		return animations[ geometries[propGeomIndex].animations[l-1] ];
		//return animations[ geometries[propGeomIndex].animations[0] ];
	};

	/**
	 * TODO
	 * 
	 * @param  {*} collision [description]
	 * @param  {*} model     [description]
	 * @param  {*} mat       [description]
	 * @return {*}           [description]
	 */
	this.renderMesh = function( collision, model, mat ){
	    
	    var pos = model.translate;
	    var rot = model.rotate;
	    var scale = 32 * model.scale;    
	    
	    /// Generate mesh
	    var mesh = this.parseHavokMesh(collision, mat);
	    
	    /// Position mesh
	    /// "x","float32","z","float32","y","float32"
	    mesh.position.set(pos[0], -pos[2], -pos[1]);    
	    
	    /// Scale mesh
	    if(scale)
	    	mesh.scale.set( scale, scale, scale );

	    /// Rotate mesh
	    if(rot){
	    	mesh.rotation.order = "ZXY";

	    	// ["x","float32","z","float32","y","float32"], 
	    	mesh.rotation.set(rot[0], -rot[2], -rot[1]);
	    }
	    	
		/// Add mesh to scene and collisions
		this.getOutput().meshes.push(mesh);
	};


	/**
	 * TODO
	 * 
	 * @return {*} [description]
	 */
	this.seedRandom = function(){
	    var x = Math.sin(this.seed++) * 10000;
	    return x - Math.floor(x);
	};

	/**
	 * TODO
	 * 
	 * @param  {*} collision [description]
	 * @param  {*} mat       [description]
	 * @return {*}           [description]
	 */
	this.parseHavokMesh = function(collision, mat){
		
		var index = collision.index;

		if(!this.meshes[index]){

			var geom = new THREE.Geometry();
			
			/// Pass vertices	    		
			for(var i=0; i&lt;collision.vertices.length; i++){
				var v=collision.vertices[i];
				//"x","float32","z","float32","y","float32"]
				geom.vertices.push( new THREE.Vector3(v[0] , v[2] , -v[1] ) );
			}	    		
				
			/// Pass faces
			for(var i=0; i&lt;collision.indices.length; i+=3){

				var f1=collision.indices[i];
				var f2=collision.indices[i+1];
				var f3=collision.indices[i+2];

				if( f1&lt;=collision.vertices.length &amp;&amp;
					f2&lt;=collision.vertices.length &amp;&amp;
					f3&lt;=collision.vertices.length){
					geom.faces.push( new THREE.Face3( f1, f2, f3 ) );
				}
	   			else{
	   				this.logger.log(
	   					T3D.Logger.TYPE_ERROR,
	   					"Errorus index in havok model geometry."
   					);
	   			}
			}

			/// Prepare geometry and pass new mesh
			geom.computeFaceNormals();
			//geom.computeVertexNormals();
			
			this.meshes[index]= new THREE.Mesh( geom, mat ); 
			
			return this.meshes[index];
		}
		else{
			return this.meshes[index].clone();
		}
	};

};


/// DataRenderer inheritance:
HavokRenderer.prototype = Object.create(DataRenderer.prototype);
HavokRenderer.prototype.constructor = HavokRenderer;

/**
 * Output fileds generated:
 *
 * - *boundingBox* Array of values describing the bounding box of all collision.
 * - *meshes* An array of THREE.Mesh objects visualizing all collision in the map.
 * 
 * @async
 * @param  {Function} callback Fires when renderer is finished, does not take arguments.
 */
HavokRenderer.prototype.renderAsync = function(callback){
	var self = this;

	// TODO:The design of this method pretty much requires one instance
	// of the class per parallel async render. Should probably fix this
	// at some point...
	
	/// Get required chunks
	this.havokChunkData = this.mapFile.getChunk("havk").data;

    /// Set static bounds to the bounds of the havk models
    this.getOutput().boundingBox = this.havokChunkData.boundsMax;
	
	/// Clear old meshes
	this.meshes = [];

	/// Set up output array
	this.getOutput().meshes = [];

	/// Grab model raw data from the chunk.
	/// Add missing scale value to obs models.
	var propModels = this.havokChunkData.propModels;
	var zoneModels = this.havokChunkData.zoneModels;
	var obsModels = this.havokChunkData.obsModels;
	obsModels.forEach(function(mdl){
		mdl.scale = 1;
	});

	/// Store geoms and animations from the file in hte instance so we don't
	/// have to pass them arround too much. (fix this later)
	this.geometries = this.havokChunkData.geometries;
	this.animations = this.havokChunkData.animations;		
	
	/// Render "prop", "zone" and "obs" models in that order.
	var renderPropModelsCB = function(){
		self.renderModels(zoneModels, "zone", renderZoneModelsCB);
	};
	var renderZoneModelsCB = function(){
		self.renderModels(obsModels, "obs", callback);
	};
	self.renderModels(propModels, "prop", renderPropModelsCB);

	
}

module.exports = HavokRenderer;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-T3D.html">T3D</a></li></ul><h3>Classes</h3><ul><li><a href="DataReader.html">DataReader</a></li><li><a href="DataRenderer.html">DataRenderer</a></li><li><a href="EnvironmentRenderer.html">EnvironmentRenderer</a></li><li><a href="GW2Chunk.html">GW2Chunk</a></li><li><a href="GW2File.html">GW2File</a></li><li><a href="HavokRenderer.html">HavokRenderer</a></li><li><a href="LocalReader.html">LocalReader</a></li><li><a href="PersistantStore.html">PersistantStore</a></li><li><a href="PropertiesRenderer.html">PropertiesRenderer</a></li><li><a href="SingleModelRenderer.html">SingleModelRenderer</a></li><li><a href="StringRenderer.html">StringRenderer</a></li><li><a href="TerrainRenderer.html">TerrainRenderer</a></li><li><a href="ZoneRenderer.html">ZoneRenderer</a></li></ul><h3>Namespaces</h3><ul><li><a href="ArchiveParser.html">ArchiveParser</a></li><li><a href="FileTypes.html">FileTypes</a></li><li><a href="Logger.html">Logger</a></li><li><a href="MaterialUtils.html">MaterialUtils</a></li><li><a href="MathUtils.html">MathUtils</a></li><li><a href="ParserUtils.html">ParserUtils</a></li><li><a href="RenderUtils.html">RenderUtils</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun May 06 2018 14:40:59 GMT+0200 (Paris, Madrid (heure dâÃ©tÃ©))
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
