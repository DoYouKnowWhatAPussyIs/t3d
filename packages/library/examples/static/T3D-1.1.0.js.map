{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/LocalReader/ArchiveParser.js","src/LocalReader/DataReader.js","src/LocalReader/FileTypes.js","src/LocalReader/LocalReader.js","src/LocalReader/PersistantStore.js","src/Logger.js","src/MapFileList.js","src/T3DLib.js","src/dataRenderer/DataRenderer.js","src/dataRenderer/EnvironmentRenderer.js","src/dataRenderer/HavokRenderer.js","src/dataRenderer/PropertiesRenderer.js","src/dataRenderer/SingleModelRenderer.js","src/dataRenderer/StringRenderer.js","src/dataRenderer/TerrainRenderer.js","src/dataRenderer/ZoneRenderer.js","src/format/file/GW2Chunk.js","src/format/file/GW2File.js","src/util/MaterialUtils.js","src/util/MathUtils.js","src/util/ParserUtils.js","src/util/RenderUtils.js","src/util/TerrainShader.js"],"names":["f","exports","module","define","amd","window","global","self","this","T3D","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","MathUtils","parseANDatHeader","ds","header","version","readUint8","magic","readString","headerSize","readUint32","seek","position","chunkSize","crc","mftOffset","arr32To64","mftSize","flags","Logger","log","TYPE_DEBUG","TYPE_ERROR","parseMFTTable","nbOfEntries","fullTable","item","readUint16","table","mftIndexOffset","offset","mftIndexSize","size","parseMFTIndex","indexTable","id","mftIndex","getFilePart","file","Promise","resolve","reject","reader","FileReader","onerror","onload","fileEvent","buffer","target","result","DataStream","endianness","LITTLE_ENDIAN","len","readAsArrayBuffer","slice","readArchive","async","archiveHeader","mftData","metaTable","[object Object]","settings","_settings","_workerPool","_workerLoad","_inflateCallbacks","workersNb","_startWorker","workerPath","mftId","isImage","capLength","arrayBuffer","byteLength","TYPE_WARNING","push","workerId","_getBestWorkerIndex","postMessage","path","worker","Worker","selfWorkerId","onmessage","message_event","data","split","callback","dxtType","imageWidth","imageHeight","indexOf","Math","min","GW2File","FileTypes","getFileType","first4","readCString","type","ArchiveParser","PersistantStore","DataReader","MapFileList","_dataReader","_persistantStore","_file","undefined","_indexTable","_fileMetaTable","noIndexedDB","baseId","raw","fileLength","extractLength","meta","getFileMeta","compressed","inflate","then","catch","oldFileList","persistantId","persistantList","lastListing","getLastListing","name","array","complete","key","iterateList","Object","keys","map","Number","index","taskArray","task","persistantNeedsUpdate","_needsScan","scan","taskId","race","_readFileType","scanResult","fileType","change","floor","TYPE_PROGRESS","putListing","res","all","_persistantData","getFileList","mapArray","reversedIndex","getReverseIndex","maps","filter","getFileIndex","found","category","fileMap","find","fileName","toString","mapEntry","typeList","reverseBaseIdList","fileList","baseIds","baseIdList","reduce","reversed","searchAll","restoreOuput","returnArray","elt","findIndex","sort","j","readFileList","getMapList","returnObj","fileEntry","readFile","loadFile","persistantData","metaData","_fileTypeCache","fileBuffer","DB_VERSION","_dbConnection","_getConnection","request","indexedDB","open","onblocked","onupgradeneeded","event","db","currentVersion","oldVersion","createObjectStore","autoIncrement","currentTarget","transaction","objectStore","createIndex","unique","onsuccess","isReady","listing","isComplete","store","put","filename","openCursor","IDBKeyRange","only","cursor","value","primaryKey","TYPE_MESSAGE","logFunctions","Array","arguments","argArr","argsToArr","unshift","severity","max","shift","apply","args","console","error","warn","debug","LocalReader","t3dtoolsWorker","concurrentTasks","navigator","hardwareConcurrency","GW2Chunk","DataRenderer","EnvironmentRenderer","HavokRenderer","PropertiesRenderer","SingleModelRenderer","TerrainRenderer","ZoneRenderer","StringRenderer","MaterialUtils","ParserUtils","RenderUtils","getLocalReader","lrInstance","openArchive","getFileListAsync","localReader","loadFileList","readFileListAsync","getMapListAsync","readMapListAsync","mapList","loadMapList","renderMapContentsAsync","renderers","logger","runAllRenderers","context","parseInt","mapFile","runRenderer","renderClass","assign","bind","cb","renderAsync","getContextValue","clazz","propName","defaultValue","output","hasWebGL","return_context","WebGLRenderingContext","canvas","document","createElement","names","getContext","getParameter","gl","numErrors","THREE","checkRequirements","constructor","prototype","getOutput","otherClass","inflatedData","fileId","rawData","uarr","Uint8Array","rawStrings","String","fromCharCode","subarray","rawString","join","loadTextureFile","imageHeigth","image","width","height","getMat","tex","MeshBasicMaterial","side","BackSide","fog","depthWrite","loadTextureWithFallback","targetMatIndices","materialArray","fallbackFilename","hazeColorAsInt","writeMat","mat","forEach","loadFallback","TextureLoader","load","loadLocalTexture","setTimeout","getHazeColor","environmentChunkData","hazes","dataGlobal","haze","farColor","parseLights","lights","ambientLight","lighting","backlightIntensity","backlightColor","hasLight","light","sumDirLightIntensity","dirLightData","color","Color","directionalLight","DirectionalLight","getHex","intensity","set","direction","normalize","lightDir","AmbientLight","ambientTotal","g","b","parseSkybox","parameterChunkData","skyElements","skyModeTex","texPathNE","texPathSW","texPathT","bounds","rect","mapW","abs","x1","x2","mapD","y1","y2","visible","skyGeometry","BoxGeometry","boxSize","faceVertexUvs","vecs","idx","face","vec2","x","y","uvsNeedUpdate","skyBox","Mesh","translateY","create","getChunk","hazeColor","lastP","seed","meshes","renderModels","models","title","MeshNormalMaterial","DoubleSide","parseAllModels","getCollisionsForAnimation","animation","collisions","ret","collisionIndices","collision","round","animationFromGeomIndex","geometryIndex","geometries","animations","havokChunkData","renderMesh","propGeomIndex","l","model","pos","translate","rot","rotate","scale","mesh","parseHavokMesh","rotation","order","seedRandom","sin","clone","geom","Geometry","vertices","v","Vector3","indices","f1","f2","f3","faces","Face3","computeFaceNormals","boundingBox","boundsMax","propModels","zoneModels","obsModels","mdl","renderZoneModelsCB","propertiesChunkData","props","propArray","animProps","propAnimArray","instanceProps","propInstanceArray","metaProps","propMetaArray","concat","meshCache","textureCache","lastPct","renderIndex","pct","pctStr","prop","addMeshToLOD","groups","lod","needsClone","lodDist","lod2","lodOverride","geometry","material","updateMatrix","matrixAutoUpdate","add","group","Group","addLevel","getMeshesForFilename","isCached","boundingSphere","meshArray","LOD","maxDist","boundingSphereRadius","radius","transforms","transform","update","addMeshesToScene","getFileIdsAsync","fileIds","getIdsForProp","getFilesUsedByModel","propFileIds","strings","end","entryHeaderDef","entryIndex","entry","readStruct","decryptionOffset","bitsPerSymbol","readUCS2String","recid","language","TerrainShader","drawWater","wireframe","opacity","transparent","renderRect","parseNumChunks","terrainData","numChunksD_1","sqrt","dims","chunkArray","numChunksD_2","loadPagedImageCallback","infaltedBuffer","terrainTiles","pimgDS","pimgTableDataChunk","pimgData","mapRect","parameterData","maxAnisotropy","anisotropy","xChunks","yChunks","allMaterials","materials","allTextures","texFileArray","dx","dy","cdx","cdy","allMats","customMaterial","MeshLambertMaterial","flatShading","chunkTextures","strippedPages","page","layer","coord","matName","chunkTex","wrapS","RepeatWrapping","wrapT","stepChunk","cx","cy","water","chunkIndex","pageX","pageY","chunkTextureIndices","loResMaterial","texIndexArray","pageOffetX","pageOffetY","fileNames","gi","textureFileName","pageTexName","pageTexName2","near","far","envOutput","uniforms","UniformsUtils","merge","UniformsLib","uvScale","Vector2","texturePicker","texturePicker2","texture1","texture2","texture3","texture4","ShaderMaterial","fragmentShader","getFragmentShader","vertexShader","getVertexShader","chunkGeo","PlaneBufferGeometry","chunkW","cn","getAttribute","heightMapArray","chunk","mS","Matrix4","identity","elements","applyMatrix","SceneUtils","createMultiMaterialObject","PI","globalOffsetX","chunkOffsetX","globalOffsetY","chunkOffsetY","z","px","py","updateMatrixWorld","renderChunk","pagedImageId","pagedImage","terrainChunk","texture","renderZone","zone","zoneDefs","renderZoneCallback","zoneDef","zd","token","defToken","modelGroups","getModelGroups","groupKeys","stepModels","meshGroups","instanceIdx","meshIdx","materialFlags","move","mg","readVerts","verts","Float32Array","readIndices","getIndex","Uint32Array","readUVs","uvs","readNormals","normals","writeVerts","stride","writeIndices","strideIndices","writeUvs","uvStride","writeNormals","normalStride","meshGroup","mergedGeom","BufferGeometry","addAttribute","BufferAttribute","setIndex","buffersNeedUpdate","mapX","mapY","zoneRect","vertRect","encodeData","zdx","linearPos","flag","zoneDefLayer","layerDefArray","modelX","modelY","modelZ","startZ","raycaster","Raycaster","intersections","intersectObject","distance","modelIdx","modelFilename","modelArray","rotRangeX","rotRangeY","rotRangeZ","scaleRange","fadeRange","zoneChunkData","zones","zoneArray","zoneDefArray","stepZone","HEAD_STRUCT","DUPLICATE_SETTINGS","PACKTOCHUNK","pack","root","addr","setting","regex","RegExp","chunkDef","formats","defsIdx","defs","versions","getRootName","pop","match","definition","__root","genDuplicateSettings","headerLength","NaN","loadHead","useNthIndex","fileTypes","defsFound","chunkVersion","def","getDefinition","chunkDataSize","Chunk","noChunks","chunks","readHead","readChunks","ch","loadData","next","toLowerCase","buildVS","numUv","vdefs","adefs","reads","generateDataTexture","DataTexture","RGBAFormat","buildPS","textures","alphaTest","lightMap","t1uv","uvIdx","discard","writeColor","varyings","getUVMat","numUV","attributes","vs","FrontSide","getTexture","texURL","sharedTextures","finalTexture","flipY","mapping","defaultColor","random","minFilter","LinearMipMapLinearFilter","magFilter","LinearFilter","generateMipmaps","format","needsUpdate","getMaterial","materialFile","finalMaterial","dxChunk","grChunk","finalTextures","textureToken","samplerTex","effect","techniques","passes","effects","samplerTextures","samplerIndex","samplerIdx","sampler","samplers","texTokens","textureIndex","uvPSInputIndex","ft","nt","MeshPhongMaterial","normalMap","textureFilename","shading","FlatShading","alphaMask0","alphaMask1","lightMask","base32Max","pow","f16","h","s","Infinity","popcount","bits","arr","sort_unique","arr_in","comparator","hasOwnProperty","getArrayReader","structDef","maxCount","struct","arr_len","arr_ptr","readType","getRefArrayReader","ret_arr","orgPos","offsets","readInt32Array","pointer","getQWordReader","getStringReader","ptr","getString16Reader","stringOffset","num","getPointerReader","getFileNameReader","fileRef","m_highPart","m_lowPart","matFiles","fvfFormat","Position","Weights","Normal","Tangent","Bitangent","TangentFrame","UV32Mask","UV16Mask","Unknown1","Unknown2","Unknown3","Unknown4","PositionCompressed","Unknown5","renderGeomChunk","modelDataChunk","showUnmaterialed","rawMeshes","mats","permutations","rawMesh","rawGeom","fvf","numVerts","vertexCount","rawVerts","vertDS","distToUV","uv32Flag","uv16Flag","isUV32","hasUV","masked","readFloat32","Uint16Array","computeVertexNormals","uvName","matIdx","materialIndex","finalMesh","materialFilename","materialName","numLods","lods","loadMeshFromModelFile","solidColor","finalMeshes","modelFile","geometryDataChunk","bsc","center","loadMaterialIndex","mIdx","matCallback","yPos","dz","cz","plane","overdraw","sharedMeshes","matFileName","ShaderChunk"],"mappings":"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","file":"T3D-1.1.0.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst MathUtils = require(\"../util/MathUtils\");\n\n/**\n * @file The ArchiveParser module is a set of helper tools to correctly read the Archive.\n * @namespace ArchiveParser\n */\n\n/**\n *    All in one function to read a GW2.dat file and parse all the needed informations to work with it\n *\n * @memberof ArchiveParser\n * @param {File} file\n * @returns {Promise<{archiveHeader: ArchiveHeader, metaTable: MetaTable, indexTable: IndexTable}>}\n */\nasync function readArchive(file) {\n  let archiveHeader = parseANDatHeader((await getFilePart(file, 0, 40)).ds);\n  let mftData = parseMFTTable(\n    (await getFilePart(file, archiveHeader.mftOffset, archiveHeader.mftSize)).ds\n  );\n  let { ds, len } = await getFilePart(\n    file,\n    mftData.mftIndexOffset,\n    mftData.mftIndexSize\n  );\n  let indexTable = parseMFTIndex(ds, len);\n\n  return {\n    archiveHeader: archiveHeader,\n    metaTable: mftData.table,\n    indexTable: indexTable\n  };\n}\n\n/**\n * The header of the archive.\n * @typedef {Object} ArchiveHeader\n * @property {number} version\n * @property {number} magic\n * @property {number} headerSize\n * @property {number} chunkSize\n * @property {number} crc\n * @property {number} mftOffset\n * @property {number} mftSize\n * @property {number} flags\n */\n\n/**\n *   Parse the main information about the archive like format version, positions of information tables, crc etc...\n *\n * @memberof ArchiveParser\n * @param {DataStream} ds\n * @returns {ArchiveIndex} Returns undefined if the header couldn't be parsed\n */\nfunction parseANDatHeader(ds) {\n  let header = {};\n\n  // Header parsing\n  header.version = ds.readUint8();\n  header.magic = ds.readString(3);\n  header.headerSize = ds.readUint32();\n  ds.seek(ds.position + 4); // Skip uint32\n  header.chunkSize = ds.readUint32();\n  header.crc = ds.readUint32();\n  ds.seek(ds.position + 4); // Skip uint32\n  header.mftOffset = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\n  header.mftSize = ds.readUint32();\n  header.flags = ds.readUint32();\n  // End header parsing\n\n  // Check MAGIC\n  if (header.magic !== \"AN\\u001A\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"ANDat header is not valid\",\n      header.magic\n    );\n    return undefined;\n  }\n\n  T3D.Logger.log(T3D.Logger.TYPE_DEBUG, \"Loaded Main .dat header\");\n\n  return header;\n}\n\n/**\n * The array containing all the meta information concerning the contained files\n * @typedef {Array<{offset: number, size: number, compressed: number, crc: number}>} MetaTable\n */\n\n/**\n *   Parse the main information table that contains the offset, size, compression flags and crc\n *\n * @memberof ArchiveParser\n * @param {Datastream}  ds\n * @returns {{header: {magic: String, nbOfEntries: number}, table: MetaTable, mftIndexOffset: number, mftIndexSize: number}|undefined}\n *   Returns undefined if it couldn't parse the table\n */\nfunction parseMFTTable(ds) {\n  // Parse the table header\n  let header = {};\n  header.magic = ds.readString(4);\n  ds.seek(ds.position + 8); // Skip uint64\n  header.nbOfEntries = ds.readUint32();\n  ds.seek(ds.position + 4 + 4); // Skip uint32 * 2\n\n  // check MAGIC\n  if (header.magic !== \"Mft\\u001A\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"MFTTable header is not valid\",\n      header.magic\n    );\n    return undefined;\n  }\n\n  // Where we put all the parsed data\n  // We don't pre-alloc anymore since not having the data aligned together procs too many\n  // cache misses during a fullscan\n  let fullTable = [];\n\n  // Go through the table\n  for (let i = 1; i < header.nbOfEntries; i++) {\n    let item = {};\n    item[\"offset\"] = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\n    item[\"size\"] = ds.readUint32();\n    item[\"compressed\"] = ds.readUint16();\n    ds.seek(ds.position + 4 + 2); // Skip uint16 + uint32\n    item[\"crc\"] = ds.readUint32();\n    fullTable[i] = item;\n  }\n\n  T3D.Logger.log(T3D.Logger.TYPE_DEBUG, \"Loaded MFTTable\");\n\n  return {\n    header: header,\n    table: fullTable,\n    // Register the MFTIndex table position and size\n    mftIndexOffset: fullTable[2].offset,\n    mftIndexSize: fullTable[2].size\n  };\n}\n\n/**\n * The array linking all the file indexes to their respective files\n * @typedef {Array<number>} IndexTable\n */\n\n/**\n *   This function used to be much more complex with the use of\n *   a \"fileId\" which in the end was just the equivalent of\n *   MFTbaseIds[mftId].sort().reverse()[0] (aka the bigger baseId found)\n *\n * @memberof ArchiveParser\n * @param {DataStream} ds\n * @param {number} size\n * @returns {IndexTable}\n */\nfunction parseMFTIndex(ds, size) {\n  let length = size / 8;\n\n  let indexTable = [];\n\n  for (let i = 0; i < length; i++) {\n    // Parse table\n    let id = ds.readUint32();\n    let mftIndex = ds.readUint32();\n    // Store the values\n    indexTable[id] = mftIndex;\n  }\n\n  T3D.Logger.log(T3D.Logger.TYPE_DEBUG, \"Finished indexing MFT\");\n\n  return indexTable;\n}\n\n/**\n *   Get a chunk of the specified file. Used mainly to take parts of the Archive before parsing.\n *\n * @memberof ArchiveParser\n * @param {File} file\n * @param {number} offset\n * @param {number} length\n * @returns {Promise<{ds: DataStream, len: number}>}\n */\nfunction getFilePart(file, offset, length) {\n  return new Promise((resolve, reject) => {\n    let reader = new FileReader();\n\n    reader.onerror = reject;\n\n    reader.onload = function(fileEvent) {\n      let buffer = fileEvent.target.result;\n      let ds = new DataStream(buffer);\n      ds.endianness = DataStream.LITTLE_ENDIAN;\n      // Pass data stream and data length to callback function\n      resolve({ ds: ds, len: length });\n    };\n\n    // Slicing a File is just reducing the scope of the ArrayBuffer, but doesn't load anything in memory.\n    reader.readAsArrayBuffer(file.slice(offset, offset + length));\n  });\n}\n\nmodule.exports = {\n  readArchive: readArchive,\n  parseANDatHeader: parseANDatHeader,\n  parseMFTTable: parseMFTTable,\n  parseMFTIndex: parseMFTIndex,\n  getFilePart: getFilePart\n};\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Organized thread pool of extractors\n * @class DataReader\n */\nclass DataReader {\n  /**\n   * @constructor\n   * @param {Object} settings\n   * @param {number} settings.workersNb Amount of concurrent spawned workers\n   * @param {string} settings.workerPath Path to the worker script\n   */\n  constructor(settings) {\n    this._settings = settings;\n    this._workerPool = [];\n    this._workerLoad = [];\n    this._inflateCallbacks = [];\n    for (let i = 0; i < settings.workersNb; i++) {\n      this._startWorker(settings.workerPath);\n    }\n  }\n\n  /**\n   * @param {DataStream} ds\n   * @param {number} size\n   * @param {number} mftId\n   * @param {boolean} [isImage] Parses the output as a dxt texture\n   * @param {number} [capLength] Output size\n   * @returns {Promise<{buffer: ArrayBuffer, dxtType: number, imageWidth: number, imageHeight: number}>}\n   */\n  inflate(ds, size, mftId, isImage, capLength) {\n    return new Promise((resolve, reject) => {\n      let arrayBuffer = ds.buffer;\n\n      // If no capLength then inflate the whole file\n      if (!capLength || capLength < 0) {\n        capLength = 0;\n      }\n\n      // Buffer length size check\n      if (arrayBuffer.byteLength < 12) {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_WARNING,\n          `not inflating, length is too short (${arrayBuffer.byteLength})`,\n          mftId\n        );\n        reject(new Error(\"Couldn't inflate \" + mftId + \" (mftId)\"));\n        return;\n      }\n\n      // Register the callback\n      if (this._inflateCallbacks[mftId]) {\n        this._inflateCallbacks[mftId].push({\n          resolve: resolve,\n          reject: reject\n        });\n\n        /// No need to make another call, just wait for callback event to fire.\n        return;\n      } else {\n        this._inflateCallbacks[mftId] = [{ resolve: resolve, reject: reject }];\n      }\n\n      // Add the load to the worker\n      let workerId = this._getBestWorkerIndex();\n      this._workerLoad[workerId] += 1;\n      this._workerPool[workerId].postMessage([\n        mftId,\n        arrayBuffer,\n        isImage === true,\n        capLength\n      ]);\n    });\n  }\n\n  // Initialization function for creating a new worker (thread)\n  _startWorker(path) {\n    let self = this;\n    let worker = new Worker(path);\n    let selfWorkerId = this._workerPool.push(worker) - 1;\n    if (this._workerLoad.push(0) !== selfWorkerId + 1) {\n      throw new Error(\"WorkerLoad and WorkerPool don't have the same length\");\n    }\n\n    worker.onmessage = function(message_event) {\n      let mftId;\n      // Remove load\n      self._workerLoad[selfWorkerId] -= 1;\n\n      // If error\n      if (typeof message_event.data === \"string\") {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_WARNING,\n          \"Inflater threw an error\",\n          message_event.data\n        );\n        mftId = message_event.data.split(\":\")[0];\n        for (let callback of self._inflateCallbacks[mftId]) {\n          callback.reject();\n        }\n      } else {\n        mftId = message_event.data[0];\n        // On success\n        if (self._inflateCallbacks[mftId]) {\n          for (let callback of self._inflateCallbacks[mftId]) {\n            let data = message_event.data;\n            // Array buffer, dxtType, imageWidth, imageHeight\n            callback.resolve({\n              buffer: data[1],\n              dxtType: data[2],\n              imageWidth: data[3],\n              imageHeight: data[4]\n            });\n          }\n          // Remove triggered listeners\n          self._inflateCallbacks[mftId] = null;\n        }\n\n        // Unknown error\n        else {\n          T3D.Logger.log(\n            T3D.Logger.TYPE_ERROR,\n            \"Inflater threw an error\",\n            message_event.data\n          );\n        }\n      }\n    };\n  }\n\n  // Get the worker with the less load\n  _getBestWorkerIndex() {\n    return this._workerLoad.indexOf(Math.min(...this._workerLoad));\n  }\n}\n\nmodule.exports = DataReader;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require(\"../format/file/GW2File.js\");\n\n/**\n * @namespace FileTypes\n */\n\nlet FileTypes = {};\n\n/**\n * Parse the beginning of a file to find its type\n *\n * @memberof FileTypes\n * @param {DataStream} ds\n * @return {number}\n */\nFileTypes.getFileType = function(ds) {\n  let first4 = ds.readCString(4);\n\n  // Parse textures\n  switch (first4) {\n    case \"ATEC\":\n      return \"TEXTURE_ATEC\";\n    case \"ATEP\":\n      return \"TEXTURE_ATEP\";\n    case \"ATET\":\n      return \"TEXTURE_ATET\";\n    case \"ATEU\":\n      return \"TEXTURE_ATEU\";\n    case \"ATEX\":\n      return \"TEXTURE_ATEX\";\n    case \"ATTX\":\n      return \"TEXTURE_ATTX\";\n  }\n\n  if (first4.indexOf(\"DDS\") === 0) return \"TEXTURE_DDS\";\n\n  if (first4.indexOf(\"PNG\") === 1) return \"TEXTURE_PNG\";\n\n  if (first4.indexOf(\"RIFF\") === 0) return \"TEXTURE_RIFF\";\n\n  if (first4.indexOf(\"YUI\") === 0) return \"TEXT_YUI\";\n\n  // PackFiles\n  if (first4.indexOf(\"PF\") === 0) {\n    let file = new GW2File(ds, 0, true); /// true for \"plz no load chunkz\"\n    return \"PF_\" + file.header.type;\n  }\n\n  // Binaries\n  if (first4.indexOf(\"MZ\") === 0) return \"BINARIES\";\n\n  // Strings\n  if (first4.indexOf(\"strs\") === 0) return \"STRINGS\";\n\n  // Raw asnd chunk (without pack file)\n  if (first4.indexOf(\"asnd\") === 0) return \"CHUNK_ASND\";\n\n  // TODO: parse all datastream and if all bytes are valid unicode symbols then\n  // return TEXT_UNKNOWN;\n\n  // Unknown\n  return \"UNKNOWN\";\n};\n\nmodule.exports = FileTypes;\n","/*\r\nCopyright © Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst ArchiveParser = require(\"./ArchiveParser\");\r\nconst PersistantStore = require(\"./PersistantStore\");\r\nconst DataReader = require(\"./DataReader\");\r\nconst MapFileList = require(\"../MapFileList\");\r\nconst FileTypes = require(\"./FileTypes\");\r\n\r\n/**\r\n * A statefull class that handles reading and inflating data from a local GW2 dat file.\r\n * LocalReader have been completely rewritten from scratch,\r\n * the API changed quite a lot between 1.0.4 and 1.1.0.\r\n *\r\n * API CHANGES: LocalReader (1.1.0 from 1.0.4)\r\n * - The constructor have __changed__.\r\n * - parseHeaderAsync have been __removed__.\r\n * - connectInflated have been __removed__.\r\n * - NaClListener have been __removed__.\r\n * - readANDatHeader have been __removed__.\r\n * - readMFTHeader have been __removed__.\r\n * - readMFTIndexFile have been __removed__.\r\n * - loadFileList is now __deprecated__.\r\n * - loadMapList is now __deprecated__.\r\n * - storeFileList have been __removed__.\r\n * - storeMapList have been __removed__.\r\n * - readFileListAsync is now __deprecated__.\r\n * - readMapListAsync is now __deprecated__.\r\n * - listFiles have been __removed__.\r\n * - getFileIndex have been slightly __changed__.\r\n * - loadTextureFile is now __deprecated__.\r\n * - loadFile have been __removed__.\r\n * - inflate have been __removed__.\r\n * - loadFilePart have been __removed__.\r\n *\r\n * @param {{workerPath: String, workersNb: number, noIndexedDB: boolean}} settings\r\n *   * workerPath: the path to the t3dtools worker script file.\r\n *   * workersNb: amount of threads spawned for decompression.\r\n *   * noIndexedDB: Do not use indexedDB (persistant storage, default is true)\r\n */\r\nclass LocalReader {\r\n  constructor(settings) {\r\n    this._settings = settings;\r\n\r\n    /**\r\n     * @private\r\n     * @type {DataReader}\r\n     */\r\n    this._dataReader = new DataReader(settings);\r\n\r\n    /**\r\n     * @private\r\n     * @type {PersistantStore}\r\n     */\r\n    this._persistantStore;\r\n\r\n    /**\r\n     * @private\r\n     * @type {File}\r\n     */\r\n    this._file = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\r\n    this._indexTable = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<{offset: number, size: number, compressed: number, crc: number}>}\r\n     */\r\n    this._fileMetaTable = [];\r\n\r\n    if (settings.noIndexedDB !== false) {\r\n      this._persistantStore = new PersistantStore();\r\n    }\r\n  }\r\n\r\n  /**\r\n   *   Asynchronously loads the archive by parsing its file index and header.\r\n   *\r\n   * @param {File} file\r\n   * @returns {Promise}\r\n   */\r\n  async openArchive(file) {\r\n    let { metaTable, indexTable } = await ArchiveParser.readArchive(file);\r\n    this._fileMetaTable = metaTable;\r\n    this._indexTable = indexTable;\r\n    this._file = file;\r\n  }\r\n\r\n  /**\r\n   *   Gets MFT index by baseId\r\n   *\r\n   * @param  {Number} baseId   A base Id\r\n   * @return {Number}          MFT index\r\n   */\r\n  getFileIndex(baseId) {\r\n    return this._indexTable[baseId];\r\n  }\r\n\r\n  /**\r\n   *   \"Meta\" informations to deal with files in the archive.\r\n   * @typedef     {Object}    FileMetaData\r\n   * @property    {number}    offset\r\n   * @property    {number}    size\r\n   * @property    {number}    compressed\r\n   * @property    {number}    crc\r\n   */\r\n\r\n  /**\r\n   *   Returns the metadata of a file stored in the archive\r\n   *\r\n   * @param {number} mftId Mft index of the file\r\n   * @returns {FileMetaData} Metadata informations\r\n   */\r\n  getFileMeta(mftId) {\r\n    return this._fileMetaTable[mftId];\r\n  }\r\n\r\n  /**\r\n   *   Fetch a file and uncompress it if needed / required.\r\n   *\r\n   * @param {number} mftId File's archive ID\r\n   * @param {boolean} [isImage] Try to read the data as a Dxt texture.\r\n   * @param {boolean} [raw] Force no decompression.\r\n   * @param {number} [fileLength] Slice the uncompressed file.\r\n   * @param {number} [extractLength] Slice the decompression.\r\n   * @returns {Promise<{buffer: ArrayBuffer, dxtType: number|undefined, imageWidth: number|undefined, imageHeight: number|undefined}>}\r\n   */\r\n  async readFile(mftId, isImage, raw, fileLength, extractLength) {\r\n    //let buffer, dxtType, imageWidth, imageHeight;\r\n    let meta = this.getFileMeta(mftId);\r\n    if (!meta) throw new Error(\"Unexistant file\");\r\n\r\n    // Slice up the data\r\n    let { ds, len } = await ArchiveParser.getFilePart(\r\n      this._file,\r\n      meta.offset,\r\n      fileLength || meta.size\r\n    );\r\n\r\n    // If needed we decompress, if not we keep raw\r\n    if (meta.compressed || raw !== false) {\r\n      let data;\r\n      await this._dataReader\r\n        .inflate(ds, len, mftId, isImage, extractLength || 0)\r\n        .then(result => {\r\n          data = result;\r\n        })\r\n        .catch(() => {\r\n          data = {\r\n            buffer: undefined,\r\n            dxtType: undefined,\r\n            imageWidth: undefined,\r\n            imageHeight: undefined\r\n          };\r\n        });\r\n      return data;\r\n    } else return { buffer: ds.buffer };\r\n  }\r\n\r\n  /**\r\n   *   Scans asynchronously the types of all the files listed in the archive.\r\n   *   Uses persistant store to cache and speed up a rescan.\r\n   *\r\n   * @param {Array<{baseId: number, size: number, crc: number, fileType: string}>|undefined} oldFileList\r\n   *   Way for platform not supporting indexDB to provide their own persistant storage.\r\n   * @returns {Promise<Array<FileItem>>}\r\n   */\r\n  async readFileList(oldFileList) {\r\n    let self = this;\r\n\r\n    let persistantList = oldFileList || [];\r\n    let persistantId;\r\n\r\n    // Load previously saved data\r\n    if (this._persistantStore) {\r\n      let lastListing = await this._persistantStore.getLastListing(\r\n        this._file.name\r\n      );\r\n      persistantList = lastListing.array;\r\n      // If the last scan was not completed then we will just update it..\r\n      if (!lastListing.complete) {\r\n        persistantId = lastListing.key;\r\n      }\r\n    }\r\n\r\n    // Create a list of all the baseIds we need to inspect\r\n    let iterateList = Object.keys(self._indexTable).map(i => Number(i));\r\n    for (let index in persistantList) {\r\n      if (!(index in self._indexTable)) iterateList.push(index);\r\n    }\r\n\r\n    // Helps us to know when we need to update the persistant store\r\n    // let updatePersistant = false;\r\n\r\n    // Spawn the decompression tasks\r\n    let taskArray = [];\r\n    for (let i = 0; i < 1; i++) {\r\n      taskArray[i] = Promise.resolve({ task: i });\r\n    }\r\n\r\n    let persistantNeedsUpdate = false;\r\n\r\n    // Iterate through the array\r\n    for (let index in iterateList) {\r\n      let baseId = iterateList[index];\r\n\r\n      // First use a synchronous function to know if we need to scan the file\r\n      let result = this._needsScan(baseId, persistantList);\r\n      if (result.scan === true) {\r\n        let taskId = (await Promise.race(taskArray)).task;\r\n        taskArray[taskId] = this._readFileType(baseId).then(scanResult => {\r\n          // Put the result into our persistant storage\r\n          persistantList[baseId] = {\r\n            baseId: baseId,\r\n            size: scanResult.size,\r\n            crc: scanResult.crc,\r\n            fileType: scanResult.fileType\r\n          };\r\n          return { task: taskId };\r\n        });\r\n      }\r\n      if (result.change === \"removed\") {\r\n        // Update the persistant storage\r\n        delete persistantList[baseId];\r\n      }\r\n\r\n      // Handle persistant storage update\r\n      if (result.change !== \"none\") persistantNeedsUpdate = true;\r\n\r\n      // Tasks to do only every %\r\n      if (index % Math.floor(iterateList.length / 100) === 0) {\r\n        // Print progress\r\n        T3D.Logger.log(\r\n          T3D.Logger.TYPE_PROGRESS,\r\n          \"Finding types\",\r\n          index / Math.floor(iterateList.length / 100)\r\n        );\r\n\r\n        // Update the persistant storage if needed\r\n        if (self._persistantStore && persistantNeedsUpdate) {\r\n          persistantNeedsUpdate = false;\r\n          self._persistantStore\r\n            .putListing(persistantId, persistantList, self._file.name, false)\r\n            .then(res => (persistantId = res));\r\n        }\r\n      }\r\n    }\r\n\r\n    await Promise.all(taskArray).then(() => {\r\n      // Finally update the listing as complete\r\n      if (self._persistantStore) {\r\n        self._persistantStore.putListing(\r\n          persistantId,\r\n          persistantList,\r\n          self._file.name,\r\n          true\r\n        );\r\n      }\r\n    });\r\n    this._persistantData = persistantList;\r\n    return this.getFileList();\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} MapItem\r\n   * @property {string} name\r\n   * @property {string} category\r\n   * @property {number} baseId\r\n   */\r\n\r\n  /**\r\n   *   Returns a list of all the maps with their name and category.\r\n   *   Uncategorized maps are available only if readFileList have been used before.\r\n   *\r\n   * @returns {Array<MapItem>}\r\n   */\r\n  getMapList() {\r\n    let self = this;\r\n    let mapArray = [];\r\n    // If the archive have been scanned for all its file we iterate through the results\r\n    if (this._persistantData) {\r\n      // Filter the maps out of all our files\r\n      let reversedIndex = this.getReverseIndex();\r\n      let maps = this._persistantData\r\n        .filter(file => file.fileType === \"PF_mapc\")\r\n        .filter(\r\n          id => id.baseId === reversedIndex[self.getFileIndex(id.baseId)][0]\r\n        );\r\n\r\n      for (let map of maps) {\r\n        let found = false;\r\n        // Try to see if we already have some informations on this map\r\n        for (let category of MapFileList.maps) {\r\n          let fileMap = category.maps.find(\r\n            item => Number(item.fileName.split(\".data\")[0]) === map.baseId\r\n          );\r\n          if (fileMap) {\r\n            mapArray.push({\r\n              name: fileMap.name,\r\n              category: category.name,\r\n              baseId: map.baseId\r\n            });\r\n            found = true;\r\n            break;\r\n          }\r\n        }\r\n        // If not we register it as Uncategorized\r\n        if (!found) {\r\n          mapArray.push({\r\n            name: map.baseId.toString(),\r\n            category: \"Uncategorized\",\r\n            baseId: map.baseId\r\n          });\r\n        }\r\n      }\r\n    }\r\n    // If not then we check only known maps\r\n    else {\r\n      for (let category of MapFileList.maps) {\r\n        for (let mapEntry of category.maps) {\r\n          if (Number(mapEntry.fileName.split(\".data\")[0]) in this._indexTable) {\r\n            mapArray.push({\r\n              name: mapEntry.name,\r\n              category: category.name,\r\n              baseId: Number(mapEntry.fileName.split(\".data\")[0])\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return mapArray;\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} FileItem\r\n   * @property {number} mftId\r\n   * @property {Array<number>} baseIdList\r\n   * @property {number} size\r\n   * @property {number} crc\r\n   * @property {string} fileType\r\n   **/\r\n\r\n  /**\r\n   *   Return the meta table with extra information such as an array of baseIds and the file types.\r\n   *   The filetype is available only if readFileList have been used before of course.\r\n   *\r\n   * @returns {Array<FileItem>}\r\n   */\r\n  getFileList() {\r\n    let typeList = this._persistantData\r\n      ? this._persistantData.map(i => i.fileType)\r\n      : [];\r\n    let reverseBaseIdList = this.getReverseIndex();\r\n\r\n    let fileList = this._fileMetaTable.map((meta, mftId) => {\r\n      let baseIds = reverseBaseIdList[mftId] ? reverseBaseIdList[mftId] : [];\r\n      let type = reverseBaseIdList[mftId]\r\n        ? typeList[baseIds[0]]\r\n        : \"Non-Registered\";\r\n      return {\r\n        mftId: mftId,\r\n        baseIdList: baseIds,\r\n        size: meta.size,\r\n        crc: meta.crc,\r\n        fileType: type\r\n      };\r\n    });\r\n    fileList[0] = {\r\n      mftId: 0,\r\n      baseIdList: [],\r\n      size: 0,\r\n      crc: 0,\r\n      fileType: \"Non-Registered\"\r\n    };\r\n    return fileList;\r\n  }\r\n\r\n  /**\r\n   * @returns {Array<Array<number>>}\r\n   */\r\n  getReverseIndex() {\r\n    return this._indexTable.reduce((reversed, mftId, baseId) => {\r\n      if (mftId in reversed) reversed[mftId].push(baseId);\r\n      else reversed[mftId] = [baseId];\r\n      return reversed;\r\n    }, []);\r\n  }\r\n\r\n  // API Compatibility\r\n\r\n  /**\r\n     * Looks up mft indices for all mapc pack files in the dat. Either looks trough all files or\r\n     * only the list defined in {@link MapFileList}\r\n     *\r\n     * @deprecated Use now the getFileList method.\r\n     * @param  {boolean}   searchAll if true forces re-indexing of entire dat.\r\n     * If false only reads indices specified in \"T3D/MapFileList\".\r\n     * @param  {Function} callback Fired when the list is generated\r\n     *\r\n     * First argument is the a list of mft indices grouped by file type. For exmample:\r\n     *\r\n     * \t\t{\r\n     * \t\t\tmaps:[\r\n     * \t\t\t\t{\r\n     * \t\t\t\t\tname: 'Heart of Maguuma',\r\n     * \t\t\t\t\tmaps: [\r\n     * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\r\n     * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\r\n     * \t\t\t\t\t]\r\n     * \t\t\t\t},\r\n     * \t\t\t\t{\r\n     * \t\t\t\t\tname: 'Unknown maps',\r\n     * \t\t\t\t\tmaps: [\r\n     * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\r\n     * \t\t\t\t\t]\r\n     * \t\t\t\t}\r\n     * \t\t\t]\r\n\r\n    *\t    };\r\n    */\r\n  readMapListAsync(searchAll, callback) {\r\n    let self = this;\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.readMapListAsync is deprecated !\"\r\n    );\r\n\r\n    // Let's preserve the old output way\r\n    function restoreOuput(array) {\r\n      let returnArray = [];\r\n      for (let elt of array) {\r\n        let category = returnArray.findIndex(i => i.name === elt.category);\r\n        if (category === -1) {\r\n          category = returnArray.push({ name: elt.category, maps: [] }) - 1;\r\n        }\r\n        returnArray[category].maps.push({\r\n          fileName: elt.baseId,\r\n          name: elt.name\r\n        });\r\n      }\r\n      // And resort it in order\r\n      returnArray.sort((i, j) => {\r\n        if (i.name < j.name) return -1;\r\n        if (i.name > j.name) return 1;\r\n        return 0;\r\n      });\r\n      return { maps: returnArray };\r\n    }\r\n\r\n    /// If seachAll flag is true, force a deep search\r\n    if (searchAll) {\r\n      this.readFileList().then(() => {\r\n        callback(restoreOuput(self.getMapList()));\r\n      });\r\n    } else {\r\n      callback(restoreOuput(self.getMapList()));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reads the file type of each file in the dat and stores the resulting list in\r\n   * the browser's local storage.\r\n   *\r\n   * @deprecated Use now the readFileList or getFileList methods.\r\n   * @param  {Function} callback Fired when the list is generated and stores\r\n   *\r\n   * First argument is the a list of mft indices grouped by file type.\r\n   */\r\n  readFileListAsync(callback) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.readFileListAsync is deprecated !\"\r\n    );\r\n\r\n    // Because the API changed we reform the data as wanted previously\r\n    this.readFileList().then(result => {\r\n      let returnObj = {};\r\n      for (let fileEntry of result) {\r\n        if (returnObj[fileEntry.fileType] === undefined) {\r\n          returnObj[fileEntry.fileType] = [];\r\n        }\r\n        returnObj[fileEntry.fileType].push(fileEntry.mftId);\r\n      }\r\n      callback(returnObj);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reads data from a file in the dat.\r\n   *\r\n   * @deprecated Use now the Promise-based method readFile.\r\n   * @param  {Number}   baseId   Base or File id of the texture to load\r\n   * @param  {Function} callback Fires when the inflater has read the data.\r\n   *\r\n   * The passed arguments are\r\n   * -ArrayBuffer raw data\r\n   * -Number DXT Type if applicable\r\n   * -Number image width if applicable\r\n   * -Number image height if applicable\r\n   *\r\n   *\r\n   * @param  {boolean}  isImage\r\n   * @param  {boolean}   raw      If true, any infation is skipped and raw data is returned.\r\n   */\r\n  loadFile(baseId, callback, isImage, raw) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadFile is deprecated !\"\r\n    );\r\n    let mftId = this.getFileIndex(baseId);\r\n    if (mftId <= 0) return callback(null);\r\n    this.readFile(mftId, isImage, raw).then(result => {\r\n      if (result.buffer === undefined) return callback(null);\r\n      callback(\r\n        result.buffer,\r\n        result.dxtType,\r\n        result.imageWidth,\r\n        result.imageHeight\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reads a bitmap from a texture file in the dat.\r\n   *\r\n   * @deprecated\r\n   * @param  {Number}   baseId   Base or File id of the texture to load\r\n   * @param  {Function} callback Fires when the inflater has read the texture data.\r\n   *\r\n   * The passed arguments are\r\n   * -ArrayBuffer Bitmap\r\n   * -Number DXT Type\r\n   * -Number image width\r\n   * -Number image height\r\n   *\r\n   */\r\n  loadTextureFile(baseId, callback) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadTextureFile is deprecated !\"\r\n    );\r\n\r\n    this.loadFile(baseId, callback, true);\r\n  }\r\n\r\n  /**\r\n   * Used to read the cached list of files corresponding to the reader's .dat from the localStorage.\r\n   * Now kept only for backward compatibility, but doesn't do anything.\r\n   * Please use getFileList now.\r\n   *\r\n   * @deprecated\r\n   */\r\n  loadFileList() {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadFileList is deprecated !\"\r\n    );\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Used to read the cached list of maps corresponding to the reader's .dat from the localStorage.\r\n   * Now kept only for backward compatibility, but doesn't do anything.\r\n   * Please use getMapList now.\r\n   *\r\n   * @deprecated\r\n   */\r\n  loadMapList() {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadMapList is deprecated !\"\r\n    );\r\n    return undefined;\r\n  }\r\n\r\n  // Private\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} baseId\r\n   * @param {Array<{baseId: number, crc: number, size: number, fileType: string}>} persistantData\r\n   * @returns {{scan: boolean, change: string }}\r\n   */\r\n  _needsScan(baseId, persistantData) {\r\n    if (baseId <= 0) return { change: \"none\", scan: false };\r\n\r\n    let mftId = this.getFileIndex(baseId);\r\n    let metaData = this.getFileMeta(mftId);\r\n\r\n    // Nothing interesting\r\n    if (metaData === undefined && !(baseId in persistantData)) {\r\n      return { change: \"none\", scan: false };\r\n    }\r\n    // If the file have been deleted\r\n    else if (metaData === undefined) {\r\n      return { change: \"removed\", scan: false };\r\n    }\r\n    // If the file is new\r\n    else if (!(baseId in persistantData)) {\r\n      return { change: \"added\", scan: true };\r\n    }\r\n    // If the size or crc don't match\r\n    else if (\r\n      metaData.size !== persistantData[baseId].size ||\r\n      metaData.crc !== persistantData[baseId].crc\r\n    ) {\r\n      return { change: \"modified\", scan: true };\r\n    }\r\n    // If everything is the same\r\n    else {\r\n      return { change: \"none\", scan: false };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} baseId\r\n   * @param {Array<{baseId: number, crc: number, size: number, fileType: string}>} persistantData\r\n   * @returns {Promise<{fileType: string, crc: number, size: number}>}\r\n   */\r\n  async _readFileType(baseId) {\r\n    if (!this._fileTypeCache) this._fileTypeCache = [];\r\n\r\n    let mftId = this.getFileIndex(baseId);\r\n    let metaData = this.getFileMeta(mftId);\r\n\r\n    let fileType;\r\n    if (this._fileTypeCache[baseId] !== undefined) {\r\n      fileType = this._fileTypeCache[baseId];\r\n    } else {\r\n      let fileBuffer = (await this.readFile(\r\n        mftId,\r\n        false,\r\n        false,\r\n        Math.min(metaData.size, 1000),\r\n        32\r\n      )).buffer;\r\n      if (fileBuffer === undefined) return undefined;\r\n      fileType = FileTypes.getFileType(new DataStream(fileBuffer));\r\n    }\r\n    return { fileType: fileType, crc: metaData.crc, size: metaData.size };\r\n  }\r\n}\r\n\r\nmodule.exports = LocalReader;\r\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/// Indexed DB versioning\nconst DB_VERSION = 4;\n\n/**\n * This class handles offline storage of the .dat indexes and files metadata\n * @class PersistantStore\n */\nclass PersistantStore {\n  constructor() {\n    // They may be multiple connection request issued at the same time, but it's actually okay since\n    // as soon as they are registered, the not-used ones will get garbage collected\n    this._dbConnection = undefined;\n    this._getConnection(() => {});\n  }\n\n  /**\n   *   Initialize the IndexedDB connection and manages version changes.\n   *\n   * @async\n   * @private\n   * @returns {Promise<IDBDatabase>} Promise to the Database connection\n   */\n  _getConnection() {\n    let self = this;\n    return new Promise((resolve, reject) => {\n      if (self._dbConnection) resolve(self._dbConnection);\n\n      // Let us open our database\n      let request = window.indexedDB.open(\"Tyria3DLibrary\", DB_VERSION);\n\n      /// onblocked is fired when the db needs an upgrade but an older version is opened in another tab\n      request.onblocked = () => {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_ERROR,\n          \"The T3D persistant database cannot be upgraded while the app is opened somewhere else.\"\n        );\n      };\n\n      /// fired when the database needs to be upgraded (or the first time)\n      request.onupgradeneeded = event => {\n        /** @type {IDBDatabase} */\n        let db = event.target.result;\n        let currentVersion = event.oldVersion;\n\n        if (currentVersion < 2) {\n          db.createObjectStore(\"listings\", {\n            autoIncrement: true\n          });\n        }\n\n        if (currentVersion < 3) {\n          let storeListing = event.currentTarget.transaction.objectStore(\n            \"listings\"\n          );\n          storeListing.createIndex(\"filename\", \"filename\", { unique: false });\n        }\n      };\n\n      request.onsuccess = event => {\n        self._dbConnection = event.target.result;\n        self.isReady = true;\n        resolve(self._dbConnection);\n      };\n\n      request.onerror = () => {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_ERROR,\n          \"The T3D persistant database could not be opened.\"\n        );\n        reject();\n      };\n    });\n  }\n\n  /**\n   *   Add or update a listing into the database\n   *\n   * @async\n   * @param {number|undefined} id This ID doesn't really matter, it's just the index of the object in the database, can be undefined\n   * @param {Array} listing\n   * @param {string} fileName .dat file name, allows to have multiple listings for different .dat files.\n   * @param {boolean} isComplete Keep back the information if that was the last update on the current scan or not.\n   * @returns {Promise<number>} On success, the number is the object key in the database\n   */\n  putListing(id, listing, fileName, isComplete) {\n    let self = this;\n    return new Promise((resolve, reject) => {\n      self._getConnection().then(db => {\n        let store = db\n          .transaction([\"listings\"], \"readwrite\")\n          .objectStore(\"listings\");\n\n        let request = id\n          ? store.put(\n              { array: listing, filename: fileName, complete: isComplete },\n              id\n            )\n          : store.put({ array: listing, name: fileName });\n\n        request.onsuccess = () => {\n          resolve(request.result);\n        };\n        request.onerror = () => {\n          reject();\n        };\n      });\n    });\n  }\n\n  /**\n   * Returns the last valid listing in the database\n   *\n   * @async\n   * @param {string} fileName .dat file name, allows to have multiple listings for different .dat files.\n   * @returns {Promise<{array: Array, key: number, complete: boolean}>}\n   *      array: the last listing\n   *      key: the index of the last listing in the database\n   */\n  getLastListing(fileName) {\n    let self = this;\n    return new Promise(resolve => {\n      self._getConnection().then(db => {\n        let listingsStore = db\n          .transaction([\"listings\"], \"readonly\")\n          .objectStore(\"listings\")\n          .index(\"filename\");\n\n        listingsStore.openCursor(\n          IDBKeyRange.only(fileName),\n          \"prev\"\n        ).onsuccess = event => {\n          let cursor = event.target.result;\n          if (!cursor) resolve({ array: [], key: undefined, complete: true });\n          else {\n            resolve({\n              array: cursor.value.array,\n              key: cursor.primaryKey,\n              complete: cursor.value.complete\n            });\n          }\n        };\n      });\n    });\n  }\n}\n\nmodule.exports = PersistantStore;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * A Logger class for T3D\n *\n * This satic class defines severity levels of messages and provides\n * basic logging functionality. Replacing the reference to\n *\n * @namespace\n * @static\n */\nlet Logger = {};\n\n/**\n * @readonly\n * @property {number} TYPE_ERROR\n */\nLogger.TYPE_ERROR = 4;\n\n/**\n * @readonly\n * @property {number} TYPE_WARNING\n */\nLogger.TYPE_WARNING = 3;\n\n/**\n * @readonly\n * @property {number} TYPE_MESSAGE\n */\nLogger.TYPE_MESSAGE = 2;\n\n/**\n * @readonly\n * @property {number} TYPE_PROGRESS\n */\nLogger.TYPE_PROGRESS = 1;\n\n/**\n * @readonly\n * @property {number} TYPE_DEBUG\n */\nLogger.TYPE_DEBUG = 0;\n\n/**\n * The logging functions, indexed by severity/type.\n *\n * @property logFunctions\n * @type Function[]\n */\nLogger.logFunctions = new Array(5);\n\n/**\n * Main logging method. Takes 1 to N arguments. If there are more than 1 arguments\n * the first argument is interpreted as severity. If there is only one argument\n * severity defaults to\n * {{#crossLink \"Logger/TYPE_MESSAGE:property\"}}{{/crossLink}}.\n *\n * The following arguments are passed to a logging function matching the\n * severity.\n *\n\n *\n */\nLogger.log = function() {\n  /// Require at least 1 argument\n  if (arguments.length === 0) {\n    return;\n  }\n\n  /// Parse arguments to an actual array\n  let argArr = Logger.argsToArr(arguments);\n\n  /// Default to message if just one argument was passed\n  if (argArr.length === 1) {\n    argArr.unshift(Logger.TYPE_MESSAGE);\n  }\n\n  /// Otherwise 1st arg is severity, log/warn/error\n  let severity = Math.max(\n    0,\n    Math.min(Logger.logFunctions.length, argArr.shift())\n  );\n  let logFunc = Logger.logFunctions[severity];\n\n  /// Ouput the rest of the arguments\n  logFunc.apply(this, argArr);\n};\n\nLogger.argsToArr = function(args) {\n  let argArr = new Array(args.length);\n  for (let i = 0; i < argArr.length; ++i) {\n    argArr[i] = args[i];\n  }\n  return argArr;\n};\n\nLogger.logFunctions[Logger.TYPE_ERROR] = function() {\n  console.error.apply(console, arguments);\n};\n\nLogger.logFunctions[Logger.TYPE_WARNING] = function() {\n  console.warn.apply(console, arguments);\n};\n\nLogger.logFunctions[Logger.TYPE_MESSAGE] = function() {\n  console.log.apply(console, arguments);\n};\n\nLogger.logFunctions[Logger.TYPE_PROGRESS] = function() {\n  let argArr = Logger.argsToArr(arguments);\n  argArr.unshift(\"Progress: \");\n  console.log.apply(console, argArr);\n};\n\nLogger.logFunctions[Logger.TYPE_DEBUG] = function() {\n  let argArr = Logger.argsToArr(arguments);\n  console.debug.apply(console, argArr);\n};\n\nmodule.exports = Logger;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = {\n  /**\n   * @property maps\n   * @type {Array.<{name: String, maps: Array.<{fileName: String, name: String}>}>}\n   */\n  maps: [\n    {\n      name: \"01. Shiverpeaks\",\n      maps: [\n        { fileName: \"125199.data\", name: \"Wayfarer Foothills (0)\" },\n        { fileName: \"187611.data\", name: \"Wayfarer Foothills (1)\" },\n        { fileName: \"568778.data\", name: \"Cragstead\" },\n        { fileName: \"132434.data\", name: \"Hoelbrak (0)\" },\n        { fileName: \"197122.data\", name: \"Hoelbrak (1)\" },\n        { fileName: \"1966018.data\", name: \"Hoelbrak (2)\" },\n        { fileName: \"124093.data\", name: \"Snowden Drifts (0)\" },\n        { fileName: \"186397.data\", name: \"Snowden Drifts (1)\" },\n        { fileName: \"275155.data\", name: \"Dredgehaunt Cliffs\" },\n        { fileName: \"276252.data\", name: \"Frostgorge Sound\" },\n        { fileName: \"277587.data\", name: \"Lornar's Pass\" },\n        { fileName: \"278717.data\", name: \"Timberline Falls (0)\" },\n        { fileName: \"846866.data\", name: \"Timberline Falls (1)\" },\n        { fileName: \"1018612.data\", name: \"Timberline Falls (2)\" },\n        { fileName: \"295282.data\", name: \"Eye of the North\" }\n      ]\n    },\n    {\n      name: \"02. Ascalon\",\n      maps: [\n        { fileName: \"126118.data\", name: \"Plains of Ashford (0)\" },\n        { fileName: \"188591.data\", name: \"Plains of Ashford (1)\" },\n        { fileName: \"127888.data\", name: \"Diessa Plateau (0)\" },\n        { fileName: \"190490.data\", name: \"Diessa Plateau (1)\" },\n        { fileName: \"131944.data\", name: \"Black Citadel (0)\" },\n        { fileName: \"196585.data\", name: \"Black Citadel (1)\" },\n        { fileName: \"1968107.data\", name: \"Black Citadel (2)\" },\n        { fileName: \"280025.data\", name: \"Blazeridge Steppes\" },\n        { fileName: \"281313.data\", name: \"Fireheart Rise\" },\n        { fileName: \"282668.data\", name: \"Iron Marches\" },\n        { fileName: \"283574.data\", name: \"Fields of Ruin\" }\n      ]\n    },\n    {\n      name: \"03. Kryta\",\n      maps: [\n        { fileName: \"191000.data\", name: \"Lion's Arch (0)\" },\n        { fileName: \"814803.data\", name: \"Lion's Arch (1)\" },\n        { fileName: \"1019669.data\", name: \"Lion's Arch (Legacy)\" },\n        { fileName: \"1796999.data\", name: \"Lion's Arch (2)\" },\n        { fileName: \"1869665.data\", name: \"Lion's Arch (3)\" },\n        { fileName: \"1968576.data\", name: \"Lion's Arch (4)\" },\n        { fileName: \"128151.data\", name: \"Divinity's Reach (0)\" },\n        { fileName: \"191265.data\", name: \"Divinity's Reach (1)\" },\n        { fileName: \"705746.data\", name: \"Divinity's Reach (2)\" },\n        { fileName: \"1968748.data\", name: \"Divinity's Reach (3)\" },\n        { fileName: \"129834.data\", name: \"North of Divinity's Reach (0)\" },\n        { fileName: \"193081.data\", name: \"North of Divinity's Reach (1)\" },\n        { fileName: \"129524.data\", name: \"Queensdale (0)\" },\n        { fileName: \"192711.data\", name: \"Queensdale (1)\" },\n        { fileName: \"130970.data\", name: \"Kessex Hills (0)\" },\n        { fileName: \"194288.data\", name: \"Kessex Hills (1)\" },\n        { fileName: \"672138.data\", name: \"Kessex Hills (2)\" },\n        { fileName: \"861815.data\", name: \"Kessex Hills (3)\" },\n        { fileName: \"286945.data\", name: \"Bloodtide Coast\" },\n        { fileName: \"287870.data\", name: \"Harathi Hinterlands\" },\n        { fileName: \"289176.data\", name: \"Gendarran Fields\" },\n        { fileName: \"295005.data\", name: \"Chantry of Secrets\" },\n        { fileName: \"294938.data\", name: \"Claw Island\" }\n      ]\n    },\n    {\n      name: \"04. Maguuma Jungle\",\n      maps: [\n        { fileName: \"195149.data\", name: \"Caledon Forest\" },\n        { fileName: \"195493.data\", name: \"Metrica Province\" },\n        { fileName: \"922320.data\", name: \"Metrica Province Instance\" },\n        { fileName: \"198076.data\", name: \"The Grove (0)\" },\n        { fileName: \"1969341.data\", name: \"The Grove (1)\" },\n        { fileName: \"198272.data\", name: \"Rata Sum (0)\" },\n        { fileName: \"1968896.data\", name: \"Rata Sum (1)\" },\n        { fileName: \"291064.data\", name: \"Mount Maelstrom\" },\n        { fileName: \"292254.data\", name: \"Sparkfly Fen\" },\n        { fileName: \"293307.data\", name: \"Brisban Wildlands\" }\n      ]\n    },\n    {\n      name: \"05. Ruins of Orr\",\n      maps: [\n        { fileName: \"284829.data\", name: \"Straits of Devastation\" },\n        { fileName: \"285089.data\", name: \"Malchor's Leap\" },\n        { fileName: \"285634.data\", name: \"Cursed Shore\" },\n        { fileName: \"295179.data\", name: \"Cathedral of Hidden Depths\" },\n        { fileName: \"295962.data\", name: \"A Light in the Darkness\" }\n      ]\n    },\n    {\n      name: \"06. Living World S1\",\n      maps: [\n        { fileName: \"520479.data\", name: \"Southsun Cove\" },\n        { fileName: \"679089.data\", name: \"Tower of Nightmares\" }\n      ]\n    },\n    {\n      name: \"07. Living World S2\",\n      maps: [\n        { fileName: \"836211.data\", name: \"Dry top (0)\" },\n        { fileName: \"861770.data\", name: \"Dry top (1)\" },\n        { fileName: \"909361.data\", name: \"The Silverwastes (0)\" },\n        { fileName: \"996202.data\", name: \"The Silverwastes (1)\" },\n        { fileName: \"908730.data\", name: \"Glint's Lair\" }\n      ]\n    },\n    {\n      name: \"08. Heart of Maguuma\",\n      maps: [\n        { fileName: \"969663.data\", name: \"Verdant Brink\" },\n        { fileName: \"1262460.data\", name: \"Hearts and Minds\" },\n        { fileName: \"969964.data\", name: \"Unknown Airship in tree\" },\n        { fileName: \"1262310.data\", name: \"Dragon Stand\" },\n        { fileName: \"1263739.data\", name: \"Tarir\" },\n        { fileName: \"1264291.data\", name: \"Tangled Depths\" }\n      ]\n    },\n    {\n      name: \"09. Living World S3\",\n      maps: [\n        { fileName: \"1472635.data\", name: \"(E1) Bloodstone Fen\" },\n        { fileName: \"1498071.data\", name: \"(E2) Taimi Simulator\" },\n        { fileName: \"1498578.data\", name: \"(E2) Ring of Fire\" },\n        { fileName: \"1605211.data\", name: \"(E3) Bitterfrost Frontier\" },\n        { fileName: \"1645474.data\", name: \"(E4) Caudecus Manor\" },\n        { fileName: \"1646520.data\", name: \"(E4) Lake Doric\" },\n        { fileName: \"1682493.data\", name: \"(E5) Draconis Mons\" },\n        { fileName: \"1682763.data\", name: \"(E5) Titan's Throat\" },\n        { fileName: \"1734839.data\", name: \"(E6) White Mantle Fortress\" },\n        { fileName: \"1735346.data\", name: \"(E6) Siren's Landing\" },\n        { fileName: \"1735440.data\", name: \"(E6) Shining Blade Headquarters\" }\n      ]\n    },\n    {\n      name: \"10. Crystal Desert\",\n      maps: [\n        { fileName: \"1794574.data\", name: \"Crystal Oasis\" },\n        { fileName: \"1833034.data\", name: \"Desert Highlands\" },\n        { fileName: \"1833726.data\", name: \"PoF story instances\" },\n        { fileName: \"1839188.data\", name: \"Domain of Vabbi\" },\n        { fileName: \"1840103.data\", name: \"Elon Riverlands\" },\n        { fileName: \"1840368.data\", name: \"Kormir Sanctuary\" },\n        { fileName: \"1842533.data\", name: \"The Desolation\" }\n      ]\n    },\n    {\n      name: \"11. Living World S4\",\n      maps: [\n        { fileName: \"1901428.data\", name: \"(E1) Fahranur\" },\n        { fileName: \"1902235.data\", name: \"(E1) Istan\" },\n        { fileName: \"1903523.data\", name: \"(E1) Crystal Oasis\" },\n        { fileName: \"1954984.data\", name: \"(E2) Desert Highlands\" },\n        { fileName: \"1955224.data\", name: \"(E2) Inquest Lab Tower\" },\n        { fileName: \"1955471.data\", name: \"(E2) Rata Primus\" },\n        { fileName: \"1955642.data\", name: \"(E2) Divinity's Reach\" },\n        { fileName: \"1955915.data\", name: \"(E2) Mount Maelstrom\" },\n        { fileName: \"1956140.data\", name: \"(E2) Frostgorge Sound\" },\n        { fileName: \"1956245.data\", name: \"(E2) Void\" },\n        { fileName: \"1956299.data\", name: \"(E2) Hided Inquest Lab\" },\n        { fileName: \"1957526.data\", name: \"(E2) Sandswept Isles\" }\n      ]\n    },\n    {\n      name: \"12. Seasonal Activities\",\n      maps: [\n        { fileName: \"506592.data\", name: \"Ascent to Madness\" },\n        { fileName: \"506670.data\", name: \"Mad King's Labyrinth (Past)\" },\n        { fileName: \"662436.data\", name: \"Mad King's Labyrinth (Present)\" },\n        { fileName: \"506739.data\", name: \"Mad King's Clock Tower\" },\n        { fileName: \"622681.data\", name: \"The Crown Pavilion\" },\n        { fileName: \"569756.data\", name: \"SAB Hub (0)\" },\n        { fileName: \"636133.data\", name: \"SAB Hub (1)\" },\n        { fileName: \"635555.data\", name: \"SAB World 1\" },\n        { fileName: \"635960.data\", name: \"SAB World 2\" },\n        { fileName: \"606255.data\", name: \"Zephyr Sanctum\" },\n        { fileName: \"529896.data\", name: \"Tixx's Infinirarium\" },\n        { fileName: \"529945.data\", name: \"Winter Wonderland\" }\n      ]\n    },\n    {\n      name: \"13. Activites\",\n      maps: [\n        { fileName: \"605983.data\", name: \"Sanctum Sprint\" },\n        { fileName: \"606030.data\", name: \"Basket Brawl\" }\n      ]\n    },\n    {\n      name: \"14. Dungeons\",\n      maps: [\n        { fileName: \"126840.data\", name: \"Ascalonian Catacombs (0)\" },\n        { fileName: \"189364.data\", name: \"Ascalonian Catacombs (1)\" },\n        { fileName: \"275474.data\", name: \"Sorrow's Embrace\" },\n        { fileName: \"276520.data\", name: \"Honor of the Waves\" },\n        { fileName: \"284039.data\", name: \"Citadel of Flame\" },\n        { fileName: \"287214.data\", name: \"Caudecus's Manor\" },\n        { fileName: \"291284.data\", name: \"Twilight Arbor (0)\" },\n        { fileName: \"645968.data\", name: \"Twilight Arbor (1)\" },\n        { fileName: \"293606.data\", name: \"Crucible of Eternity\" },\n        { fileName: \"473930.data\", name: \"The Ruined City of Arah\" },\n        { fileName: \"473765.data\", name: \"Arah - Story\" },\n        { fileName: \"580061.data\", name: \"Molten Facility\" },\n        { fileName: \"595722.data\", name: \"Aetherblade Retreat\" }\n      ]\n    },\n    {\n      name: \"15. Fractals\",\n      maps: [\n        { fileName: \"519839.data\", name: \"Fractals of the Mists\" },\n        { fileName: \"697450.data\", name: \"Thaumanova Reactor\" },\n        { fileName: \"1426653.data\", name: \"Cliffside Fractal\" },\n        { fileName: \"1472361.data\", name: \"Chaos Isle Fractal\" },\n        { fileName: \"1472382.data\", name: \"Snowblind Fractal\" },\n        { fileName: \"1472406.data\", name: \"Swampland Fractal\" },\n        { fileName: \"1498016.data\", name: \"Mistlock Observatory\" },\n        { fileName: \"1498798.data\", name: \"Aetherblade/Mai Trin Fractal\" },\n        { fileName: \"1605344.data\", name: \"Nightmare Fractal\" },\n        { fileName: \"1733857.data\", name: \"Shattered Observatory Fractal\" },\n        { fileName: \"1733961.data\", name: \"Mistlock Sanctuary\" },\n        { fileName: \"1905739.data\", name: \"Molten Boss Fractal\" },\n        { fileName: \"1905889.data\", name: \"Twilight Oasis Fractal\" }\n      ]\n    },\n    {\n      name: \"16. Raid\",\n      maps: [\n        { fileName: \"1151420.data\", name: \"(W1) Spirit Vale\" },\n        { fileName: \"1383309.data\", name: \"(W2) Salvation Pass\" },\n        { fileName: \"1427048.data\", name: \"Special Forces Training Area\" },\n        { fileName: \"1454070.data\", name: \"(W3) Stronghold of the Faithful\" },\n        { fileName: \"1645215.data\", name: \"(W4) Bastion of the Penitent\" },\n        { fileName: \"1906329.data\", name: \"(W5) Hall of Chains\" }\n      ]\n    },\n    {\n      name: \"17. Structured PvP\",\n      maps: [\n        { fileName: \"871093.data\", name: \"Original Stronghold\" },\n        { fileName: \"870987.data\", name: \"Battle of Champion's Dusk (0)\" },\n        { fileName: \"1666233.data\", name: \"Battle of Champion's Dusk (1)\" },\n        { fileName: \"132570.data\", name: \"Heart of the Mists (0)\" },\n        { fileName: \"197249.data\", name: \"Heart of the Mists (1)\" },\n        { fileName: \"1734729.data\", name: \"Heart of the Mists (2)\" },\n        { fileName: \"1712986.data\", name: \"Hall of the Mists\" },\n        { fileName: \"132710.data\", name: \"The Battle of Khylo (0)\" },\n        { fileName: \"197402.data\", name: \"The Battle of Khylo (1)\" },\n        { fileName: \"132837.data\", name: \"Forest of Niflhel (0)\" },\n        { fileName: \"197545.data\", name: \"Forest of Niflhel (1)\" },\n        { fileName: \"376916.data\", name: \"Legacy of the Foefire\" },\n        { fileName: \"467374.data\", name: \"Raid on the Capricorn\" },\n        { fileName: \"520609.data\", name: \"Temple of the Silent Storm\" },\n        { fileName: \"579383.data\", name: \"Skyhammer (0)\" },\n        { fileName: \"677968.data\", name: \"Skyhammer (1)\" },\n        { fileName: \"1934470.data\", name: \"Skyhammer (2)\" },\n        { fileName: \"791564.data\", name: \"Courtyard (0)\" },\n        { fileName: \"1713054.data\", name: \"Courtyard (1)\" },\n        { fileName: \"556199.data\", name: \"Spirit Watch (0)\" },\n        { fileName: \"1473061.data\", name: \"Spirit Watch (1)\" },\n        { fileName: \"506539.data\", name: \"Reaper's Rumble\" },\n        { fileName: \"529718.data\", name: \"Snowball Mayhem\" },\n        { fileName: \"595582.data\", name: \"Dragon Ball Arena\" },\n        { fileName: \"617120.data\", name: \"Aspect Arena\" },\n        { fileName: \"1644624.data\", name: \"Revenge of the Capricorn\" },\n        { fileName: \"1704155.data\", name: \"Eternal Coliseum\" }\n      ]\n    },\n    {\n      name: \"18. World vs World\",\n      maps: [\n        { fileName: \"131235.data\", name: \"Eternal Battlegrounds (0)\" },\n        { fileName: \"195806.data\", name: \"Eternal Battlegrounds (1)\" },\n        { fileName: \"1885693.data\", name: \"Eternal Battlegrounds (2)\" },\n        { fileName: \"1918037.data\", name: \"Eternal Battlegrounds (3)\" },\n        { fileName: \"131574.data\", name: \"Alpine Borderlands (0)\" },\n        { fileName: \"641501.data\", name: \"Alpine Borderlands (1)\" },\n        { fileName: \"1799855.data\", name: \"Alpine Borderlands (2)\" },\n        { fileName: \"1647236.data\", name: \"Desert Borderlands (0)\" },\n        { fileName: \"1799442.data\", name: \"Desert Borderlands (1)\" },\n        { fileName: \"736241.data\", name: \"Edge of the Mists\" }\n      ]\n    },\n    {\n      name: \"19. Guild Halls\",\n      maps: [\n        { fileName: \"1255378.data\", name: \"Gilded Hollow\" },\n        { fileName: \"1256064.data\", name: \"Lost Precipice\" },\n        { fileName: \"1843274.data\", name: \"Windswept Haven\" }\n      ]\n    },\n    {\n      name: \"20. Concept and not released\",\n      maps: [\n        { fileName: \"122695.data\", name: \"Empty Plane\" },\n        { fileName: \"184799.data\", name: \"Empty Plane v1\" },\n        { fileName: \"197562.data\", name: \"Empty Plane v2\" },\n        { fileName: \"875614.data\", name: \"Unknown Mists Platforms\" },\n        { fileName: \"132853.data\", name: \"Empty Box\" },\n        { fileName: \"1255516.data\", name: \"Guild Coliseum\" },\n        { fileName: \"1498193.data\", name: \"Concept sPVP Map 1\" },\n        { fileName: \"1513556.data\", name: \"Concept sPVP Map 2\" },\n        { fileName: \"1513607.data\", name: \"Concept sPVP Map 3\" },\n        { fileName: \"1513620.data\", name: \"Concept sPVP Map 4\" },\n        { fileName: \"1513675.data\", name: \"Concept sPVP Map 5\" },\n        { fileName: \"1712945.data\", name: \"Concept sPVP Map 6\" }\n      ]\n    }\n  ]\n};\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* INCLUDES */\nlet LocalReader = require(\"./LocalReader/LocalReader\");\n\n/* PRIVATE VARS */\nlet _version = \"1.1.0\";\nlet _settings = {\n  t3dtoolsWorker: \"modules/t3dtools/t3dworker.js\",\n  concurrentTasks:\n    typeof navigator !== \"undefined\" ? navigator.hardwareConcurrency : 1\n};\n\nlet T3D;\n\n/* PUBLIC PROPERTIES */\n\n/**\n * Tyria 3D Library main module.\n *\n * Use this static class to access file parsers- and data renderer classes.\n *\n * This class also works as a factory for creating\n * LocalReader instances that looks up and inflates files from the Guild Wars 2 .dat.\n * @module T3D\n */\nT3D = module.exports = {\n  /**\n   * The current library version. Used to make sure local storage caches are not\n   * shared between different releases.\n   *\n   * @property version\n   * @type String\n   */\n  version: _version,\n\n  /* FILES */\n\n  /**\n   * A static reference to the GW2File class, the preferred way of\n   * accessing this class.\n   *\n   * @memberof T3D\n   * @property GW2File\n   * @type Class\n   */\n  GW2File: require(\"./format/file/GW2File\"),\n\n  /**\n   * A static reference to the GW2Chunk class, the preferred way of\n   * accessing this class.\n   *\n   * @memberOf T3D\n   * @property GW2Chunk\n   * @type Class\n   */\n  GW2Chunk: require(\"./format/file/GW2Chunk\"),\n\n  /* RENDERERS */\n\n  /**\n   * A static reference to the DataRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property DataRenderer\n   * @type Class\n   */\n  DataRenderer: require(\"./dataRenderer/DataRenderer\"),\n\n  /**\n   * A static reference to the EnvironmentRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property EnvironmentRenderer\n   * @type Class\n   */\n  EnvironmentRenderer: require(\"./dataRenderer/EnvironmentRenderer\"),\n\n  /**\n   * A static reference to the HavokRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property HavokRenderer\n   * @type Class\n   */\n  HavokRenderer: require(\"./dataRenderer/HavokRenderer\"),\n\n  /**\n   * A static reference to the PropertiesRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property PropertiesRenderer\n   * @type Class\n   */\n  PropertiesRenderer: require(\"./dataRenderer/PropertiesRenderer\"),\n\n  /**\n   * A static reference to the SingleModelRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property SingleModelRenderer\n   * @type Class\n   */\n  SingleModelRenderer: require(\"./dataRenderer/SingleModelRenderer\"),\n\n  /**\n   * A static reference to the TerrainRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property TerrainRenderer\n   * @type Class\n   */\n  TerrainRenderer: require(\"./dataRenderer/TerrainRenderer\"),\n\n  /**\n   * A static reference to the ZoneRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property ZoneRenderer\n   * @type Class\n   */\n  ZoneRenderer: require(\"./dataRenderer/ZoneRenderer\"),\n\n  /**\n   * A static reference to the StringRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property StringRenderer\n   * @type Class\n   */\n  StringRenderer: require(\"./dataRenderer/StringRenderer\"),\n\n  /* LOGGING */\n\n  /**\n   * A static reference to the static Logger object, the preferred way of\n   * accessing this object. A simple way of providing your own logging methods\n   * is to simply overwrite any or all of the logging methods specified in\n   * {{#crossLink \"Logger/logFunctions:property\"}}{{/crossLink}}\n   *\n   * @property Logger\n   * @type Object\n   */\n  Logger: require(\"./Logger\"),\n\n  /* SETTINGS */\n\n  /**\n   * Contains a list of known map fileID:s and their names. Used in order to quickly\n   * look up what maps are in a .dat file. Note that this property is hard coded and\n   * has high probablity of being outdated. Also note that the names are just guesses\n   * by RequestTimeout.\n   *\n   * The format of this list objects is\n   *\n   *\n   * \t{\n   *  \tmaps : [\n   *\t  \t\t{\n   *     \t\t\tname:\"World Area Name\",\n   *\t       \t\tmaps:[\n   *\t         \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name One\" },\n   *\t           \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name Two\" },\n   *\t             \t{ fileName :\"[numeric fileId].data\", name:\"Map Name Three\" }\n   *\t              ]\n   *           },\n   *\t         {\n   *\t\t\t    name:\"Another World Area Name\",\n   *\t\t \t   \tmaps:[\n   *\t\t \t\t   \t{ fileName :\"[numeric fileId].data\", name:\"Map Name 408\" }\n   *\t\t\t    ]\n   *\t\t     }\n   * \t\t]\n   *   }\n   *\n   * @readonly\n   * @property MapFileList\n   * @type Object\n   */\n  MapFileList: require(\"./MapFileList\"),\n\n  /* UTILS */\n\n  /**\n   * A static reference to the MaterialUtils class.\n   *\n   * @readonly\n   * @property MaterialUtils\n   * @type Object\n   */\n  MaterialUtils: require(\"./util/MaterialUtils.js\"),\n\n  /**\n   * A static reference to the MathUtils class.\n   *\n   * @readonly\n   * @property MathUtils\n   * @type Object\n   */\n  MathUtils: require(\"./util/MathUtils.js\"),\n\n  /**\n   * A static reference to the ParserUtils class.\n   *\n   * @readonly\n   * @property ParserUtils\n   * @type Object\n   */\n  ParserUtils: require(\"./util/ParserUtils.js\"),\n\n  /**\n   * A static reference to the RenderUtils class.\n   *\n   * @readonly\n   * @property RenderUtils\n   * @type Object\n   */\n  RenderUtils: require(\"./util/RenderUtils.js\"),\n\n  /**\n   * A static reference to the PersistantStore class.\n   *\n   * @readonly\n   * @property PersistantStore\n   * @type Class\n   */\n  PersistantStore: require(\"./LocalReader/PersistantStore\"),\n\n  /**\n   * A static reference to the FileTypes tools and list.\n   *\n   * @readonly\n   * @property FileTypes\n   * @type Object\n   */\n  FileTypes: require(\"./LocalReader/FileTypes\"),\n\n  /* PUBLIC METHODS */\n\n  /**\n   * Creates a new instance of LocalReader with an pNaCl inflater connected to it.\n   *\n   * @async\n   * @param  {File}   \tfile\t\tCore JS File instance, must refer to a GW2 .dat file\n   * @param  {Function}\tcallback\tCallback function, fired when the file index is fully\n   *                             \t\tconstructed. Takes no arguments.\n   *\n   * @param  {String} \tt3dtoolsWorker URL to the inflater file. If omitted\n   *                               \t_settings.t3dtoolsWorker will be used instead.\n   *\n   * @return {LocalReader}\t\t\tThe contructed LocalReader, note that this object\n   *                             \t\twill not be fully initialized until the callback\n   *                             \t\tis fired.\n   */\n  getLocalReader: function(file, callback, t3dtoolsWorker) {\n    let path = t3dtoolsWorker || _settings.t3dtoolsWorker;\n\n    // Create the instance and init the threads\n    let lrInstance = new LocalReader({\n      workerPath: path,\n      workersNb: _settings.concurrentTasks\n    });\n\n    /// Callback with the lrInstance\n    lrInstance.openArchive(file).then(() => {\n      callback(lrInstance);\n    });\n\n    return lrInstance;\n  },\n\n  /**\n   * Utility method for acceccing a list containing information about all files\n   * in the .dat connected to the provided LocalReader instance. This method first\n   * tries to read a local indexing list from the client's localstorage and\n   * fallbacks to generating the list by scanning the MFT indices of the .dat\n   * and peeking each file in order to find out what filetype it has.\n   *\n   * Note that peeking the files is the time consuming task, so if you don't want\n   * yout application to spend time indexing the .dat and have a priori knowledge\n   * about the required file Id's you should not use this method.\n   *\n   * @async\n   * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\n   * @param  {Function}\t\tcallback    Fires when the index has been loaded\n   *                                 \t\tfrom the localstorage or after it has\n   *                                 \t\tbeen built and stored in localstorage.\n   *                                 \t\tTakes the generated object list of\n   *                                 \t\tfiles as an argument. This list groups\n   *                                 \t\tarrays of MFT indices per file type,\n   *                                 \t\tfor exmample:\n   *\n   *\n   * \t{\n   *\t  \t\"Unknown\"\t: [444, 555, 333],\n   *\t  \t\"MODL\"\t\t: [444, 555, 333],\n   * \t  \t\"String\"\t: [666, 777, 888]\n   * \t}\n   *\n   * For more details see\n   * {{#crossLink \"LocalReader/listFiles:method\"}}{{/crossLink}}\n   */\n  getFileListAsync: function(localReader, callback) {\n    /// Check local storage for an existing file list\n    let fileList = localReader.loadFileList();\n\n    /// If there is no cached list, look for pre-defined maps.\n    if (!fileList) {\n      localReader.readFileListAsync(callback);\n    }\n\n    /// Otherwise, just fire the callback with the cached list\n    else {\n      callback(fileList);\n    }\n  },\n\n  /**\n\t * Utility method for acceccing a list containing information about all map files\n\t * in the .dat connected to the provided LocalReader instance. This method first\n\t * tries to read a local indexing list from the client's localstorage and\n\t * fallbacks to generating the list by scanning the MFT indices of the .dat\n\t * and peeking each file in order to find out what filetype it has.\n\t *\n\t * If the searchAll flag is not set to true, this process will only scan files\n\t * from the {{#crossLink \"T3D/MapFileList:property\"}}{{/crossLink}}\n\t *\n\t * @async\n\t * @param {LocalReader}\tlocalReader\tA fully initialized LocalReader instance\n\t * @param {Function}\tcallback\tFires when the index has been loaded\n\t *                                 \tfrom the localstorage or after it has\n\t *                                 \tbeen built and stored in localstorage.\n\t *                                 \tTakes the generated object list of\n\t *                                 \tfiles as an argument. This list groups\n\t *                                 \tarrays of MFT indices per file type,\n\t *                                 \tfor exmample:\n\t *\n\t * \t\t{\n\t * \t\t\tmaps:[\n\t * \t\t\t\t{\n\t * \t\t\t\t\tname: 'Heart of Maguuma',\n\t * \t\t\t\t\tmaps: [\n\t * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\n\t * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\n\t * \t\t\t\t\t]\n\t * \t\t\t\t},\n\t * \t\t\t\t{\n\t * \t\t\t\t\tname: 'Unknown maps',\n\t * \t\t\t\t\tmaps: [\n\t * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\n\t * \t\t\t\t\t]\n\t * \t\t\t\t}\n\t * \t\t\t]\n\n\t*\t    };\n\t* @param {boolean} searchAll if true forces re-indexing of entire dat.\n\t*/\n  getMapListAsync: function(localReader, callback, searchAll) {\n    /// If seachAll flag is true, force a deep search\n    if (searchAll) {\n      localReader.readMapListAsync(true, callback);\n      return;\n    }\n\n    /// Check local storage for an existing map list\n    let mapList = localReader.loadMapList();\n\n    /// If there is no cached list, look for pre-defined maps.\n    if (!mapList) {\n      localReader.readMapListAsync(false, callback);\n    }\n\n    /// Otherwise, just fire the callback with the cached list\n    else {\n      callback(mapList);\n    }\n  },\n\n  /**\n   * Utility method used for rendering map files. Loads a map file and applies\n   * the provided renderers to it.\n   *\n   * @async\n   * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\n   * @param  {Number}   \t\tfileName\tThe File Id of a mapc file.\n   * @param  {Array}   \t\trenderers\tAn array of renderer classes. Each\n   *                               \t\tclass should extend\n   *                               \t\t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\n   * @param  {Function}\t\tcallback    Callback function, takes the shared\n   *                                 \t\trenderer context as an argument.\n   * @param  {Class}\t\t\tlogger      A logger class of the same type as\n   *                               \t\t{{#crossLink \"Logger\"}}{{/crossLink}}\n   */\n  renderMapContentsAsync: function(\n    localReader,\n    fileName,\n    renderers,\n    callback,\n    logger\n  ) {\n    /// VO for storing result from renderers\n    let context = {};\n\n    let runAllRenderers;\n\n    /// Make sure we got an actuall ID number\n    if (parseInt(fileName)) {\n      /// File name is baseId, load using local reader.\n      localReader.loadFile(fileName, function(arrayBuffer) {\n        /// Set up datastream\n        let ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);\n\n        /// Initiate Map file object. Connect callback\n        let mapFile = new T3D.GW2File(ds, 0);\n\n        /// Populate VO by running the renderers\n        runAllRenderers = function(i) {\n          /// Run each renderer\n          if (i < renderers.length) {\n            T3D.runRenderer(\n              renderers[i].renderClass,\n              localReader,\n              Object.assign(renderers[i].settings, { mapFile: mapFile }),\n              context,\n              runAllRenderers.bind(this, i + 1)\n            );\n          }\n\n          /// Fire callback with VO when done\n          else {\n            callback(context);\n          }\n        };\n\n        /// Starting point for running each renderer\n        runAllRenderers(0);\n      });\n    }\n\n    /// Primitive error message...\n    else {\n      let outputLogger = logger || T3D.Logger;\n      outputLogger.log(\n        T3D.Logger.TYPE_ERROR,\n        \"Map id must be an integer!, was:\",\n        fileName\n      );\n    }\n  },\n\n  /**\n   * Utility method for applying a single renderer to a LocalReader insatnce.\n   *\n   * @async\n   *\n   * @param  {Class}\t\trenderClass\tA class extending\n   *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\n   * @param  {LocalReader}localReader A fully initialized LocalReader instance\n   * @param  {Object}\t\tsettings    Settings passed to the renderer. Often\n   *                               \tspecifies thinks like what file ID should\n   *                               \tbe loaded.\n   * @param  {Object}\t\tcontext     The shared renderer context value object.\n   * @param  {Function} \tcb          Callback method passed to the renderAsync\n   *                                 \tmethod of the renderer.\n   */\n  runRenderer: function(renderClass, localReader, settings, context, cb) {\n    let r = new renderClass(localReader, settings, context);\n\n    r.renderAsync(cb);\n  },\n\n  /**\n   * @param  {Object} context      \tA shared renderer context value object.\n   * @param  {Class} \tclazz        \tA class extending\n   *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}.\n   *                                \tSpecifies for renderer class you want to read\n   *                                \toutput.\n   * @param  {String} propName     \tThe name of the property written by the\n   *                                \trenderer that should retrtieved.\n   * @param  {any} \tdefaultValue \tThis value is passed back if no data could\n   *                              \tbe found.\n   * @return {any}    \t\t\t\tThe specified value from the conext if any,\n   *                          \t\totherwise defaultValue.\n   */\n  getContextValue: function(context, clazz, propName, defaultValue) {\n    let output = context[clazz.name];\n    if (output) {\n      return output[propName] ? output[propName] : defaultValue;\n    }\n    return defaultValue;\n  },\n\n  /**\n   * Check if the client web browser can render WebGL 3D content.\n   *\n   * @private\n   * @param  {boolean} return_context flag making this method return the canvas object instead of true\n   * @return {boolean} true if the client is WebGL enabled, false otherwise\n   */\n  hasWebGL: function(return_context) {\n    if (window.WebGLRenderingContext) {\n      let canvas = document.createElement(\"canvas\");\n      let names = [\"webgl\", \"experimental-webgl\", \"moz-webgl\", \"webkit-3d\"];\n      let context = false;\n\n      for (let i = 0; i < 4; i++) {\n        try {\n          context = canvas.getContext(names[i]);\n          if (context && typeof context.getParameter === \"function\") {\n            // WebGL is enabled\n            if (return_context) {\n              // return WebGL object if the function's argument is present\n              return { name: names[i], gl: context };\n            }\n            // else, return just true\n            return true;\n          }\n        } catch (e) {\n          //continue\n        }\n      }\n\n      // WebGL is supported, but disabled\n      return false;\n    }\n\n    // WebGL not supported\n    return false;\n  }\n};\n\n/* PRIVATE METHODS */\n\n/**\n * Performs checks for required browser capabilities and required third party libraries.\n * Loggs any warnings or error messages.\n *\n * @private\n * @return {Number} The ammount of errors and warnings generated.\n */\nfunction checkRequirements() {\n  let numErrors = 0;\n\n  if (!global.window || !window.indexedDB) {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"T3D persistant storing and loading requires indexedDB support.\"\n    );\n    numErrors++;\n  }\n\n  if (typeof DataStream === \"undefined\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"T3D core functionality requires DataStream library.\"\n    );\n    numErrors++;\n  }\n\n  if (typeof THREE === \"undefined\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_WARNING,\n      \"T3D mesh generation requires three.js library.\"\n    );\n    numErrors++;\n  }\n\n  if (numErrors < 1) {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_MESSAGE,\n      \"Tyria 3D API v\" + T3D.version + \" initialized.\"\n    );\n  }\n\n  return numErrors;\n}\n\n/**\n * Performs a quick and dirty check to find what chunk name definitions\n * appear multiple times in th formats array. Note that anything that\n * appears more than 2 times wil get a too hight value due to the\n * algorithm being... incorrect.\n *\n * @private\n * @return {Object} An object mapping duplicate chunk definition names.\n * to the number of apperances.\n */\n// eslint-disable-next-line no-unused-vars\nfunction findDuplicateChunkDefs() {\n  let dups = {};\n  T3D.formats.forEach(function(f1) {\n    T3D.formats.forEach(function(f2) {\n      if (f2.name === f1.name && f2 !== f1) {\n        if (dups[f1.name]) {\n          dups[f1.name]++;\n        } else {\n          dups[f1.name] = 1;\n        }\n      }\n    });\n  });\n  return dups;\n}\n\n/// Library checks requirements on startup\ncheckRequirements();\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require(\"../format/file/GW2File\");\n\n/**\n * Base class for data interpretors a.k.a. 'Renderers'\n *\n * Renderers are classes that collect and interpret data from the dat file.\n *\n * A {{#crossLink \"LocalReader\"}}{{/crossLink}} instance is used for accessing data from the dat.\n *\n * A {{#crossLink \"Logger\"}}{{/crossLink}} is used for posting progress output or error messages.\n *\n * Most Renderers use one or more\n * {{#crossLink \"GW2Chunk\"}}GW2Chunks{{/crossLink}}, typed data structures that can be read from\n * {{#crossLink \"GW2File\"}}GW2Files{{/crossLink}}.\n *\n * The generated data, be it strings, numbers or meshes are put into a value object structure called\n * the 'context'. The context can store data generated by multiple renderers and makes sure each\n * renderer type, or class has it's own value object within the context. This enables one renderer\n * to read data written by another renderer wihtout having to worry about overwriting existing data\n * within the context. Keep in mind that you will have to manually pass and clean the conext object!\n *\n * A clean context object should just be the empty javasript object : {}.\n *\n * When a Renderer is done it will fire the callback and any view interrested in retrieving the generated\n * data from the context can read it using\n * {{#crossLink \"T3D/getContextValue:method\"}}{{/crossLink}}.\n *\n *\n *\n *\n * @class DataRenderer\n * @constructor\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nlet DataRenderer = function(localReader, settings, context, logger) {\n  /// Just storing parameters\n  this.localReader = localReader;\n  this.settings = settings;\n  if (!settings) {\n    settings = {};\n  }\n  this.context = context;\n  this.context[this.constructor.name] = {};\n\n  if (logger) this.logger = logger;\n  else this.logger = T3D.Logger;\n};\n\n/**\n * Gets the output value object for a specified class within the context.\n *\n * @param  {Class} otherClass The class to fetch the output value object for.\n * If not specified the class of this instance will be used.\n * @return {Object}            The output value object for this class within the context.\n */\nDataRenderer.prototype.getOutput = function(otherClass) {\n  return this.context[otherClass ? otherClass.name : this.constructor.name];\n};\n\n/**\n * Basic rendering of unknown files. Output fileds generated:\n *\n * - *fileId* The fileId passed in the settings parameter when constructing this instance.\n *\n * - *rawData* An ArrayBuffer containg the infalted binary data of the loaded file.\n *\n * - *rawString* A string representation of the rawData\n *\n * - *image* A value object witht he fields 'width', 'height' and 'data' describing a RGBA bitmap\n * image. Only set if the loaded file was a texture.\n *\n * - *file* A GW2File representation of the loaded file. Only set if the loaded file was a Pack File.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nDataRenderer.prototype.renderAsync = function(callback) {\n  let self = this;\n\n  this.localReader.loadFile(this.settings.id, function(inflatedData) {\n    /// Set fileId so callers can identify this VO\n    self.getOutput().fileId = self.settings.id;\n\n    /// Share inflated data\n    self.getOutput().rawData = inflatedData;\n\n    /// Construct raw string\n    let uarr = new Uint8Array(inflatedData);\n    let rawStrings = [];\n    let chunksize = 0xffff;\n    let len = Math.min(uarr.length, 10000);\n\n    // There is a maximum stack size. We cannot call String.fromCharCode with as many arguments as we want\n    for (let i = 0; i * chunksize < len; i++) {\n      rawStrings.push(\n        String.fromCharCode.apply(\n          null,\n          uarr.subarray(i * chunksize, (i + 1) * chunksize)\n        )\n      );\n    }\n\n    if (len < uarr.length) {\n      rawStrings.push(\n        \"T3D Ignored the last \" +\n          (uarr.length - len) +\n          \" bytes when generating this raw output\"\n      );\n    }\n\n    self.getOutput().rawString = rawStrings.join();\n\n    /// Check if this is an PF or ATEX file\n    // Binareis are MZ\n    let ds = new DataStream(inflatedData);\n    let first4 = ds.readCString(4);\n\n    /// Do special stuff for different fcc signatures\n    ///\n    /// fourcc != fcc::ATEX && fourcc != fcc::ATEC && fourcc != fcc::ATEP &&\n    /// fourcc != fcc::ATET && fourcc != fcc::ATEU && fourcc != fcc::ATTX)\n    ///\n    if (\n      first4 === \"ATEX\" ||\n      first4 === \"ATEC\" ||\n      first4 === \"ATEP\" ||\n      first4 === \"ATET\" ||\n      first4 === \"ATEU\" ||\n      first4 === \"ATTX\"\n    ) {\n      /// TODO: MOVE TO GW2 texture file!!\n      /// Load file using LocalReader.\n      self.localReader.loadTextureFile(self.settings.id, function(\n        inflatedData,\n        dxtType,\n        imageWidth,\n        imageHeigth\n      ) {\n        /// Create image using returned data.\n        let image = {\n          data: new Uint8Array(inflatedData),\n          width: imageWidth,\n          height: imageHeigth\n        };\n\n        self.getOutput().image = image;\n        callback();\n      });\n    } else if (first4.indexOf(\"PF\") === 0) {\n      self.getOutput().file = new GW2File(ds, 0);\n      callback();\n    } else {\n      self.getOutput().file = null;\n      callback();\n    }\n  });\n};\n\nmodule.exports = DataRenderer;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"../util/RenderUtils\");\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates some of the environment objects of a map.\n *\n * @class EnvironmentRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction EnvironmentRenderer(localReader, settings, context, logger) {\n  DataRenderer.call(this, localReader, settings, context, logger);\n\n  this.mapFile = this.settings.mapFile;\n\n  this.getMat = function(tex) {\n    return new THREE.MeshBasicMaterial({\n      map: tex,\n      side: THREE.BackSide,\n      fog: false,\n      depthWrite: false\n    });\n  };\n\n  this.loadTextureWithFallback = function(\n    targetMatIndices,\n    materialArray,\n    filename,\n    fallbackFilename,\n    hazeColorAsInt\n  ) {\n    let self = this;\n\n    function writeMat(mat) {\n      targetMatIndices.forEach(function(i) {\n        materialArray[i] = mat;\n      });\n    }\n\n    function loadFallback() {\n      let mat = self.getMat(new THREE.TextureLoader().load(fallbackFilename));\n\n      writeMat(mat);\n    }\n\n    function errorCallback() {\n      setTimeout(loadFallback, 1);\n    }\n\n    let mat = self.getMat(\n      RenderUtils.loadLocalTexture(\n        localReader,\n        filename,\n        null,\n        hazeColorAsInt,\n        errorCallback\n      )\n    );\n\n    writeMat(mat);\n  };\n\n  this.getHazeColor = function(environmentChunkData) {\n    let hazes = environmentChunkData && environmentChunkData.dataGlobal.haze;\n\n    if (!hazes || hazes.length <= 0) {\n      return [190, 160, 60];\n    } else {\n      return hazes[0].farColor;\n    }\n  };\n\n  this.parseLights = function(environmentChunkData) {\n    let self = this;\n\n    /// Set up output array\n    self.getOutput().lights = [];\n\n    let lights = environmentChunkData\n      ? environmentChunkData.dataGlobal.lighting\n      : [\n          {\n            lights: [],\n            backlightIntensity: 1.0,\n            backlightColor: [255, 255, 255]\n          }\n        ];\n\n    let ambientLight;\n\n    // var light = lights[0];\n    //\n    let hasLight = false;\n    lights.forEach(function(light /*, idx*/) {\n      if (hasLight) return;\n\n      /// Directional lights\n      // eslint-disable-next-line no-unused-vars\n      let sumDirLightIntensity = 0;\n\n      light.lights.forEach(function(dirLightData /*, idx*/) {\n        hasLight = true;\n\n        let color = new THREE.Color(\n          dirLightData.color[2] / 255.0,\n          dirLightData.color[1] / 255.0,\n          dirLightData.color[0] / 255.0\n        );\n\n        let directionalLight = new THREE.DirectionalLight(\n          color.getHex(),\n          dirLightData.intensity\n        );\n\n        directionalLight.position\n          .set(\n            -dirLightData.direction[0],\n            dirLightData.direction[2],\n            dirLightData.direction[1]\n          )\n          .normalize();\n\n        sumDirLightIntensity += dirLightData.intensity;\n\n        self.getOutput().lights.push(directionalLight);\n      }); // END for each directional light in light\n\n      /// Add some random directional lighting if there was no, in order to se SOME depth on models\n      if (!light.lights || light.lights.length === 0) {\n        let directions = [[0, 1, 0, 0.3], [1, 2, 1, 0.3], [-1, -2, -1, 0.3]];\n\n        directions.forEach(function(lightDir) {\n          let color = new THREE.Color(1, 1, 1);\n          let intensity = lightDir[3];\n          let directionalLight = new THREE.DirectionalLight(\n            color.getHex(),\n            intensity\n          );\n\n          directionalLight.position\n            .set(lightDir[0], lightDir[1], lightDir[2])\n            .normalize();\n\n          sumDirLightIntensity += intensity;\n\n          self.getOutput().lights.push(directionalLight);\n        });\n      }\n\n      /// Ambient light\n      // light.backlightIntensity /= sumDirLightIntensity +light.backlightIntensity;\n      // light.backlightIntensity = light.backlightIntensity;\n      let color = new THREE.Color(\n        (light.backlightIntensity * (255.0 - light.backlightColor[2])) / 255.0,\n        (light.backlightIntensity * (255.0 - light.backlightColor[1])) / 255.0,\n        (light.backlightIntensity * (255.0 - light.backlightColor[0])) / 255.0\n      );\n\n      ambientLight = new THREE.AmbientLight(color);\n    }); // END for each light in lighting\n\n    let ambientTotal = 0;\n    if (ambientLight) {\n      ambientTotal =\n        ambientLight.color.r + ambientLight.color.g + ambientLight.color.b;\n      this.getOutput().lights.push(ambientLight);\n    }\n\n    /// Parsing done, set hasLight flag and return\n    this.getOutput().hasLight = hasLight || ambientTotal > 0;\n  };\n\n  this.parseSkybox = function(\n    environmentChunkData,\n    parameterChunkData,\n    hazeColorAsInt\n  ) {\n    /// set up output array\n    this.getOutput().skyElements = [];\n\n    /// Grab sky texture.\n    /// index 0 and 1 day\n    /// index 2 and 3 evening\n    let skyModeTex =\n      this.environmentChunkData &&\n      this.environmentChunkData.dataGlobal.skyModeTex[0];\n\n    /// Fallback skyboxfrom dat.\n    if (!skyModeTex) {\n      skyModeTex = {\n        texPathNE: 1930687,\n        texPathSW: 193069,\n        texPathT: 193071\n      };\n    }\n\n    /// Calculate bounds\n    let bounds = parameterChunkData.rect;\n    let mapW = Math.abs(bounds.x1 - bounds.x2);\n    let mapD = Math.abs(bounds.y1 - bounds.y2);\n    // eslint-disable-next-line no-unused-vars\n    let boundSide = Math.max(mapW, mapD);\n\n    let materialArray = [];\n\n    /// Load skybox textures, fallback to hosted png files.\n    this.loadTextureWithFallback(\n      [1, 4],\n      materialArray,\n      skyModeTex.texPathNE + 1,\n      \"img/193068.png\",\n      hazeColorAsInt\n    );\n    this.loadTextureWithFallback(\n      [0, 5],\n      materialArray,\n      skyModeTex.texPathSW + 1,\n      \"img/193070.png\",\n      hazeColorAsInt\n    );\n    this.loadTextureWithFallback(\n      [2],\n      materialArray,\n      skyModeTex.texPathT + 1,\n      \"img/193072.png\",\n      hazeColorAsInt\n    );\n    materialArray[3] = new THREE.MeshBasicMaterial({ visible: false });\n\n    /// Create skybox geometry\n    let boxSize = 1024;\n    let skyGeometry = new THREE.BoxGeometry(boxSize, boxSize / 2, boxSize); // Width Height Depth\n\n    /// Ugly way of fixing UV maps for the skybox (I think)\n    skyGeometry.faceVertexUvs[0].forEach(function(vecs, idx) {\n      let face = Math.floor(idx / 2);\n\n      // PX NX\n      // PY NY\n      // PZ NZ\n\n      /// PX - WEST \tNX - EAST\n      if (face === 0 || face === 1) {\n        vecs.forEach(function(vec2) {\n          vec2.x = 1 - vec2.x;\n          vec2.y /= 2.0;\n          vec2.y += 0.5;\n        });\n      }\n\n      /// NZ - SOUTH \tPZ - NORTH\n      else if (face === 5 || face === 4) {\n        vecs.forEach(function(vec2) {\n          vec2.y /= -2.0;\n          vec2.y += 0.5;\n        });\n      } else {\n        vecs.forEach(function(vec2) {\n          vec2.x = 1 - vec2.x;\n        });\n      }\n    });\n\n    skyGeometry.uvsNeedUpdate = true;\n\n    /// Generate final skybox\n    let skyBox = new THREE.Mesh(skyGeometry, materialArray);\n\n    /// Put horizon in camera center\n    skyBox.translateY(boxSize / 4);\n    // skyBox.translateY( -environmentChunk.data.dataGlobal.sky.verticalOffset );\n\n    /// Write to output\n    this.getOutput().skyElements.push(skyBox);\n  };\n}\n\n/// DataRenderer inheritance:\nEnvironmentRenderer.prototype = Object.create(DataRenderer.prototype);\nEnvironmentRenderer.prototype.constructor = EnvironmentRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *hazeColor* Array of RGBA values describing the global haze color of the map.\n * - *lights* An array of THREE.DirectionalLight and  THREE.AmbientLight objects.\n * - *hasLight* Boolean is false if no directional lights were added to \"lights\".\n * - *skyElements* A textured THREE.Mesh skybox.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nEnvironmentRenderer.prototype.renderAsync = function(callback) {\n  let environmentChunkData = this.mapFile.getChunk(\"env\").data;\n  let parameterChunkData = this.mapFile.getChunk(\"parm\").data;\n\n  /// Set renderer clear color from environment haze\n  let hazeColor = this.getHazeColor(environmentChunkData);\n  let hazeColorAsInt =\n    hazeColor[2] * 256 * 256 + hazeColor[1] * 256 + hazeColor[0];\n  this.getOutput().hazeColor = hazeColor;\n\n  /// Add directional lights to output. Also write hasLight flag\n  this.parseLights(environmentChunkData);\n\n  /// Generate skybox\n  this.parseSkybox(environmentChunkData, parameterChunkData, hazeColorAsInt);\n\n  /// All parsing is synchronous, just fire callback\n  callback();\n};\n\nmodule.exports = EnvironmentRenderer;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates meshes describing the collisions of a map.\n *\n * @class HavokRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File. If \"visible\" is specified and true, the generated meshes will be textured\n * with a MeshNormalMaterial, otherwise they will not be visible.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction HavokRenderer(localReader, settings, context, logger) {\n  DataRenderer.call(this, localReader, settings, context, logger);\n\n  this.mapFile = this.settings.mapFile;\n\n  this.lastP = -1;\n  this.seed = 1;\n  this.meshes = [];\n\n  /**\n   * TODO\n   *\n   * @param  {Function} callback         [description]\n   * @async\n   */\n  this.renderModels = function(models, title, callback) {\n    let mat;\n    if (this.settings && this.settings.visible) {\n      mat = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide });\n    } else {\n      mat = new THREE.MeshBasicMaterial({ visible: false });\n    }\n\n    this.parseAllModels(models, mat, title, 200, 0, callback);\n  };\n\n  /**\n   * TODO\n   *\n   * @param  {*} animation  [description]\n   * @param  {*} collisions [description]\n   * @return {*}            [description]\n   */\n  this.getCollisionsForAnimation = function(animation, collisions) {\n    let ret = [];\n\n    for (let i = 0; i < animation.collisionIndices.length; i++) {\n      let index = animation.collisionIndices[i];\n      let collision = collisions[index];\n      collision.index = index;\n      ret.push(collision);\n    }\n\n    return ret;\n  };\n\n  /**\n   * TODO\n   *\n   * @param  {*} models       [description]\n   * @param  {*} mat       [description]\n   * @param  {*} title     [description]\n   * @param  {*} chunkSize [description]\n   * @param  {*} offset    [description]\n   * @return {*} callback          [description]\n   * @async\n   */\n  this.parseAllModels = function(\n    models,\n    mat,\n    title,\n    chunkSize,\n    offset,\n    callback\n  ) {\n    let i = offset;\n\n    for (; i < offset + chunkSize && i < models.length; i++) {\n      let p = Math.round((i * 100) / models.length);\n      if (p !== this.lastP) {\n        this.logger.log(\n          T3D.Logger.TYPE_PROGRESS,\n          \"Loading Collision Models (\" + title + \")\",\n          p\n        );\n        this.lastP = p;\n      }\n\n      /// Get animation object\n      let animation = this.animationFromGeomIndex(\n        models[i].geometryIndex,\n        this.geometries,\n        this.animations\n      );\n\n      let collisions = this.getCollisionsForAnimation(\n        animation,\n        this.havokChunkData.collisions\n      );\n\n      for (let j = 0; j < collisions.length; j++) {\n        let collision = collisions[j];\n        this.renderMesh(collision, models[i], mat);\n      }\n    }\n\n    if (i < models.length) {\n      window.setTimeout(\n        this.parseAllModels.bind(\n          this,\n          models,\n          mat,\n          title,\n          chunkSize,\n          offset + chunkSize,\n          callback\n        ),\n        10 /* time in ms to next call */\n      );\n    } else {\n      callback();\n    }\n  };\n\n  /**\n   * TODO\n   *\n   * @param  {*} propGeomIndex [description]\n   * @param  {*} geometries    [description]\n   * @param  {*} animations    [description]\n   * @return {*}               [description]\n   */\n  this.animationFromGeomIndex = function(\n    propGeomIndex,\n    geometries,\n    animations\n  ) {\n    // geometries is just list of all geometries.animations[end] for now\n    let l = geometries[propGeomIndex].animations.length;\n\n    return animations[geometries[propGeomIndex].animations[l - 1]];\n    // return animations[ geometries[propGeomIndex].animations[0] ];\n  };\n\n  /**\n   * TODO\n   *\n   * @param  {*} collision [description]\n   * @param  {*} model     [description]\n   * @param  {*} mat       [description]\n   * @return {*}           [description]\n   */\n  this.renderMesh = function(collision, model, mat) {\n    let pos = model.translate;\n    let rot = model.rotate;\n    let scale = 32 * model.scale;\n\n    /// Generate mesh\n    let mesh = this.parseHavokMesh(collision, mat);\n\n    /// Position mesh\n    /// \"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"\n    mesh.position.set(pos[0], -pos[2], -pos[1]);\n\n    /// Scale mesh\n    if (scale) mesh.scale.set(scale, scale, scale);\n\n    /// Rotate mesh\n    if (rot) {\n      mesh.rotation.order = \"ZXY\";\n\n      // [\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"],\n      mesh.rotation.set(rot[0], -rot[2], -rot[1]);\n    }\n\n    /// Add mesh to scene and collisions\n    this.getOutput().meshes.push(mesh);\n  };\n\n  /**\n   * TODO\n   *\n   * @return {*} [description]\n   */\n  this.seedRandom = function() {\n    let x = Math.sin(this.seed++) * 10000;\n    return x - Math.floor(x);\n  };\n\n  /**\n   * TODO\n   *\n   * @param  {*} collision [description]\n   * @param  {*} mat       [description]\n   * @return {*}           [description]\n   */\n  this.parseHavokMesh = function(collision, mat) {\n    let index = collision.index;\n\n    if (!this.meshes[index]) {\n      let geom = new THREE.Geometry();\n\n      /// Pass vertices\n      for (let i = 0; i < collision.vertices.length; i++) {\n        let v = collision.vertices[i];\n        // \"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"]\n        geom.vertices.push(new THREE.Vector3(v[0], v[2], -v[1]));\n      }\n\n      /// Pass faces\n      for (let i = 0; i < collision.indices.length; i += 3) {\n        let f1 = collision.indices[i];\n        let f2 = collision.indices[i + 1];\n        let f3 = collision.indices[i + 2];\n\n        if (\n          f1 <= collision.vertices.length &&\n          f2 <= collision.vertices.length &&\n          f3 <= collision.vertices.length\n        ) {\n          geom.faces.push(new THREE.Face3(f1, f2, f3));\n        } else {\n          this.logger.log(\n            T3D.Logger.TYPE_ERROR,\n            \"Errorus index in havok model geometry.\"\n          );\n        }\n      }\n\n      /// Prepare geometry and pass new mesh\n      geom.computeFaceNormals();\n      // geom.computeVertexNormals();\n\n      this.meshes[index] = new THREE.Mesh(geom, mat);\n\n      return this.meshes[index];\n    } else {\n      return this.meshes[index].clone();\n    }\n  };\n}\n\n/// DataRenderer inheritance:\nHavokRenderer.prototype = Object.create(DataRenderer.prototype);\nHavokRenderer.prototype.constructor = HavokRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *boundingBox* Array of values describing the bounding box of all collision.\n * - *meshes* An array of THREE.Mesh objects visualizing all collision in the map.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nHavokRenderer.prototype.renderAsync = function(callback) {\n  let self = this;\n\n  // TODO:The design of this method pretty much requires one instance\n  // of the class per parallel async render. Should probably fix this\n  // at some point...\n\n  /// Get required chunks\n  this.havokChunkData = this.mapFile.getChunk(\"havk\").data;\n\n  /// Set static bounds to the bounds of the havk models\n  this.getOutput().boundingBox = this.havokChunkData.boundsMax;\n\n  /// Clear old meshes\n  this.meshes = [];\n\n  /// Set up output array\n  this.getOutput().meshes = [];\n\n  /// Grab model raw data from the chunk.\n  /// Add missing scale value to obs models.\n  let propModels = this.havokChunkData.propModels;\n  let zoneModels = this.havokChunkData.zoneModels;\n  let obsModels = this.havokChunkData.obsModels;\n  obsModels.forEach(function(mdl) {\n    mdl.scale = 1;\n  });\n\n  /// Store geoms and animations from the file in hte instance so we don't\n  /// have to pass them arround too much. (fix this later)\n  this.geometries = this.havokChunkData.geometries;\n  this.animations = this.havokChunkData.animations;\n\n  /// Render \"prop\", \"zone\" and \"obs\" models in that order.\n  let renderZoneModelsCB = function() {\n    self.renderModels(obsModels, \"obs\", callback);\n  };\n  let renderPropModelsCB = function() {\n    self.renderModels(zoneModels, \"zone\", renderZoneModelsCB);\n  };\n  self.renderModels(propModels, \"prop\", renderPropModelsCB);\n};\n\nmodule.exports = HavokRenderer;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"../util/RenderUtils\");\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates property models for a map.\n *\n * @class PropertiesRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction PropertiesRenderer(localReader, settings, context, logger) {\n  DataRenderer.call(this, localReader, settings, context, logger);\n  this.mapFile = this.settings.mapFile;\n}\n\n/// DataRenderer inheritance:\nPropertiesRenderer.prototype = Object.create(DataRenderer.prototype);\nPropertiesRenderer.prototype.constructor = PropertiesRenderer;\n\n/**\n * Renders all property meshes in a GW2 map described by the map's PROP chunk.\n * Output fileds generated:\n *\n * - *meshes* An array of THREE.Mesh objects visualizing all property models refered by this map.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nPropertiesRenderer.prototype.renderAsync = function(callback) {\n  let self = this;\n\n  self.getOutput().meshes = [];\n\n  let propertiesChunkData = this.mapFile.getChunk(\"prp2\").data;\n\n  if (!propertiesChunkData) {\n    callback();\n    return;\n  }\n\n  let props = propertiesChunkData.propArray;\n  let animProps = propertiesChunkData.propAnimArray;\n  let instanceProps = propertiesChunkData.propInstanceArray;\n  let metaProps = propertiesChunkData.propMetaArray;\n\n  /// Concat all prop types\n  props = props\n    .concat(animProps)\n    .concat(instanceProps)\n    .concat(metaProps);\n\n  /// Create mesh cache\n  self.meshCache = {};\n  self.textureCache = {};\n\n  // For now, we'll do all load in serial\n  // TODO: load unique meshes and textures in parallell (asynch), then render!\n  let lastPct = -1;\n\n  let renderIndex = function(idx) {\n    if (idx >= props.length) {\n      /// Empty mesh cache\n      self.meshCache = {};\n      self.textureCache = {};\n      callback();\n      return;\n    }\n\n    let pct = Math.round((1000.0 * idx) / props.length);\n    pct /= 10.0;\n\n    /// Log progress\n    if (lastPct !== pct) {\n      let pctStr = pct + (pct.toString().indexOf(\".\") < 0 ? \".0\" : \"\");\n\n      self.logger.log(\n        T3D.Logger.TYPE_PROGRESS,\n        \"Loading 3D Models (Props)\",\n        pctStr\n      );\n      lastPct = pct;\n    }\n\n    /// Read prop at index.\n    let prop = props[idx];\n\n    /// Adds a single mesh to a group.\n    let addMeshToLOD = function(mesh, groups, lod, prop, needsClone) {\n      /// Read lod distance before overwriting mesh variable\n      let lodDist = prop.lod2 !== 0 ? prop.lod2 : mesh.lodOverride[1];\n\n      /// Read flags before overwriting mesh variable\n      let flags = mesh.flags;\n\n      /// Mesh flags are 0 1 4\n      /// For now, use flag 0 as the default level of detail\n      if (flags === 0) lodDist = 0;\n\n      /// Create new empty mesh if needed\n      if (needsClone) {\n        mesh = new THREE.Mesh(mesh.geometry, mesh.material);\n      }\n\n      mesh.updateMatrix();\n      mesh.matrixAutoUpdate = false;\n\n      // Find group for this LOD distance\n      if (groups[lodDist]) {\n        groups[lodDist].add(mesh);\n      }\n      // Or create LOD group and add to a level of detail\n      // WIP, needs some testing!\n      else {\n        let group = new THREE.Group();\n        group.updateMatrix();\n        group.matrixAutoUpdate = false;\n        group.add(mesh);\n        groups[lodDist] = group;\n        lod.addLevel(group, lodDist);\n      }\n\n      return lodDist;\n    };\n\n    /// Adds array of meshes to the scene, also adds transform clones\n    let addMeshesToScene = function(meshArray, needsClone, boundingSphere) {\n      /// Add original\n\n      /// Make LOD object and an array of groups for each LOD level\n      let groups = {};\n      let lod = new THREE.LOD();\n\n      /// Each mesh is added to a group corresponding to its LOD distane\n      let maxDist = 0;\n      meshArray.forEach(function(mesh) {\n        maxDist = Math.max(\n          maxDist,\n          addMeshToLOD(mesh, groups, lod, prop, needsClone)\n        );\n      });\n\n      /// Add invisible level (the raycaster crashes on lod without any levels)\n      lod.addLevel(new THREE.Group(), 100000);\n\n      /// Set position, scale and rotation of the LOD object\n      if (prop.rotation) {\n        lod.rotation.order = \"ZXY\";\n        // [\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"],\n        lod.rotation.set(\n          prop.rotation[0],\n          -prop.rotation[2],\n          -prop.rotation[1]\n        );\n      }\n      lod.scale.set(prop.scale, prop.scale, prop.scale);\n      lod.position.set(prop.position[0], -prop.position[2], -prop.position[1]);\n\n      lod.boundingSphereRadius =\n        (boundingSphere && boundingSphere.radius\n          ? boundingSphere.radius\n          : 1.0) * prop.scale;\n\n      lod.updateMatrix();\n      lod.matrixAutoUpdate = false;\n\n      /// Show highest level always\n      // lod.update(lod);\n\n      // Add LOD containing mesh instances to scene\n      self.getOutput().meshes.push(lod);\n\n      // Add one copy per transform, needs to be within it's own LOD\n      if (prop.transforms) {\n        prop.transforms.forEach(function(transform) {\n          /// Make LOD object and an array of groups for each LOD level\n          let groups = {};\n          let lod = new THREE.LOD();\n\n          /// Each mesh is added to a group corresponding to its LOD distane\n          let maxDist = 0;\n          meshArray.forEach(function(mesh) {\n            maxDist = Math.max(\n              maxDist,\n              addMeshToLOD(mesh, groups, lod, prop, true)\n            );\n          });\n\n          /// Add invisible level\n          // lod.addLevel(new THREE.Group(),10000);\n\n          /// Set position, scale and rotation of the LOD object\n          if (transform.rotation) {\n            lod.rotation.order = \"ZXY\";\n            lod.rotation.set(\n              transform.rotation[0],\n              -transform.rotation[2],\n              -transform.rotation[1]\n            );\n          }\n          lod.scale.set(transform.scale, transform.scale, transform.scale);\n          lod.position.set(\n            transform.position[0],\n            -transform.position[2],\n            -transform.position[1]\n          );\n\n          lod.updateMatrix();\n          lod.matrixAutoUpdate = false;\n\n          lod.boundingSphereRadius =\n            (boundingSphere && boundingSphere.radius\n              ? boundingSphere.radius\n              : 1.0) * prop.scale;\n\n          /// Show highest level always\n          lod.update(lod);\n\n          /// Add LOD containing mesh instances to scenerender: function(propertiesChunkHeader, map, localReader, renderCallback){\n          self.getOutput().meshes.push(lod);\n        });\n      }\n    };\n\n    /// Get meshes\n    let showUnmaterialed = false;\n    RenderUtils.getMeshesForFilename(\n      prop.filename,\n      prop.color,\n      self.localReader,\n      self.meshCache,\n      self.textureCache,\n      showUnmaterialed,\n      function(meshes, isCached, boundingSphere) {\n        if (meshes) {\n          addMeshesToScene(meshes, isCached, boundingSphere);\n        }\n\n        /// Render next prop\n        renderIndex(idx + 1);\n      }\n    );\n  };\n\n  /// Start serial loading and redering. (to allow re-using meshes and textures)\n  renderIndex(0);\n};\n\n/**\n * TODO: write description. Used for export feature\n * @param  {Function} callback [description]\n * @return {*}            [description]\n */\nPropertiesRenderer.prototype.getFileIdsAsync = function(callback) {\n  let fileIds = [];\n\n  let propertiesChunkData = this.mapFile.getChunk(\"prp2\").data;\n\n  let props = propertiesChunkData.propArray;\n  let animProps = propertiesChunkData.propAnimArray;\n  let instanceProps = propertiesChunkData.propInstanceArray;\n  let metaProps = propertiesChunkData.propMetaArray;\n\n  props = props\n    .concat(animProps)\n    .concat(instanceProps)\n    .concat(metaProps);\n\n  let getIdsForProp = function(idx) {\n    if (idx >= props.length) {\n      callback(fileIds);\n      return;\n    }\n\n    if (idx % 100 === 0) {\n      this.logger.log(\n        T3D.Logger.TYPE_MESSAGE,\n        \"getting ids for entry\",\n        idx,\n        \"of\",\n        props.length\n      );\n    }\n\n    let prop = props[idx];\n    RenderUtils.getFilesUsedByModel(\n      prop.filename,\n      {\n        /* broken, needs localReader */\n      },\n      function(propFileIds) {\n        fileIds = fileIds.concat(propFileIds);\n        getIdsForProp(idx + 1);\n      }\n    );\n  };\n\n  getIdsForProp(0);\n};\n\nmodule.exports = PropertiesRenderer;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"../util/RenderUtils\");\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates meshes for a single model file.\n *\n * @class SingleModelRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"id\" the base ID or file ID of the model to generate meshes for.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction SingleModelRenderer(localReader, settings, context, logger) {\n  DataRenderer.call(this, localReader, settings, context, logger);\n}\n\n/// DataRenderer inheritance:\nSingleModelRenderer.prototype = Object.create(DataRenderer.prototype);\nSingleModelRenderer.prototype.constructor = SingleModelRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *meshes* An array of THREE.Mesh objects visualizing this model file.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nSingleModelRenderer.prototype.renderAsync = function(callback) {\n  let self = this;\n\n  /// Get file id\n  let fileId = this.settings.id;\n  let showUnmaterialed = true;\n\n  /// Load the model file\n  let meshCache = {};\n  let textureCache = {};\n\n  /// Set up output array\n  self.getOutput().meshes = [];\n\n  RenderUtils.getMeshesForFilename(\n    fileId,\n    0x00ff00,\n    self.localReader,\n    meshCache,\n    textureCache,\n    showUnmaterialed,\n    function(meshes, isCached, boundingSphere) {\n      if (meshes) {\n        meshes.forEach(function(mesh) {\n          mesh.boundingSphere = boundingSphere;\n          self.getOutput().meshes.push(mesh);\n        });\n      }\n\n      /// Fire callback after all meshes have been added.\n      meshCache = {};\n      callback();\n    }\n  );\n};\n\nmodule.exports = SingleModelRenderer;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates a list of readable strings from a \"strs\" file.\n *\n * @class StringRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"id\" the base ID or file ID of the string file to read strings from.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction StringRenderer(localReader, settings, context, logger) {\n  DataRenderer.call(this, localReader, settings, context, logger);\n}\n\n/// DataRenderer inheritance:\nStringRenderer.prototype = Object.create(DataRenderer.prototype);\nStringRenderer.prototype.constructor = StringRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *strings* An array of objects. Each object has a \"recid\"-property specifing on what index within the file\n * a given string was found, and a \"value\"-property specigying the string value.\n *\n * - *language* An integer specifing the language of the loaded file.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nStringRenderer.prototype.renderAsync = function(callback) {\n  let self = this;\n\n  /// Get file id\n  // eslint-disable-next-line no-unused-vars\n  let fileId = this.settings.id;\n  // eslint-disable-next-line no-unused-vars\n  let showUnmaterialed = true;\n\n  /// Load the string file\n\n  /// Set up output array\n  this.getOutput().strings = [];\n\n  this.localReader.loadFile(this.settings.id, function(inflatedData) {\n    let ds = new DataStream(inflatedData);\n    let end = ds.byteLength - 2;\n\n    /// skip past fcc\n    ds.seek(4);\n\n    let entryHeaderDef = [\n      \"size\",\n      \"uint16\",\n      \"decryptionOffset\",\n      \"uint16\",\n      \"bitsPerSymbol\",\n      \"uint16\"\n    ];\n\n    let entryIndex = 0;\n\n    while (end - ds.position > 6) {\n      let entry = ds.readStruct(entryHeaderDef);\n      entry.size -= 6;\n\n      if (entry.size > 0) {\n        let isEncrypted =\n          entry.decryptionOffset !== 0 || entry.bitsPerSymbol !== 0x10;\n\n        /// UTF-16\n        if (!isEncrypted) {\n          let value = ds.readUCS2String(entry.size / 2);\n          self.getOutput().strings.push({\n            value: value,\n            recid: entryIndex\n          });\n        }\n\n        /// Other... ignored\n        else {\n          //continue\n        }\n      }\n\n      entryIndex++;\n    }\n\n    ds.seek(ds.byteLength - 2);\n    self.getOutput().language = ds.readUint16();\n    callback();\n  });\n};\n\nmodule.exports = StringRenderer;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"../util/RenderUtils\");\nconst DataRenderer = require(\"./DataRenderer\");\nconst GW2File = require(\"../format/file/GW2File.js\");\n\nconst TerrainShader = require(\"../util/TerrainShader.js\");\n\n/**\n *\n * A renderer that generates the meshes for the terrain of a map.\n *\n *\n * Requires a context previously populated by a\n * {{#crossLink \"EnvironmentRenderer\"}}{{/crossLink}}.\n *\n * @class TerrainRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction TerrainRenderer(localReader, mapFile, settings, context, logger) {\n  DataRenderer.call(this, localReader, mapFile, settings, context, logger);\n  this.mapFile = this.settings.mapFile;\n\n  this.drawWater = function(rect) {\n    /// Add Water\n    let material =\n      material ||\n      new THREE.MeshBasicMaterial({\n        color: 0x5bb1e8,\n        wireframe: false,\n        opacity: 0.35\n      });\n\n    material.transparent = true;\n    return RenderUtils.renderRect(rect, 0, material);\n  };\n\n  this.parseNumChunks = function(terrainData) {\n    terrainData.numChunksD_1 = Math.sqrt(\n      (terrainData.dims[0] * terrainData.chunkArray.length) /\n        terrainData.dims[1]\n    );\n    terrainData.numChunksD_2 =\n      terrainData.chunkArray.length / terrainData.numChunksD_1;\n  };\n\n  this.loadPagedImageCallback = function(callback, infaltedBuffer) {\n    let self = this;\n\n    // Prep output array\n    self.getOutput().terrainTiles = [];\n\n    let pimgDS = new DataStream(infaltedBuffer);\n    let pimgFile = new GW2File(pimgDS, 0);\n    let pimgTableDataChunk = pimgFile.getChunk(\"pgtb\");\n    let pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\n\n    this.mapRect = null;\n\n    /// Fetch chunks\n    let terrainData = this.mapFile.getChunk(\"trn\").data;\n    let parameterData = this.mapFile.getChunk(\"parm\").data;\n\n    /// Read settings\n    let maxAnisotropy = this.settings.anisotropy ? this.settings.anisotropy : 1;\n\n    //let chunks = [];\n    let chunkW = 35;\n\n    /// Calculate numChunksD_1 and _2\n    this.parseNumChunks(terrainData);\n\n    let xChunks = terrainData.numChunksD_1;\n    let yChunks = terrainData.numChunksD_2;\n\n    let allMaterials = terrainData.materials.materials;\n    let allTextures = terrainData.materials.texFileArray;\n\n    // Total map dx and dy\n    /*\n\t\told parameter data definition:\n\t\t\"x1\", \"float32\",\n\t\t\"y1\", \"float32\",\n\t\t\"x2\", \"float32\",\n\t\t\"y2\", \"float32\"\n\t\t*/\n    // var dx = parameterData.rect.x2 - parameterData.rect.x1;\n    // var dy = parameterData.rect.y2 - parameterData.rect.y1;\n    let dx = parameterData.rect[2] - parameterData.rect[0];\n    let dy = parameterData.rect[3] - parameterData.rect[1];\n\n    // Each chunk dx and dy\n    let cdx = (dx / terrainData.numChunksD_1) * 1; //  35/33;\n    let cdy = (dy / terrainData.numChunksD_2) * 1; // 35/33;\n    let n = 0;\n    let allMats = [];\n    let customMaterial = new THREE.MeshLambertMaterial({\n      side: THREE.DoubleSide,\n      color: 0x666666,\n      flatShading: true\n    });\n    //let texMats = {};\n\n    /// Load textures from PIMG and inject as material maps (textures)\n    let chunkTextures = {};\n\n    /// Load textures\n    if (pimgData) {\n      let strippedPages = pimgData.strippedPages;\n\n      /// Only use layer 0\n      strippedPages.forEach(function(page) {\n        /// Only load layer 0 and 1\n        if (page.layer <= 1) {\n          let filename = page.filename;\n          //let color = page.solidColor;\n          let coord = page.coord;\n\n          let matName = coord[0] + \",\" + coord[1];\n          if (page.layer === 1) matName += \"-2\";\n\n          /// Add texture to list, note that coord name is used, not actual file name\n          if (!chunkTextures[matName]) {\n            /// Load local texture, here we use file name!\n            let chunkTex = RenderUtils.loadLocalTexture(\n              self.localReader,\n              filename\n            );\n\n            if (chunkTex) {\n              /// Set repeat, antistropy and repeat Y\n              chunkTex.anisotropy = maxAnisotropy;\n              chunkTex.wrapS = THREE.RepeatWrapping;\n              chunkTex.wrapT = THREE.RepeatWrapping;\n            }\n\n            /// ...But store in coord name\n            chunkTextures[matName] = chunkTex;\n          }\n        }\n      }); /// end for each stripped page in pimgData\n    }\n\n    /// Render Each chunk\n    /// We'll make this async in order for the screen to be able to update\n\n    let renderChunk = function(cx, cy) {\n      let chunkIndex = cy * xChunks + cx;\n\n      let pageX = Math.floor(cx / 4);\n      let pageY = Math.floor(cy / 4);\n\n      // TODO: Terrain texture LOD ?\n      let chunkTextureIndices =\n        allMaterials[chunkIndex].loResMaterial.texIndexArray;\n      // let matFileName = allMaterials[chunkIndex].loResMaterial.materialFile;\n      // let chunkTextureIndices = allMaterials[chunkIndex].hiResMaterial.texIndexArray;\n      // let matFileName = allMaterials[chunkIndex].hiResMaterial.materialFile;\n      // let chunkData = terrainData.chunkArray[chunkIndex];\n      // let mainTex = allTextures[chunkTextureIndices[0]];\n      let mat = customMaterial;\n\n      /// TODO: just tick invert y = false...?\n      let pageOffetX = (cx % 4) / 4.0;\n      let pageOffetY = 0.75 - (cy % 4) / 4.0;\n\n      // offset 0 -> 0.75\n\n      // Make sure we have shared textures\n\n      /// Load and store all tiled textures\n      let fileNames = [];\n      for (let gi = 0; gi < chunkTextureIndices.length / 2; gi++) {\n        let textureFileName = allTextures[chunkTextureIndices[gi]].filename;\n\n        fileNames.push(textureFileName);\n\n        /// If the texture is not already loaded, read it from the .dat!\n        if (!chunkTextures[textureFileName]) {\n          /// Load local texture\n          let chunkTex = RenderUtils.loadLocalTexture(\n            self.localReader,\n            textureFileName\n          );\n\n          if (chunkTex) {\n            /// Set repeat, antistropy and repeat Y\n            chunkTex.anisotropy = maxAnisotropy;\n            chunkTex.wrapS = THREE.RepeatWrapping;\n            chunkTex.wrapT = THREE.RepeatWrapping;\n          }\n\n          chunkTextures[textureFileName] = chunkTex;\n        }\n      } /// End for each chunkTextureIndices\n\n      /// Create Composite texture material, refering the shared textures\n      let pageTexName = pageX + \",\" + pageY;\n      let pageTexName2 = pageX + \",\" + pageY + \"-2\";\n\n      /// TODO USe mapData (Chunk: env -> haze)\n      // var fog = SceneUtils.getScene().fog;\n      let fog = {\n        color: { r: 1, g: 1, b: 1 },\n        near: 0,\n        far: 0\n      };\n\n      /// Get haze color from environment rednerer\n      let envOutput = self.getOutput(T3D.EnvironmentRenderer);\n      if (envOutput.hazeColor) {\n        fog.color.r = envOutput.hazeColor[2] / 255.0;\n        fog.color.g = envOutput.hazeColor[1] / 255.0;\n        fog.color.b = envOutput.hazeColor[0] / 255.0;\n      }\n\n      let uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib[\"lights\"]]);\n\n      /// TODO: READ FROM VO, don't default to hard coded scale\n      uniforms.uvScale = { type: \"v2\", value: new THREE.Vector2(8.0, 8.0) };\n      uniforms.offset = {\n        type: \"v2\",\n        value: new THREE.Vector2(pageOffetX, pageOffetY)\n      };\n\n      uniforms.texturePicker = { type: \"t\", value: chunkTextures[pageTexName] };\n      uniforms.texturePicker2 = {\n        type: \"t\",\n        value: chunkTextures[pageTexName2]\n      };\n\n      uniforms.texture1 = { type: \"t\", value: chunkTextures[fileNames[0]] };\n      uniforms.texture2 = { type: \"t\", value: chunkTextures[fileNames[1]] };\n      uniforms.texture3 = { type: \"t\", value: chunkTextures[fileNames[2]] };\n      uniforms.texture4 = { type: \"t\", value: chunkTextures[fileNames[3]] };\n\n      mat = new THREE.ShaderMaterial({\n        uniforms: uniforms,\n        fragmentShader: TerrainShader.getFragmentShader(),\n        vertexShader: TerrainShader.getVertexShader()\n      });\n\n      /// Store referenceto each material\n      allMats.push(mat);\n\n      /// -1 for faces -> vertices , -2 for ignoring outer faces\n      let chunkGeo = new THREE.PlaneBufferGeometry(\n        cdx,\n        cdy,\n        chunkW - 3,\n        chunkW - 3\n      );\n\n      let cn = 0;\n\n      /// Render chunk\n\n      /// Each chunk vertex\n      for (let y = 0; y < chunkW; y++) {\n        for (let x = 0; x < chunkW; x++) {\n          if (x !== 0 && x !== chunkW - 1 && y !== 0 && y !== chunkW - 1) {\n            chunkGeo.getAttribute(\"position\").array[cn * 3 + 2] =\n              terrainData.heightMapArray[n];\n            cn++;\n          }\n\n          n++;\n        }\n      } // End each chunk vertex\n\n      /// Flip the plane to fit wonky THREE js world axes\n      let mS = new THREE.Matrix4().identity();\n      mS.elements[5] = -1;\n      chunkGeo.applyMatrix(mS);\n\n      /// Compute face normals for lighting, not used when textured\n      chunkGeo.computeFaceNormals();\n      // chunkGeo.computeVertexNormals();\n\n      /// Build chunk mesh!\n      let chunk;\n      chunk = new THREE.Mesh(chunkGeo, customMaterial);\n      if (mat.length) {\n        chunk = THREE.SceneUtils.createMultiMaterialObject(chunkGeo, mat);\n      } else {\n        chunk = new THREE.Mesh(chunkGeo, mat);\n      }\n\n      /// Move and rotate Mesh to fit in place\n      chunk.rotation.set(Math.PI / 2, 0, 0);\n\n      /// Last term is the new one: -cdx*(2/35)\n      let globalOffsetX = parameterData.rect[0] + cdx / 2;\n      let chunkOffsetX = cx * cdx;\n\n      chunk.position.x = globalOffsetX + chunkOffsetX;\n\n      /// Adjust for odd / even number of chunks\n      if (terrainData.numChunksD_2 % 2 === 0) {\n        /// Last term is the new one: -cdx*(2/35)\n        let globalOffsetY = parameterData.rect[1] + cdy / 2 - 0; // -cdy*(1/35);\n        let chunkOffsetY = cy * cdy * 1; // 33/35;\n\n        chunk.position.z = chunkOffsetY + globalOffsetY;\n      } else {\n        let globalOffsetY = parameterData.rect[1] - cdy / 2 + 0; // cdy*(1/35);\n        let chunkOffsetY = cy * cdy * 1; // 33/35;\n\n        chunk.position.z = globalOffsetY + chunkOffsetY;\n      }\n\n      let px = chunk.position.x;\n      let py = chunk.position.z;\n\n      if (!self.mapRect) {\n        self.mapRect = {\n          x1: px - cdx / 2,\n          x2: px + cdx / 2,\n          y1: py - cdy / 2,\n          y2: py + cdy / 2\n        };\n      }\n\n      self.mapRect.x1 = Math.min(self.mapRect.x1, px - cdx / 2);\n      self.mapRect.x2 = Math.max(self.mapRect.x2, px + cdx / 2);\n\n      self.mapRect.y1 = Math.min(self.mapRect.y1, py - cdy / 2);\n      self.mapRect.y2 = Math.max(self.mapRect.y2, py + cdy / 2);\n\n      chunk.updateMatrix();\n      chunk.updateMatrixWorld();\n\n      /// Add to list of stuff to render\n      /// TODO: Perhaps use some kind of props for each entry instead?\n      self.getOutput().terrainTiles.push(chunk);\n    }; /// End render chunk function\n\n    let stepChunk = function(cx, cy) {\n      if (cx >= xChunks) {\n        cx = 0;\n        cy++;\n      }\n\n      if (cy >= yChunks) {\n        /// Draw water surface using map bounds\n        self.getOutput().water = self.drawWater(self.mapRect);\n\n        /// Set bounds in output VO\n        self.getOutput().bounds = self.mapRect;\n\n        /// Fire call back, we're done rendering.\n        callback();\n        return;\n      }\n\n      let pct = Math.floor((100 * (cy * xChunks + cx)) / (xChunks * yChunks));\n\n      self.logger.log(T3D.Logger.TYPE_PROGRESS, \"Loading Terrain\", pct);\n\n      renderChunk(cx, cy);\n      setTimeout(stepChunk, 1, cx + 1, cy);\n    };\n\n    stepChunk(0, 0);\n  };\n}\n\n/// DataRenderer inheritance:\nTerrainRenderer.prototype = Object.create(DataRenderer.prototype);\nTerrainRenderer.prototype.constructor = TerrainRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *terrainTiles* An array of THREE.Mesh objects visualizing terrain of the map.\n *\n * - *water* A THREE.Mesh object visualizing the bounds of the map.\n *\n * - *bounds* An object wiht x1, x2, y1, and y2 properties specifying the bounds of the map.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nTerrainRenderer.prototype.renderAsync = function(callback) {\n  /// Load all paged Images, requires inflation of other pack files!\n  let pagedImageId = this.mapFile.getChunk(\"trn\").data.materials.pagedImage;\n  this.localReader.loadFile(\n    pagedImageId,\n    this.loadPagedImageCallback.bind(this, callback)\n  );\n};\n\n/**\n * TODO: write description. Used for export feature\n *\n * @param  {Function} callback [description]\n * @return {*}            [description]\n */\nTerrainRenderer.prototype.getFileIdsAsync = function(/* callback */) {\n  let terrainChunk = this.mapFile.getChunk(\"trn\");\n  let pimgTableDataChunk = this.mapFile.getChunk(\"pimg\");\n  let fileIds = [];\n\n  /// ------------ SPLASH TEXTURES ------------\n  let pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\n  let strippedPages = pimgData.strippedPages;\n\n  /// Only use layer 0\n  strippedPages.forEach(function(page) {\n    /// Only load layer 0 and 1\n    if (page.layer <= 1 && page.filename > 0) {\n      fileIds.push(page.filename);\n    }\n  });\n  /// ------------ END SPLASH TEXTURES ------------\n\n  /// ------------ TILED IMAGES ------------\n  let terrainData = terrainChunk.data;\n  let allTextures = terrainData.materials.texFileArray;\n  allTextures.forEach(function(texture) {\n    if (texture.filename > 0) fileIds.push(texture.filename);\n  });\n  /// ------------ END TILED IMAGES ------------\n\n  return fileIds;\n};\n\nmodule.exports = TerrainRenderer;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"../util/RenderUtils\");\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates zone models for a map.\n *\n * @class ZoneRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction ZoneRenderer(localReader, settings, context, logger) {\n  DataRenderer.call(this, localReader, settings, context, logger);\n  this.mapFile = this.settings.mapFile;\n\n  /**\n   * TODO\n   *\n   * @param  {*} zone               [description]\n   * @param  {*} zoneDefs           [description]\n   * @param  {*} mapRect            [description]\n   * @param  {*} renderZoneCallback [description]\n   * @return {*}                    [description]\n   */\n  this.renderZone = function(zone, zoneDefs, mapRect, renderZoneCallback) {\n    let self = this;\n\n    /// Get Zone Definition\n    let zoneDef = null;\n    zoneDefs.forEach(function(zd) {\n      if (!zoneDef && zd.token === zone.defToken) zoneDef = zd;\n    });\n\n    /// Create array of all models to add:\n    // let models = []\n    let modelGroups = this.getModelGroups(zone, zoneDef, mapRect);\n\n    /// Create empty mesh cache\n    self.meshCache = {};\n    self.textureCache = {};\n\n    /*\n     * ---Keeping this out of the doc for now---\n     * Steps trough each model and renders it to the scene, allowing for efficient caching.\n     * @param  {Number} i - Current index within the models array\n     */\n    // var lastPct = -1;\n    let groupKeys = Object.keys(modelGroups);\n    function stepModels(i) {\n      /* var pct = Math.round(100.0*i / groupKeys.length);\n\t\t\tif(lastPct!=pct){\n\t\t\t\tconsole.log(\"Rendering ZONE models \"+pct);\n\t\t\t\tlastPct = pct;\n\t\t\t} */\n\n      if (i >= groupKeys.length) {\n        /// Empty mesh cache\n        self.meshCache = {};\n        self.textureCache = {};\n\n        /// Tell caller this zone is done loading\n        renderZoneCallback();\n        return;\n      }\n\n      /// Read model at index\n      /// var model = models[i];\n      let key = groupKeys[i]; /// key is model filename\n      let group = modelGroups[key];\n\n      let meshGroups = [];\n\n      /// Get model just once for this group\n      let showUnmaterialed = false;\n      RenderUtils.getMeshesForFilename(\n        key,\n        null,\n        self.localReader,\n        self.meshCache,\n        self.textureCache,\n        showUnmaterialed,\n\n        function(meshes /*, isCached*/) {\n          /// If there were meshes, add them to the scene with correct scaling rotation etc.\n          if (meshes /* && meshes.length == 3 */) {\n            /// Add one copy per model instance\n            /// TODO: add rotation!\n            /// TODO: fine tune position?\n            /// TODO: POTIMIZE!\n\n            group.forEach(function(model, instanceIdx) {\n              //let isCached = true;\n              //let scale = 1.0;\n\n              /// For each Mesh in the model\n              meshes.forEach(function(mesh, meshIdx) {\n                if (\n                  mesh.materialFlags ===\n                  525 /* || mesh.materialFlags == 520 || mesh.materialFlags == 521 */\n                ) {\n                  // console.log(\"Skipping lod\");\n                  return;\n                }\n\n                let move = { x: 0, y: 0, z: 0 };\n\n                /// Add to big mesh\n                if (!meshGroups[meshIdx]) {\n                  let mg = mesh.geometry.clone();\n                  meshGroups[meshIdx] = {\n                    readVerts: mg.getAttribute(\"position\").array,\n                    verts: new Float32Array(\n                      group.length * mg.getAttribute(\"position\").array.length\n                    ),\n\n                    readIndices: mg.getIndex().array,\n                    indices: new Uint32Array(\n                      group.length * mg.getIndex().array.length\n                    ),\n\n                    readUVs: mg.getAttribute(\"uv\").array,\n                    uvs: new Float32Array(\n                      group.length * mg.getAttribute(\"uv\").array.length\n                    ),\n\n                    readNormals: mg.getAttribute(\"normal\").array,\n                    normals: new Float32Array(\n                      group.length * mg.getAttribute(\"normal\").array.length\n                    ),\n\n                    material: mesh.material,\n                    // material:new THREE.MeshBasicMaterial( {color: 0xffcccc, wireframe:true} ),\n                    /* material : new THREE.PointCloudMaterial ({\n\t\t\t\t\t\t\t\t\t      color: 0xFF0000,\n\t\t\t\t\t\t\t\t\t      size: 20\n\t\t\t\t\t\t\t\t\t    }), */\n                    position: { x: model.x, y: model.y, z: model.z }\n                  };\n                } else {\n                  /// Translate\n                  move.x = model.x - meshGroups[meshIdx].position.x;\n                  move.y = model.z - meshGroups[meshIdx].position.z;\n                  move.z = model.y - meshGroups[meshIdx].position.y;\n                }\n\n                /// Add geom verts\n                let readVerts = meshGroups[meshIdx].readVerts;\n                let writeVerts = meshGroups[meshIdx].verts;\n                let stride = readVerts.length;\n\n                for (\n                  let i = 0, j = instanceIdx * stride;\n                  i < stride;\n                  i += 3, j += 3\n                ) {\n                  writeVerts[j + 0] = readVerts[i + 0] + move.x;\n                  writeVerts[j + 1] = readVerts[i + 1] + move.y;\n                  writeVerts[j + 2] = readVerts[i + 2] + move.z;\n                }\n\n                let readIndices = meshGroups[meshIdx].readIndices;\n                let writeIndices = meshGroups[meshIdx].indices;\n                let strideIndices = readIndices.length;\n                let shift = (stride * instanceIdx) / 3;\n\n                for (\n                  let i = 0, j = instanceIdx * strideIndices;\n                  i < strideIndices;\n                  i++, j++\n                ) {\n                  writeIndices[j] = readIndices[i] + shift;\n                }\n\n                let readUVs = meshGroups[meshIdx].readUVs;\n                let writeUvs = meshGroups[meshIdx].uvs;\n                let uvStride = readUVs.length;\n                for (\n                  let i = 0, j = instanceIdx * uvStride;\n                  i < uvStride;\n                  i++, j++\n                ) {\n                  writeUvs[j] = readUVs[i];\n                }\n\n                let readNormals = meshGroups[meshIdx].readNormals;\n                let writeNormals = meshGroups[meshIdx].normals;\n                let normalStride = readNormals.length;\n                for (\n                  let i = 0, j = instanceIdx * normalStride;\n                  i < normalStride;\n                  i++, j++\n                ) {\n                  writeNormals[j] = readNormals[i];\n                }\n              });\n            }); // End for each model in group\n          } /// End if meshes\n\n          /// Add each cluster of merged meshes to scene\n          meshGroups.forEach(function(meshGroup) {\n            let mergedGeom = new THREE.BufferGeometry();\n\n            mergedGeom.addAttribute(\n              \"position\",\n              new THREE.BufferAttribute(meshGroup.verts, 3)\n            );\n            // mergedGeom.addAttribute( 'index', new THREE.BufferAttribute( meshGroup.indices, 1) );\n            mergedGeom.setIndex(\n              new THREE.BufferAttribute(meshGroup.indices, 1)\n            );\n            mergedGeom.addAttribute(\n              \"normal\",\n              new THREE.BufferAttribute(meshGroup.normals, 3)\n            );\n            mergedGeom.addAttribute(\n              \"uv\",\n              new THREE.BufferAttribute(meshGroup.uvs, 2)\n            );\n\n            mergedGeom.buffersNeedUpdate = true;\n\n            let mesh = new THREE.Mesh(mergedGeom, meshGroup.material);\n            mesh.position.set(\n              meshGroup.position.x,\n              meshGroup.position.z,\n              meshGroup.position.y\n            );\n\n            self.getOutput().meshes.push(mesh);\n          }); // End for each meshgroup\n\n          /// Rendering is done, render next.\n          stepModels(i + 1);\n        }\n      );\n    } /// End function stepModels\n\n    /// Begin stepping trough the models, rendering them.\n    stepModels(0);\n  };\n\n  /**\n   * TODO\n   *\n   * @param  {*} zone    [description]\n   * @param  {*} zoneDef [description]\n   * @param  {*} mapRect [description]\n   * @return {*}         [description]\n   */\n  this.getModelGroups = function(zone, zoneDef, mapRect) {\n    /// Calculate rect in global coordinates\n    // let zPos = zone.zPos;\n\n    let mapX = mapRect[0];\n    let mapY = mapRect[1];\n    let c = 32 + 16;\n\n    // [\"x1\",\"uint32\",\"y1\",\"uint32\",\"x2\",\"uint32\", \"y2\", \"uint32\"]\n    let zoneRect = {\n      x1: zone.vertRect[0] * c + mapX,\n      x2: zone.vertRect[2] * c + mapX,\n      y1: zone.vertRect[1] * -c - mapY,\n      y2: zone.vertRect[3] * -c - mapY\n    };\n\n    /// Zone width and depth in local corrdinates\n    /* var zdx = zone.vertRect.x1-zone.vertRect.x2;\n\t\tvar zdy = zone.vertRect.y1-zone.vertRect.y2; */\n\n    /// These zones seems to overflow :/\n    if (zone.encodeData.length === 0) {\n      return {};\n    }\n\n    // console.log(\"Get mdl groups\", zone);\n    /// Testing: Render Zone Vert Rect\n    // RenderUtils.renderRect(zoneRect, -zPos);\n\n    let zdx = zone.vertRect[0] - zone.vertRect[2];\n    // let zdy = zone.vertRect[1] - zone.vertRect[3];\n\n    /// Zone Flags increases a linear position, used to step trough the Zone.\n    let linearPos = 0;\n\n    let modelGroups = {};\n\n    let terrainTiles = this.getOutput(T3D.TerrainRenderer).terrainTiles;\n\n    for (let i = 0; i < zone.flags.length; i += 2) {\n      /// Step forward\n      linearPos += zone.flags[i];\n\n      /// Check if a model should be placed\n      let flag = zone.flags[i + 1];\n      if (flag !== 0) {\n        /// Extract flag data\n        /// Layer is written in the last 4 bytes\n        let zoneDefLayer = flag >> 4;\n\n        /// Get Zone Definition Layer\n        let layer = zoneDef.layerDefArray[zoneDefLayer - 1];\n\n        /// TESTING Only show layers with height >= 3\n        if (layer /* && layer.height >= 0 */) {\n          /// Get X and Y from linear position\n          let modelX = (linearPos % zdx) * c + zoneRect.x1;\n          let modelY = Math.floor(linearPos / zdx) * c + zoneRect.y1;\n\n          /// Get Z from intersection with terrain\n          let modelZ = null;\n\n          let startZ = 100000;\n\n          let raycaster = new THREE.Raycaster(\n            new THREE.Vector3(modelX, startZ, modelY),\n            new THREE.Vector3(0, -1, 0)\n          );\n\n          /// TODO: OPT?\n          terrainTiles.forEach(function(chunk) {\n            if (modelZ === null) {\n              let intersections = raycaster.intersectObject(chunk);\n              if (intersections.length > 0) {\n                modelZ = startZ - intersections[0].distance;\n              }\n            }\n          });\n\n          /// Get model id\n          /// TODO: check with modelIdx = flag & 0xf;\n          let modelIdx = 0;\n          let model = layer.modelArray[modelIdx];\n          let modelFilename = model.filename;\n          // let zOffsets = model.zOffsets;\n\n          // let layerFlags = layer.layerFlags; // NOrmaly 128, 128\n\n          // TODO: flip z,y?\n          let rotRangeX = layer.rotRangeX; // max min\n          let rotRangeY = layer.rotRangeY; // max min\n          let rotRangeZ = layer.rotRangeZ; // max min\n          let scaleRange = layer.scaleRange; // max min\n          let fadeRange = layer.fadeRange; // max min\n\n          // Unused\n          // tiling: 3\n          // type: 1\n          // width: 2\n          // radiusGround: 2\n\n          /// Create modelGroup (this zone only)\n          if (!modelGroups[modelFilename]) {\n            modelGroups[modelFilename] = [];\n          }\n\n          /// Add entry to model group\n          modelGroups[modelFilename].push({\n            x: modelX,\n            y: modelY,\n            z: modelZ,\n            rotRangeX: rotRangeX,\n            rotRangeY: rotRangeY,\n            rotRangeZ: rotRangeZ,\n            scaleRange: scaleRange,\n            fadeRange: fadeRange\n          });\n        } /// End if layer\n      } /// End if flag != 0\n    } /// End for each flag\n\n    return modelGroups;\n  };\n}\n\n/// NOT USED??\n// eslint-disable-next-line no-unused-vars\nfunction addZoneMeshesToScene(meshes, isCached, position, scale, rotation) {\n  /// Called for each mesh in the zone\n  /// TODO: Opt opt opt...\n\n  meshes.forEach(function(mesh) {\n    /// Create new mesh if we got back a cached original.\n    if (isCached) mesh = new THREE.Mesh(mesh.geometry, mesh.material);\n\n    /// Scale, position and rotate.\n    mesh.scale.set(scale, scale, scale);\n    if (rotation) {\n      mesh.rotation.order = \"ZXY\";\n      mesh.rotation.set(rotation.x, rotation.y, rotation.z);\n    }\n    mesh.position.set(position.x, position.y, position.z);\n\n    /// Add to export\n    this.getOutput().meshes.push(mesh);\n  });\n}\n\n/// DataRenderer inheritance:\nZoneRenderer.prototype = Object.create(DataRenderer.prototype);\nZoneRenderer.prototype.constructor = ZoneRenderer;\n\n/**\n * Renders all zone meshes in a GW2 map described by the map's \"zon2\" chunk.\n * Output fileds generated:\n *\n * - *meshes* An array of THREE.Mesh objects visualizing all zone models refered by this map.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nZoneRenderer.prototype.renderAsync = function(callback) {\n  let self = this;\n\n  /// Set up output array\n  self.getOutput().meshes = [];\n\n  let zoneChunkData = this.mapFile.getChunk(\"zon2\").data;\n  let parameterChunkData = this.mapFile.getChunk(\"parm\").data;\n  // let terrainChunkData = this.mapFile.getChunk(\"trn\").data;\n  let mapRect = parameterChunkData.rect;\n\n  /// Zone data\n  let zones = zoneChunkData.zoneArray;\n  let zoneDefs = zoneChunkData.zoneDefArray;\n\n  /// Render each zone\n  let lastPct = -1;\n\n  /// Main render loop, render each zone\n  function stepZone(i) {\n    let pct = Math.round((100.0 * i) / zones.length);\n    if (lastPct !== pct) {\n      self.logger.log(\n        T3D.Logger.TYPE_PROGRESS,\n        \"Loading 3D Models (Zone)\",\n        pct\n      );\n      lastPct = pct;\n    }\n\n    if (i >= zones.length) {\n      callback();\n      return;\n    }\n\n    /// Main zone render function call\n    self.renderZone(zones[i], zoneDefs, mapRect, stepZone.bind(self, i + 1));\n  }\n\n  stepZone(0);\n};\n\nmodule.exports = ZoneRenderer;\n\n/// / Not used: zone defintion per chunk data \"images\" 32*32 points\n/*\n//Total map dx and dy\nvar d = terrainChunkHeader.data;\nvar pd = parameterChunkHeader.data;\nvar dx = (pd.rect.x2-pd.rect.x1);\nvar dy = (pd.rect.y2-pd.rect.y1);\n\n//Each chunk dx and dy\n\nvar c =1;\nvar cdx = c*dx/d.dims.dim1;\n\nvar cdy = c*dy/d.dims.dim2;\n\nvar cdx = dx/(d.numChunksD_1*2);\nvar cdy =dy/(d.numChunksD_2*2);\n\nfor(var i=0; i<zoneDefs.length; i++){\n\tvar zoneDef = zoneDefs[i];\n\n\t//TODO: opt!\n\tzoneDef.layerDefs.forEach(function(layer){\n\n\t\tlayer.modelArray.forEach(function(model){\n\n\t\t});\n\n\t});\n\n\tvar chunkMat = new THREE.MeshBasicMaterial(\n\t\t{\n\t\t\tcolor: 0x00ff00,\n\t\t\twireframe:true,\n\t\t \topacity: 1.0,\n\t\t}\n\t);\n\n\t//TODO: opt!\n\n\tif(\n\t\tzoneDef.token == 597  ||\n\t\tzoneDef.token == 1369  ||\n\t\tzoneDef.token == 903\n\t){\n\n\t\tzoneDef.pageTable.pageArray.forEach(function(page){\n\t\t\tvar flags = page.flags;\n\t\t\tvar coord = page.chunkCoord;\n\n\t\t\t//Hightlight this coord\n\t\t\tvar rect = {};\n\n\t\t\t//var globalOffsetX = pd.rect.x2 - cdx;\n\t\t\tvar globalOffsetX = pd.rect.x1 + cdx/2;\n\t\t\tvar chunkOffsetX = coord[0] * cdx;\n\n\t\t\trect.x1  = globalOffsetX + chunkOffsetX;\n\n\t\t\t///Adjust for odd / even number of chunks\n\t\t\tif(d.numChunksD_2 % 2 == 0){\n\n\t\t\t\tvar globalOffsetY = -pd.rect.y1;\n\t\t\t\tvar chunkOffsetY = -coord[1] * cdy;\n\n\t\t\t\trect.y1  =  chunkOffsetY + globalOffsetY;\n\t\t\t}\n\t\t\telse{\n\n\t\t\t\tvar globalOffsetY =  -pd.rect.y1;\n\t\t\t\tvar chunkOffsetY = -coord[1] * cdy;\n\n\t\t\t\trect.y1 = globalOffsetY +  chunkOffsetY;\n\t\t\t}\n\n\t\t\trect.x2 = rect.x1+cdx;\n\t\t\trect.y2 = rect.y1+cdy;\n\n\t\t\tRenderUtils.renderRect(rect, 4000,chunkMat, 4000);\n\n\t\t\t//for(var j=0; j<flags.length; j++){\n\t\t\t//\tif(flags[j]>0){\n\t\t\t//\t\tconsole.log(\"Found flag\",flags[j],\"@ zoneDef\",zoneDef.token,\"coord\",coord,\"index\",j);\n\t\t\t//\t}\n\t\t\t//}\n\t\t});\n\n\t}\n\n} */\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst HEAD_STRUCT = [\n  \"type\",\n  \"cstring:4\",\n  \"chunkDataSize\",\n  \"uint32\",\n  \"chunkVersion\",\n  \"uint16\",\n  \"chunkHeaderSize\",\n  \"uint16\",\n  \"offsetTableOffset\",\n  \"uint32\"\n];\n\n/**\n * Settings for resolving conflicting chunk names in different files.\n * @private\n * @property DUPLICATE_SETTINGS\n * @type {Object}\n */\nlet DUPLICATE_SETTINGS;\n\n// Replacement for DUPLICATE_SETTINGS, based on the name of the root property.\nconst PACKTOCHUNK = [\n  { pack: \"MODL\", chunk: \"ANIM\", root: \"ModelFileAnimation\" },\n  { pack: \"MODL\", chunk: \"GAME\", root: \"ModelFileGame\" },\n  { pack: \"MODL\", chunk: \"SKEL\", root: \"ModelFileSkeleton\" },\n  { pack: \"MODL\", chunk: \"TOOL\", root: \"ModelFileTool\" },\n  { pack: \"cntc\", chunk: \"Main\", root: \"PackContent\" },\n  { pack: \"mMet\", chunk: \"Main\", root: \"PackMapMetadata\" },\n  { pack: \"AMAT\", chunk: \"TOOL\", root: \"AmatToolParams\" },\n  { pack: \"cmaC\", chunk: \"main\", root: \"CollideModelManifest\" }\n];\n\n// Builds the DUPLICATE_SETTINGS based on the provided T3D.formats.\n// Required to be done dynamically since the 32 bit and 64bits have different ordering\nfunction genDuplicateSettings() {\n  // Early return if the settings have been already generated\n  if (DUPLICATE_SETTINGS) return;\n\n  function getRootName(definition) {\n    let a = new definition();\n    return Object.keys(a).filter(v => {\n      return a[v] === a.__root && v !== \"__root\";\n    })[0];\n  }\n\n  DUPLICATE_SETTINGS = {};\n  for (let setting of PACKTOCHUNK) {\n    let regex = new RegExp(`^${setting.root}(V[0-9]*)?$`);\n    let chunkDef = T3D.formats.filter(v => {\n      return v.name === setting.chunk;\n    });\n\n    for (let defsIdx in chunkDef) {\n      let defs = chunkDef[defsIdx].versions;\n      let lastVersion = defs[Object.keys(defs).pop()];\n      let rootName = getRootName(lastVersion);\n      if (rootName.match(regex)) {\n        if (!DUPLICATE_SETTINGS[setting.chunk]) {\n          DUPLICATE_SETTINGS[setting.chunk] = [];\n        }\n        DUPLICATE_SETTINGS[setting.chunk][defsIdx] = setting.pack;\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Basic chunk parsing functionality for Guild Wars 2 file chunks\n *\n * @constructor\n * @param {DataStream} ds A DataStream containing deflated chunk binary data.\n * @param {Number} addr Offset of chunk start within the DataStream\n */\nclass GW2Chunk {\n  constructor(ds, addr) {\n    // Early returns if already called, it defines the DUPLICATE_SETTINGS variable\n    genDuplicateSettings();\n\n    /**\n     * @property {DataStream} ds The DataStream data source used by this chunk.\n     */\n    this.ds = ds;\n\n    /**\n     * @property {Number} addr The address to this Chunk within ds.\n     */\n    this.addr = addr;\n\n    /**\n     * @property {Object} data The typed data read from the body of this chunk.\n     */\n    this.data = null;\n\n    /**\n     * @property {Number} headerLength The length in bytes of the chunk header.\n     */\n    this.headerLength = NaN;\n\n    /**\n     * @property {Object} header Chunk header data.\n     */\n    this.loadHead();\n  }\n\n  /**\n   * Parses the chunk header data, populating the header property.\n   */\n  loadHead() {\n    this.ds.seek(this.addr);\n    this.header = this.ds.readStruct(HEAD_STRUCT);\n\n    this.headerLength = this.ds.position - this.addr;\n  }\n\n  /**\n   * @param  {String} fileType The main type of the pack file containing this chunk.\n   * Used for resolving chunk naming conflicts between pack file types.\n   * @return {Array}\tDataStream formatted array describing the data\n   * sctructures of this chunk\n   */\n  getDefinition(fileType) {\n    /// Normally we're looking for the 0th occurance\n    /// But some chunk names occur multiple times and we're interrested\n    /// in the N:th occurance of the definition.\n    ///\n    /// I've no idea how this is automated, for now just use the\n    /// settings object I've put together from experience.\n    let useNthIndex = 0;\n\n    /// If this chunk has multiple definitions\n    /// get to know what def to use...\n    let fileTypes = DUPLICATE_SETTINGS[this.header.type];\n    if (fileTypes) {\n      useNthIndex = -1;\n\n      /// Check what file name entry matches this file name\n      for (let i = 0; i < fileTypes.length && useNthIndex === -1; i++) {\n        let ft = fileTypes[i];\n\n        if (ft === fileType) {\n          useNthIndex = i;\n        }\n      }\n\n      /// We didnt find this file name!\n      /// TODO: if you get this error, please update the DUPLICATE_SETTINGS above\n      if (useNthIndex === -1) {\n        throw new Error(\"We didnt find this file name!\");\n        //debugger;\n      }\n    }\n\n    let defsFound = 0;\n    for (let i = 0; i < T3D.formats.length; i++) {\n      let f = T3D.formats[i];\n\n      /// Chunk name needs to match\n      if (f.name === this.header.type) {\n        /// There needs to be a chunk def version matching the one specifiend\n        ///\n        /// AND If this is the Nth occurance of the chunk definition\n        /// and we're looking for the Nth occurance, return it.\n        ///\n        /// chunkVersion in the dat uses 0 indexing\n        if (defsFound === useNthIndex && f.versions[this.header.chunkVersion]) {\n          return new f.versions[this.header.chunkVersion]().__root;\n        }\n\n        defsFound++;\n      }\n    }\n  }\n\n  /**\n   * Parses the chunk main data, populating the data property.\n   *\n   * @param  {String} fileType The main type of the pack file containing this chunk.\n   * Used for resolving chunk naming conflicts between pack file types when\n   * looking up the structure definition for this chunk.\n   */\n  loadData(fileType) {\n    let def = this.getDefinition(fileType);\n\n    if (def) {\n      this.ds.seek(this.addr + this.headerLength);\n      this.data = this.ds.readStruct(def);\n    } else {\n      T3D.Logger.log(\n        T3D.Logger.TYPE_WARNING,\n        \"Could not find a definition for chunk\",\n        this.header.type,\n        \"version\",\n        this.header.chunkVersion,\n        \"file name\",\n        fileType\n      );\n    }\n  }\n\n  /**\n   * Retrieves the next chunk is the datastream. In practice this means the next chunk\n   * within the same pack file.\n   *\n   * @return {GW2Chunk} The next chunk if any, otherwise null.\n   */\n  next() {\n    try {\n      // Calculate actual data size, as mChunkDataSize\n      // does not count the size of some header variables\n      return new GW2Chunk(this.ds, this.addr + 8 + this.header.chunkDataSize);\n    } catch (e) {\n      /// Out of bounds probably\n    }\n    return null;\n  }\n}\n\nmodule.exports = GW2Chunk;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst Chunk = require(\"./GW2Chunk\");\n\nconst HEAD_STRUCT = [\n  \"identifier\",\n  \"cstring:2\",\n  \"unknownField1\",\n  \"uint16\",\n  \"unknownField2\",\n  \"uint16\",\n  \"pkFileVersion\",\n  \"uint16\",\n  \"type\",\n  \"cstring:4\"\n];\n\n/**\n * Basic header and chunk parsing functionality for Guild Wars 2 pack files (PF)\n *\n * @constructor\n * @param {DataStream} ds A DataStream containing deflated file binary data.\n * @param {Number} addr Offset of file start within the DataStream\n * @param {boolean} noChunks If true, the file does not parse its\n * chunks on creation.\n */\nclass GW2File {\n  constructor(ds, addr, noChunks) {\n    /**\n     * @property {DataStream} ds The DataStream data source used by this file.\n     */\n    this.ds = ds;\n\n    /**\n     * @property {Number} addr The address to this File within ds.\n     */\n    this.addr = addr;\n\n    /// Not used anymore I think\n    this.data = null;\n\n    /**\n     * @property {Number} headerLength The length in bytes of the file header.\n     */\n    this.headerLength = NaN;\n\n    /**\n     * All {{#crossLink \"GW2Chunk\"}}chunks{{/crossLink}} contained in the file.\n     *\n     * @property chunks\n     * @type GW2Chunk[]\n     */\n    this.chunks = [];\n\n    /**\n     * @property {Object} header Chunk header data.\n     */\n    this.readHead();\n\n    if (!noChunks) {\n      this.readChunks();\n    }\n  }\n\n  /**\n   * Parses the file header data, populating the header property.\n   */\n  readHead() {\n    this.ds.seek(this.addr);\n    this.header = this.ds.readStruct(HEAD_STRUCT);\n    this.headerLength = this.ds.position - this.addr;\n  }\n\n  /**\n   * Parses the file headers and populates the chunks property.\n   */\n  readChunks() {\n    /// Reset chunks\n    this.chunks = [];\n\n    // var structs = this.getChunkStructs && this.getChunkStructs();\n\n    /// Load basic Chunk in order to read the chunk header.\n    let ch = new Chunk(this.ds, this.headerLength + this.addr);\n\n    // while(structs && ch!=null && ch.header.type){\n    while (ch !== null && ch.header.type) {\n      /// Load data and pass file type if we need to determine what chunk entry to use\n      /// (Some chunks in different files share the same chunk name)\n      ch.loadData(this.header.type);\n      this.chunks.push(ch);\n\n      /// Load next basic Chunk in order to read the chunk header.\n      ch = ch.next();\n    }\n  }\n\n  /**\n   * Get a GW2Chunk from this file\n   *\n   * @param  {String} type The name, or type of the desired chunk.\n   * @return {GW2Chunk} The first GW2Chunk in this file matching the type name, or null if no matching GW2Chunk was found.\n   */\n  getChunk(type) {\n    for (let i = 0; i < this.chunks.length; i++) {\n      if (this.chunks[i].header.type.toLowerCase() === type.toLowerCase()) {\n        return this.chunks[i];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Provides a list of known header types and their parsing structure. Should be defined by each file type individually.\n   *\n   * @return {Object} An object mapping chunk identifiers to DataStream structure descriptors.\n   */\n  getChunkStructs() {\n    return {};\n  }\n}\n\nmodule.exports = GW2File;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n\tguid 1683952224941671000 is fucked up floor in SAB HUB\n\tmaterialFilename for that mesh is 564821, shared with lots of stuff\n\tlod 1 and 2 are both 0\n\tmaterial flags is 2056\n*/\n\n/**\n * Collection of methods for generating THREE materials and textures\n * from Guild Wars 2 data formats.\n * @namespace MaterialUtils\n */\n\n/**\n * Builds a custom vertex shader for a given number of uv cannels.\n * WIP not implemented yet!\n *\n * @memberof MaterialUtils\n * @param  {Number} numUv Number of UV channels used by this shader\n * @return {String}       Genereted vertex shader source\n */\nfunction buildVS(numUv) {\n  let vdefs = \"\";\n  let adefs = \"\";\n  let reads = \"\";\n  for (let i = 0; i < numUv; i++) {\n    vdefs += \"varying vec2 vUv_\" + (i + 1) + \";\\n\";\n\n    /// uv and uv2 are defined by THREE\n    if (i > 1) adefs += \"attribute vec2 uv\" + (i + 1) + \";\\n\";\n\n    reads += \"vUv_\" + (i + 1) + \" = uv\" + (i > 0 ? i + 1 : \"\") + \";\\n\";\n  }\n\n  return (\n    adefs +\n    vdefs +\n    \"void main()\\n\" +\n    \"{\\n\" +\n    reads +\n    \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\" +\n    \"gl_Position = projectionMatrix * mvPosition;\\n\" +\n    \"}\"\n  );\n}\n\n/**\n * Generate a texture of a specified color, used to be part of THREEjs\n *\n * @memberof MaterialUtils\n * @param {Number} width\n * @param {Number} height\n * @param {THREE.Color} color\n * @returns {THREE.DataTexture}\n */\nfunction generateDataTexture(width, height, color) {\n  // create a buffer with color data\n  let size = width * height;\n  let data = new Uint8Array(4 * size);\n  let r = Math.floor(color.r * 255);\n  let g = Math.floor(color.g * 255);\n  let b = Math.floor(color.b * 255);\n  let a = 255;\n\n  for (let i = 0; i < size; i++) {\n    let stride = i * 4;\n\n    data[stride] = r;\n    data[stride + 1] = g;\n    data[stride + 2] = b;\n    data[stride + 3] = a;\n  }\n  // used the buffer to create a DataTexture\n  return new THREE.DataTexture(data, width, height, THREE.RGBAFormat);\n}\n\n/**\n * Builds a custom pixel shader for a given number of uv cannels.\n * WIP not implemented yet!\n *\n * @memberof MaterialUtils\n * @param  {Array}  textures  THREE textures\n * @param  {Number} numUv     Number of UV channels used by this shader\n * @param  {Number} alphaTest Texture see-trough alpha treshold\n * @param  {any} lightMap  TODO\n * @returns {string}\n */\nfunction buildPS(textures, numUv, alphaTest, lightMap) {\n  let t1uv = \"vUv_\" + (textures[0].uvIdx + 1);\n\n  let discard = \"\";\n\n  if (alphaTest) {\n    discard = \"    if (c1.a < 0.5) \\n\" + \"       discard;\\n\";\n  }\n\n  /// Color from 1st text or lighted by 2nd?\n  let writeColor = \"gl_FragColor = c1;\\n\";\n\n  if (lightMap) {\n    let texIdx = 0;\n    // var t2uv = \"vUv_4\";//+(3-textures[texIdx].uvIdx+1);\n    let t2uv = \"vUv_1\"; // + (textures[texIdx].uvIdx+1);\n    // console.log(\"t2uv\",t2uv);\n\n    writeColor =\n      \"   vec4 c2 = texture2D( texture\" +\n      (texIdx + 1) +\n      \", \" +\n      t2uv +\n      \" );\\n\" +\n      \"     gl_FragColor = c2;\\n\";\n    // \"     gl_FragColor = vec4(c2.rgb * c1.r/.5, c2.a);\\n\";\n  }\n\n  let uniforms = \"\";\n  textures.forEach(function(t, idx) {\n    uniforms += \"uniform sampler2D texture\" + (idx + 1) + \";\\n\";\n  });\n  /* uniforms += \"uniform sampler2D texture1;\\n\";\n\tif(lightMap)\n\t\tuniforms += \"uniform sampler2D texture2;\\n\"; */\n\n  let varyings = \"\";\n  for (let i = 0; i < numUv; i++) {\n    varyings += \"varying vec2 vUv_\" + (i + 1) + \";\\n\";\n  }\n\n  return (\n    uniforms +\n    varyings +\n    \"void main( void ) {\\n\" +\n    \"    vec4 c1 = texture2D( texture1, \" +\n    t1uv +\n    \" );\\n\" +\n    discard +\n    writeColor +\n    \"}\"\n  );\n}\n\n/**\n * WIP, concept for generatin materials to render multi UV chanelled meshes.\n *\n * @memberof MaterialUtils\n * @param  {Array} \ttextures  THREE texture\n * @param  {Number} numUV     Number of UV channels used by this shader\n * @param  {Number} alphaTest Texture see-trough alpha treshold\n * @return {THREE.ShaderMaterial} Generated shader\n */\nfunction getUVMat(textures, numUV, alphaTest) {\n  let lightMap = false;\n  let uniforms = {};\n\n  textures.forEach(function(t, idx) {\n    uniforms[\"texture\" + idx] = { type: \"t\", value: t };\n  });\n\n  if (textures.length > 1) {\n    lightMap = true;\n  }\n\n  let attributes = {};\n\n  for (let i = 2; i < numUV; i++) {\n    attributes[\"uv\" + (i + 1)] = { type: \"v2\", value: [] };\n  }\n\n  let vs = buildVS(numUV);\n\n  return new THREE.ShaderMaterial({\n    uniforms: uniforms,\n    vertexShader: vs,\n    fragmentShader: buildPS(textures, numUV, alphaTest, lightMap),\n    attributes: attributes,\n    side: THREE.FrontSide\n  });\n}\n\n/**\n * Builds a THREE texture from a ModelMaterialData by reading settings and\n * loading any required data from the localReader. Uses sharedTextures for\n * texture caching.\n *\n * This method is full of guesses and estimations, and could be improved on\n * a lot, allowing rendering of multi UV channeled materials, or special\n * materials like custom color chanelled gear.\n *\n * @memberof MaterialUtils\n * @param  {ModelMaterialData} material \tA value object often automaticaly\n *                                       \tgenerated by a\n *                                       \t{{#crossLink \"GW2Chunk\"}}{{/crossLink}}\n *                                       \tstructure definitions can be found in\n *                                       \tAllFormats.js, look for the latest\n *                                       \tversion of ModelMaterialData\n *\n * @param  {GW2File} materialFile   A GW2File instance, must be of type AMAT\n * @param  {LocalReader} localReader The LocalReader to load the file contents from.\n * @param  {Object} sharedTextures  Value Object for keeping the texture cache\n * @return {THREE.Material}         A THREE Material with the generated contents and settings.\n */\nfunction getMaterial(material, materialFile, localReader, sharedTextures) {\n  if (!materialFile) return;\n\n  let dxChunk = materialFile.getChunk(\"dx9s\");\n  let grChunk = materialFile.getChunk(\"grmt\");\n\n  /// Append all textures to the custom material\n  let finalTextures = [];\n\n  // Some materials don't use textures..\n  if (\n    material &&\n    material.textures.length /* && material.textures[texIndex] */\n  ) {\n    /// TODO: check for flags!\n    ///\n    /// techinques[] -> passes[] -> effects[] -> samplerIndex[]\n    ///\n    // console.log(\"num effects\",dxChunk.data.techniques[0].passes[0].effects.length);\n\n    // if(grChunk.data.flags!=76)\n    //\treturn;\n\n    /// 3 teqs : high medium low\t\t\t\t\t\t\t\tGRAPHICS LEVEL SETTINGS\n    /// 1 passes\t\t\t\t\t\t\t\t\t\t\t\tDON'T CARE\n    /// 15 effects\t\t\tEach effect has a pixel shader \t\tHOW??\n    /// 1 or 2 sampler indices \t\t\t\t\t\t\t\t\tUSE ALL! (Multi material)\n\n    let effects = dxChunk.data.techniques[0].passes[0].effects;\n    // var effect = effects[10];\n    let effect = effects[0];\n\n    //let shader = dxChunk.data.shaders[effect.pixelShader];\n\n    /* effects.forEach(function (eff) {\n\t\t\tif(eff.samplerIndex.length > effect.samplerIndex.length)\n\t\t\t\teffect = eff;\n\t\t}); */\n    // var samplerIdx = effect.samplerIndex[0];\n\n    let samplerTextures = [];\n    let textureToken;\n    let samplerTex;\n    for (let i = 0; i < effect.samplerIndex.length; i++) {\n      let samplerIdx = effect.samplerIndex[i];\n      let sampler = dxChunk.data.samplers[samplerIdx];\n\n      /// SHOULD NEVER HAPPEN, hide mesh!\n      if (!sampler) continue; // return;\n\n      textureToken = sampler && grChunk.data.texTokens[sampler.textureIndex];\n      if (!textureToken) textureToken = \"0-0\";\n      /* else\n\t\t\t\ttextureToken =textureToken.val; */\n\n      /// Find the texture reffered by this sampler\n      samplerTex = null;\n\n      material.textures.forEach(function(tex /*, index*/) {\n        /// Seems like only 1st part of token is used...\n        if (\n          !samplerTex &&\n          tex.token.split(\"-\")[0] === textureToken.split(\"-\")[0]\n        ) {\n          // console.log(\"TEX match\",tex.token, textureToken)\n          samplerTex = tex;\n        }\n      });\n\n      /// Add this sampler's texture to the collection of all textures\n      if (samplerTex) {\n        samplerTextures.push(samplerTex);\n      } else {\n        /// FALLBACK, just guess what texture we should use\n        if (sampler) {\n          samplerTextures.push(material.textures[sampler.textureIndex]);\n        } else if (material.textures.length > 0) {\n          samplerTextures.push(material.textures[0]);\n        } else return;\n      }\n    } /// END for each sampler index in effect\n\n    /// We now have all textures\n    // console.log(\"textures from sampler\", samplerTextures);\n\n    /// Fallback to using whatever texture there is.\n    if (samplerTextures.length <= 0) {\n      return;\n      // mainTex =  material.textures[0];\n    }\n\n    // console.log(\"num samplers \",samplerTextures.length);\n    samplerTextures.forEach(function(texture, idx) {\n      if (!texture) return;\n\n      /// Set texture \"URL\"\n      let texURL = texture && texture.filename;\n\n      /// Load texture from RAM or local reader:\n      finalTextures[idx] = getTexture(texURL, localReader, sharedTextures);\n      if (finalTextures[idx]) {\n        finalTextures[idx].uvIdx = texture.uvPSInputIndex;\n      }\n    });\n  } /// End if material and texture\n\n  let finalMaterial;\n\n  /// Create custom shader material if there are textures\n  if (finalTextures) {\n    // TODO: make this work!\n    //eslint-disable-next-line no-constant-condition\n    if (false && finalTextures.length > 0) {\n      finalMaterial = getUVMat(\n        finalTextures,\n        material.texCoordCount,\n        grChunk.data.flags !== 16460\n      );\n    } else {\n      let ft = false;\n      let nt = false;\n      material.textures.forEach(function(t) {\n        // Flag for diffuse map\n        if (!ft && t.token.split(\"-\")[0] === \"1733499172\") ft = t;\n\n        // Flag for normal map\n        if (!nt && t.token.split(\"-\")[0] === \"404146670\") nt = t;\n      });\n\n      if (!ft || ft.filename <= 0) return;\n\n      finalMaterial = new THREE.MeshPhongMaterial({\n        side: THREE.FrontSide,\n        map: getTexture(ft.filename, localReader, sharedTextures)\n      });\n      if (nt) {\n        let normalMap = getTexture(nt.filename, localReader, sharedTextures);\n        normalMap.flipY = true;\n        finalMaterial.normalMap = normalMap;\n      }\n\n      finalMaterial.textureFilename = ft.filename;\n      if (grChunk.data.flags !== 16460) {\n        // console.log(\"Setting alpha flag for \",grChunk.data.flags)\n        finalMaterial.alphaTest = 0.05;\n      }\n    }\n  }\n\n  /// Fallback material is monocolored red\n  else {\n    finalMaterial = new THREE.MeshBasicMaterial({\n      side: THREE.FrontSide,\n      color: 0xff0000,\n      shading: THREE.FlatShading\n    });\n  }\n\n  finalMaterial.needsUpdate = true;\n\n  /// Set material props\n  /// disable for now in order for custom shaders not to fuck up\n\n  if (material) {\n    let alphaMask0 = 0x0001; // + 0x0100 + 0x0200;\n    let alphaMask1 = 0x0010;\n    let alphaMask2 = 0x0100 + 0x0200;\n    //let alphaMask2b = 0x0200;\n\n    grChunk = materialFile.getChunk(\"grmt\");\n\n    // Enable alpha test for transparent flags\n    if (\n      material.materialFlags & alphaMask0 ||\n      material.materialFlags & alphaMask1 ||\n      material.materialFlags & alphaMask2 // && solidColor != null\n    ) {\n      // return;\n      // mesh.material.transparent = true;\n      // mesh.material.opacity = 2.0;\n      // var clr = solidColor;\n      // var propAlpha = 0;\n      /// Backgroud color adds to alpha\n      // if( mesh.materialFlags == 2569  ){\n      /// This is rly just guesswork\n      /// Check material flag  2568 (as int) and compare material filename 27353 to 20041\n      /// Same flags but some have alpha and some don't\n      // if( mesh.materialFlags & alphaMask2b  ){\n      //\tpropAlpha =  (clr[3] - 128)/128;\n      //\t//propAlpha = Math.max(0,propAlpha);\n      // }\n      // mesh.material.alphaTest = Math.max(0, 0.1 );//- propAlpha*2);\n    }\n\n    /// GRCHUNK -> DATA -> FLAGS\n\n    /// HAS LIGHT - TEX - ? - EMISSIVE16460\n    ///\n\n    /// 56533 LOD FOR TOMBSTONE?\n\n    //\t16460\t\t\t0100 0000 0100 1100\t\t\t\"standard\" stuff rendering OK in SAB (no alpha test)\n\n    //\n    //\t16452(SAB)\t\t0100 0000 0100 0100\t\t\tyellow numbers in sab signs\n    //\t16448(SAB)\t\t0100 0000 0100 0000\t\t\tfaces on rocks, cloudmen, skybox portal images, holes in walls, floor plates...\n    //\t\t\t\t\t\t\t\t\t\t\t\tno lighting??\n    //\n    //\t 8268\t\t\t0010 0000 0100 1100\n    //\t 3392\t\t\t0000 1101 0100 0000\t\t\tMoto machine light bulbs\n    //\t 2380\t\t\t0000 1001 0100 1100\n    //\t 2368\t\t\t0000 1001 0100 0000\t\t\tFountain water with rings, portal border and circular \"light\"\n    //\t  332\t\t\t0000 0001 0100 1100\n    //\t  324\t\t\t0000 0001 0100 0100\t\t\tMoto face sprites\n    //\n    //\t  320(SAB)\t\t0000 0001 0100 0000\t\t\tportal textures (normal maps ish)\n    //\n    //\t   76\t\t\t0000 0000 0100 1100\t\t\tLOTS OF STUFF\n    //\t   \t\t\t\t\t\t\t\t\t\t\tTree leaves, ground, hills, some roofs, flags, street lights\n    //\t   \t\t\t\t\t\t\t\t\t\t\tsheild textures, some fences, water tops, waterfall\n    //\n    //\t   \t\t\t\t\t\t\t\t\t\t\tIN KHYLO \"everything with alpha\"\n    //\n    //\n    //\t   68\t\t\t0000 0000 0100 0100\t\t\tSome flowers (lo res?) fountain edges foam\n    //\n    //\t   64(SAB)\t\t0000 0000 0100 0000\t\t\tclouds, sun iamge\n\n    let lightMask = 8;\n\n    let knownFileFlags = [\n      16460,\n      16452,\n      16448,\n      8268,\n      3392,\n      2380,\n      2368,\n      332,\n      324,\n      320,\n      76,\n      68,\n      64\n    ];\n\n    if (knownFileFlags.indexOf(grChunk.data.flags) < 0) {\n      T3D.Logger.log(\n        T3D.Logger.TYPE_WARNING,\n        \"unknown GR flag\",\n        grChunk.data.flags\n      );\n    }\n\n    if (!(grChunk.data.flags & lightMask)) {\n      // debugger;\n      // console.log(\"no light\");\n      finalMaterial = new THREE.MeshBasicMaterial({\n        side: THREE.FrontSide,\n        map: finalMaterial.map\n      });\n    }\n\n    if (grChunk.data.flags !== 16460) {\n      finalMaterial.alphaTest = 0.05;\n    }\n  } /// End if material\n\n  return finalMaterial;\n}\n\n/**\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\n * Any loaded tetures are added to sharedTextures, allowing for texture caching and fewer reads.\n *\n * @memberof MaterialUtils\n * @param  {Number} texURL         The fileId or baseId of the file to load image data from.\n * @param  {LocalReader} localReader    The LocalReader to load the file contents from.\n * @param  {Object} sharedTextures Value Object for keeping the texture cache\n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nfunction getTexture(texURL, localReader, sharedTextures) {\n  let finalTexture;\n\n  /// Read texture from shared array of loaded textures\n  /// or read it from URL and add to shared ones!\n  if (texURL && sharedTextures[texURL]) {\n    /// Just read from already loaded textures.\n    finalTexture = sharedTextures[texURL];\n  } else if (texURL) {\n    /// Load and add to shared array.\n    finalTexture = loadLocalTexture(localReader, texURL);\n\n    /// Set standard texture functionality.\n    finalTexture.wrapT = THREE.RepeatWrapping;\n    finalTexture.wrapS = THREE.RepeatWrapping;\n    finalTexture.flipY = false;\n\n    sharedTextures[texURL] = finalTexture;\n  }\n\n  return finalTexture;\n}\n\n/**\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\n * If you're loading multiple textures, make sure to use\n * {{#crossLink \"MaterialUtils/getTexture\"}}{{/crossLink}} that allows you to cache textures.\n *\n * @memberof MaterialUtils\n * @param {LocalReader} localReader - The LocalReader to load the file contents from.\n * @param {Number} fileId - The fileId or baseId of the file to load image data from.\n * @param {Number} mapping - What THREE mapping the returned texture will use, not implemented.\n\n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nfunction loadLocalTexture(localReader, fileId, mapping, defaultColor, onerror) {\n  if (defaultColor === undefined) {\n    defaultColor = Math.floor(0xffffff * Math.random());\n  }\n\n  /// Temporary texture that will be returned by the function.\n  /// Color is randomized in order to differentiate different textures during loading.\n  let texture = generateDataTexture(\n    1, // Width\n    1, // Height\n    new THREE.Color(defaultColor) // Color\n  );\n\n  // Threejs r71 is using these settings by default, r72+ changed it\n  texture.minFilter = THREE.LinearMipMapLinearFilter;\n  texture.magFilter = THREE.LinearFilter;\n  texture.generateMipmaps = true;\n  texture.flipY = true;\n\n  /// Only allow non-zero fileId, otherwise jsut return static texture\n  if (parseInt(fileId) <= 0) {\n    if (onerror) onerror();\n    return texture;\n  }\n\n  /// Load file using LocalReader.\n  localReader.loadTextureFile(fileId, function(\n    inflatedData,\n    dxtType,\n    imageWidth,\n    imageHeigth\n  ) {\n    /// Require infalted data to be returned.\n    if (!inflatedData) {\n      if (onerror) onerror();\n      return;\n    }\n\n    /// Create image using returned data.\n    let image = {\n      data: new Uint8Array(inflatedData),\n      width: imageWidth,\n      height: imageHeigth\n    };\n\n    /// Use RGBA for all textures for now...\n    /// TODO: don't use alpha for some formats!\n    texture.format =\n      //eslint-disable-next-line no-constant-condition\n      dxtType === 3 || dxtType === 5 || true\n        ? THREE.RGBAFormat\n        : THREE.RGBFormat;\n\n    /// Update texture with the loaded image.\n    texture.image = image;\n    texture.needsUpdate = true;\n  });\n\n  /// Return texture with temporary content.\n  return texture;\n}\n\nmodule.exports = {\n  buildVS: buildVS,\n  generateDataTexture: generateDataTexture,\n  buildPS: buildPS,\n  getUVMat: getUVMat,\n  getMaterial: getMaterial,\n  loadLocalTexture: loadLocalTexture\n};\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst base32Max = Math.pow(2, 32);\n\n/**\n * Collection Math and sorting methods\n * @namespace MathUtils\n */\n\n/**\n * Takes an integer and calculates what the 16 bit float\n * representation of the binary data used to read the integer is.\n *\n * @memberof MathUtils\n * @param  {Number} h Integer value\n * @return {Number} Float value\n */\nfunction f16(h) {\n  let s = (h & 0x8000) >> 15;\n  let e = (h & 0x7c00) >> 10;\n  let f = h & 0x03ff;\n\n  if (e === 0) {\n    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n  } else if (e === 0x1f) {\n    return f ? NaN : (s ? -1 : 1) * Infinity;\n  }\n\n  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\n}\n\n/**\n * Calculates the number of binary ones present in the data used to\n * generate the input integer.\n *\n * @memberof MathUtils\n * @param  {Number} bits Integer\n * @return {Number}      Number of binary ones in the data\n */\nfunction popcount(bits) {\n  let SK5 = 0x55555555;\n  let SK3 = 0x33333333;\n  let SKF0 = 0x0f0f0f0f;\n  // let SKFF = 0xff00ff\n\n  bits -= (bits >> 1) & SK5;\n  bits = (bits & SK3) + ((bits >> 2) & SK3);\n  bits = (bits & SKF0) + ((bits >> 4) & SKF0);\n  bits += bits >> 8;\n\n  return (bits + (bits >> 15)) & 63;\n}\n\n/**\n * Calculates the 64 bit integer value of two 32 bit integers. Only works up to\n * the limit of the javascript Number maximum value.\n *\n * @memberof MathUtils\n * @param  {Number[]} arr     Input integers, length should be 2.\n * @return {Number}      64 bit representation of the two integers.\n */\nfunction arr32To64(arr) {\n  /// Re-read as uint64 (still little endian)\n  /// Warn: this will not work for ~50+ bit longs cus all JS numbers are 64 bit floats...\n  return base32Max * arr[1] + arr[0];\n}\n\n/**\n * Sorts an array and returns unique values only.\n *\n * @memberof MathUtils\n * @param  {Array} arr_in     Input array\n * @param  {Function} comparator A comparator function between the objects in arr_in\n * @return {Array}            Sorted and unique value.\n */\nfunction sort_unique(arr_in, comparator) {\n  let arr = Array.prototype.sort.call(arr_in, comparator);\n\n  let u = {};\n  let a = [];\n  for (let i = 0, l = arr.length; i < l; ++i) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (u.hasOwnProperty(arr[i])) {\n      continue;\n    }\n    a.push(arr[i]);\n    u[arr[i]] = 1;\n  }\n\n  return a;\n}\n\nmodule.exports = {\n  f16: f16,\n  popcount: popcount,\n  arr32To64: arr32To64,\n  sort_unique: sort_unique\n};\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @namespace ParserUtils\n */\n\n/**\n * Collection of methods used for parsing complex data types from the .dat\n *\n * Most of these methods are only refered by the automatically generated script\n * AllFormats.js\n *\n */\n\nmodule.exports = {\n  /**\n   * Generates a function for reading an array using DataStream\n   *\n   * @param  {Array} structDef DataStream formatted structure definition\n   *                           for the items in the array.\n   * @param  {Number} maxCount The maximum allowed length of the array.\n   *                           Allows any length if left unspecified.\n   * @return {Function}        The generated parsing function.\n   */\n  getArrayReader: function(structDef, maxCount) {\n    return function(ds, struct) {\n      let ret = [];\n      try {\n        let arr_len = ds.readUint32();\n        let offset = ds.readUint32();\n        if (offset === 0) {\n          return ret;\n        }\n        let arr_ptr = ds.position - 4 + offset;\n        let pos = ds.position;\n\n        if (maxCount && arr_len > maxCount) {\n          throw \"Array length \" +\n            arr_len +\n            \" exceeded allowed maximum \" +\n            maxCount;\n        }\n\n        ds.seek(arr_ptr);\n        ret = ds.readType([\"[]\", structDef, arr_len], struct);\n        ds.seek(pos);\n      } catch (e) {\n        console.warn(\"getArrayReader Failed loading array\", e);\n        console.warn(\n          \"getArrayReader Failed loading array, structDef\",\n          structDef\n        );\n      }\n      return ret;\n    };\n  },\n\n  /**\n   * Generates a function for reading a refered array using DataStream\n   *\n   * @param  {Array} structDef DataStream formatted structure definition\n   *                           for the items in the array.\n   * @return {Function}        The generated parsing function.\n   */\n  getRefArrayReader: function(structDef) {\n    return function(ds) {\n      let ret_arr = [];\n\n      /// Read array of offsets\n      let arr_len = ds.readUint32();\n      let arr_ptr = ds.position + ds.readUint32();\n\n      if (arr_len === 0) {\n        return ret_arr;\n      }\n\n      let orgPos = ds.position;\n\n      /// Go to pointer and read an array of offsets!\n      ds.seek(arr_ptr);\n      let offsets = ds.readInt32Array(arr_len);\n\n      // p_data is after having read array\n      // var pointer = p_data - 4;\n      let pointer = orgPos - 4;\n\n      // auto offset  = *reinterpret_cast<const int32*>(pointer);\n      ds.seek(pointer);\n      let offset = ds.readUint32(); /// this should be the same as arr_ptr\n\n      // pointer     += offset;\n      pointer += offset;\n\n      for (let i = 0; i < offsets.length; i++) {\n        if (offsets[i] !== 0) {\n          let pos = pointer + i * 4 + offsets[i];\n          ds.seek(pos);\n\n          try {\n            ret_arr.push(ds.readStruct(structDef));\n          } catch (e) {\n            // debugger;\n            ret_arr.push(null);\n            console.warn(\n              \"getRefArrayReader could not find refered data at offset\",\n              offsets[i],\n              e\n            );\n          }\n        }\n      } /// End for each offset\n\n      ds.seek(orgPos);\n      return ret_arr;\n    };\n  },\n\n  /**\n   * Generates a function for reading a 64bit initeger. For now just reads each\n   * 32 bit integer and glues together as a string.\n   *\n   * @return {Function}        The generated parsing function.\n   */\n  getQWordReader: function() {\n    // let base32Max = 4294967296;\n    return function(ds /*, struct */) {\n      return ds.readUint32() + \"-\" + ds.readUint32();\n\n      // let p0 = ds.readUint32();\n      // let p1 = ds.readUint32();\n      // return base32Max * p1 + p0;\n    };\n  },\n\n  /**\n   * Generates a function for reading a string of 8 bit chars.\n   *\n   * @return {Function}        The generated parsing function.\n   */\n  getStringReader: function() {\n    return function(ds /*, struct*/) {\n      let ptr = ds.position + ds.readUint32();\n      let pos = ds.position;\n\n      /// Go to pointer\n      ds.seek(ptr);\n\n      let ret = ds.readCString();\n\n      /// Go back to where we were\n      ds.seek(pos);\n\n      return ret;\n    };\n  },\n\n  /**\n   * Generates a function for reading a string of 16 bit chars.\n   *\n   * @return {Function}        The generated parsing function.\n   */\n  getString16Reader: function(stringOffset) {\n    return function(ds /*, struct*/) {\n      let ptr = ds.position + ds.readUint32() + (stringOffset || 0);\n      let pos = ds.position;\n\n      /// Go to pointer\n      ds.seek(ptr);\n\n      let ret = \"\";\n      let num;\n      while (ds.position + 2 < ds.byteLength && (num = ds.readUint16()) !== 0) {\n        ret += String.fromCharCode(num);\n      }\n      // ds.readCString();\n\n      /// Go back to where we were\n      ds.seek(pos);\n\n      return ret;\n    };\n  },\n\n  /**\n   * Generates a function for reading a pointer.\n   *\n   * @param  {Array} structDef DataStream formatted structure definition\n   *                           for the item pointed to.\n   * @return {Function}        The generated parsing function.\n   */\n  getPointerReader: function(structDef) {\n    return function(ds /*, struct*/) {\n      let offset = ds.readUint32();\n\n      if (offset === 0) {\n        return {};\n      }\n\n      let ptr = ds.position - 4 + offset;\n      let pos = ds.position;\n\n      /// Go to pointer\n      ds.seek(ptr);\n\n      let ret = ds.readStruct(structDef);\n\n      /// Go back to where we were\n      ds.seek(pos);\n\n      return ret;\n    };\n  },\n\n  /**\n   * Generates a function for reading a filename/file Id.\n   *\n   * @return {Function}        The generated parsing function.\n   */\n  getFileNameReader: function() {\n    return function(ds /*, struct*/) {\n      let pos;\n      try {\n        let ptr = ds.position + ds.readUint32();\n        pos = ds.position;\n\n        /// Go to pointer\n        ds.seek(ptr);\n\n        let fileRef = ds.readStruct([\n          \"m_lowPart\",\n          \"uint16\", // uint16 m_lowPart;\n          \"m_highPart\",\n          \"uint16\", // uint16 m_highPart;\n          \"m_terminator\",\n          \"uint16\" // uint16 m_terminator;\n        ]);\n\n        /// Getting the file name...\n        /// Both need to be >= than 256 (terminator is 0)\n        let ret =\n          0xff00 * (fileRef.m_highPart - 0x100) +\n          (fileRef.m_lowPart - 0x100) +\n          1;\n        // var ret = (fileRef.m_highPart - 0x100) * 0xff00 + (fileRef.m_lowPart - 0xff);\n\n        if (ret < 0) {\n          ret = 0;\n          // console.log(\"FR negative\", fileRef.m_highPart, fileRef.m_lowPart, fileRef.m_terminator);\n          // debugger;\n        }\n\n        /// Go back to where we were\n        ds.seek(pos);\n\n        return ret;\n      } catch (e) {\n        /// Go back to where we were\n        ds.seek(pos);\n\n        return -1;\n      }\n    };\n  }\n};\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require(\"../format/file/GW2File\");\nconst MaterialUtils = require(\"./MaterialUtils\");\nconst MathUtils = require(\"./MathUtils\");\n\n// TODO: Remove this local cache!!\nlet matFiles = {};\n\n/**\n * Object describing the meaning of the bits in fvf integers.\n * @property fvfFormat\n * @private\n * @type {Object}\n */\nlet fvfFormat = {\n  Position: 0x00000001 /** < 12 bytes. Position as three 32-bit floats in the order x, y, z. */,\n  Weights: 0x00000002 /** < 4 bytes. Contains bone weights. */,\n  Group: 0x00000004 /** < 4 bytes. Related to bone weights. */,\n  Normal: 0x00000008 /** < 12 bytes. Normal as three 32-bit floats in the order x, y, z. */,\n  Color: 0x00000010 /** < 4 bytes. Vertex color. */,\n  Tangent: 0x00000020 /** < 12 bytes. Tangent as three 32-bit floats in the order x, y, z. */,\n  Bitangent: 0x00000040 /** < 12 bytes. Bitangent as three 32-bit floats in the order x, y, z. */,\n  TangentFrame: 0x00000080 /** < 12 bytes. */,\n  UV32Mask: 0x0000ff00 /** < 8 bytes for each set bit. Contains UV-coords as two 32-bit floats in the order u, v. */,\n  UV16Mask: 0x00ff0000 /** < 4 bytes for each set bit. Contains UV-coords as two 16-bit floats in the order u, v. */,\n  Unknown1: 0x01000000 /** < 48 bytes. Unknown data. */,\n  Unknown2: 0x02000000 /** < 4 bytes. Unknown data. */,\n  Unknown3: 0x04000000 /** < 4 bytes. Unknown data. */,\n  Unknown4: 0x08000000 /** < 16 bytes. Unknown data. */,\n  PositionCompressed: 0x10000000 /** < 6 bytes. Position as three 16-bit floats in the order x, y, z. */,\n  Unknown5: 0x20000000 /** < 12 bytes. Unknown data. **/\n};\n\n/**\n * Collection of methods used for generating THREE meshes from Guild Wars 2 data formats.\n * @namespace RenderUtils\n */\n\n/**\n * Creates a mesh representing a single plane.\n *\n * @memberof RenderUtils\n * @param  {Object} rect     An object with x1,x2,y1 and y2 properties.\n * @param  {Number} yPos     Vertical position of the rectangle.\n * @param  {THREE.Material} material \tMesh material to apply.\n * @param  {Number} dy       Mesh height.\n * @return {THREE.Mesh}      The generated mesh.\n */\nfunction renderRect(rect, yPos, material, dy) {\n  let dx = rect.x1 - rect.x2;\n  let dz = rect.y1 - rect.y2;\n  if (!dy) dy = 1;\n\n  let cx = (rect.x1 + rect.x2) / 2;\n  let cz = (rect.y1 + rect.y2) / 2;\n  let cy = yPos;\n\n  let geometry = new THREE.BoxGeometry(dx, dy, dz);\n\n  material =\n    material ||\n    new THREE.MeshBasicMaterial({\n      color: 0xff0000,\n      wireframe: true\n    });\n  let plane = new THREE.Mesh(geometry, material);\n  plane.overdraw = true;\n\n  plane.position.x = cx;\n  plane.position.y = cy;\n  plane.position.z = cz;\n\n  return plane;\n}\n\n/**\n * Load image data into a THREE.Texture from a file within the GW2 .dat file using a LocalReader.\n *\n * @deprecated Please use the original function from MaterialUtils\n * @memberof RenderUtils\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Number} fileId The fileId or baseId of the file to load image data from.\n * @param {Number} mapping What THREE mapping the returned texture will use, not implemented.\n * @param  {Array} defaultColor RGBA array of 4 integers. The default solid color of the mesh, should texture loading fail.\n * @param {Function} onerror Error callback, not implemented.\n *\n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nfunction loadLocalTexture(localReader, fileId, mapping, defaultColor, onerror) {\n  T3D.Logger.log(\n    T3D.Logger.TYPE_WARNING,\n    \"RenderUtils.loadLocalTexture is deprecated ! Please use the one from MaterialUtils.\"\n  );\n  return MaterialUtils.loadLocalTexture(\n    localReader,\n    fileId,\n    mapping,\n    defaultColor,\n    onerror\n  );\n}\n\n/**\n * Returns a THREE representation of the data contained by a GW2 model file.\n * The data is read using a LocalReader reference into the GW2 .dat.\n *\n * @memberof RenderUtils\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Object} chunk Model GEOM chunk.\n * @param {Object} modelDataChunk Model MODL chunk.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n *\n * @return {Array} Each geometry in the model file represented by a textured THREE.Mesh object\n */\nfunction renderGeomChunk(\n  localReader,\n  chunk,\n  modelDataChunk,\n  sharedTextures,\n  showUnmaterialed\n) {\n  let rawMeshes = chunk.data.meshes;\n  let meshes = [];\n  let mats = modelDataChunk.data.permutations[0].materials;\n\n  rawMeshes.forEach(function(rawMesh) {\n    let rawGeom = rawMesh.geometry;\n    let fvf = rawGeom.verts.mesh.fvf; // rawGeom.fvf;\n\n    let numVerts = rawGeom.verts.vertexCount; // rawGeom.vertexCount;\n\n    let rawVerts = rawGeom.verts.mesh.vertices; // rawGeom.vertices\n\n    let indices = rawGeom.indices.indices;\n\n    let geom = new THREE.BufferGeometry();\n\n    let vertDS = new DataStream(rawVerts.buffer);\n\n    // Dirty step length for now:\n    let stride = rawVerts.length / numVerts;\n\n    // Each vertex\n    // DO UV as well\n    let vertices = new Float32Array(numVerts * 3);\n    // let tangents = null;\n    let normals = null;\n    let uvs = [];\n\n    /// Calculate the distance to the first pair of UV data from the\n    /// start of the vertex entry\n    ///\n    let distToNormals =\n      !!(fvf & fvfFormat.Position) * 12 +\n      !!(fvf & fvfFormat.Weights) * 4 +\n      !!(fvf & fvfFormat.Group) * 4;\n\n    let distToTangent =\n      distToNormals +\n      !!(fvf & fvfFormat.Normal) * 12 +\n      !!(fvf & fvfFormat.Color) * 4;\n\n    let distToBittangent = distToTangent + !!(fvf & fvfFormat.Tangent) * 12;\n\n    let distToTangentFrame =\n      distToBittangent + !!(fvf & fvfFormat.Bitangent) * 12;\n\n    let distToUV = distToTangentFrame + !!(fvf & fvfFormat.TangentFrame) * 12;\n\n    /// Check if the UV is 32 bit float or 16 bit float.\n    let uv32Flag = (fvf & fvfFormat.UV32Mask) >> 8;\n    let uv16Flag = (fvf & fvfFormat.UV16Mask) >> 16;\n    let isUV32 = !!uv32Flag;\n    let hasUV = !!uv16Flag || !!uv32Flag;\n\n    /// Popcount (count the number of binary 1's) in the UV flag\n    /// to get the number of UV pairs used in this vertex format.\n    let masked = isUV32 ? uv32Flag : uv16Flag;\n    let numUV = MathUtils.popcount(masked);\n\n    numUV = Math.min(numUV, 1.0);\n\n    /// Create typed UV arrays\n    if (hasUV) {\n      for (let i = 0; i < numUV; i++) {\n        uvs[i] = new Float32Array(numVerts * 2);\n      }\n    }\n\n    if (fvf & fvfFormat.Normal) {\n      // console.log(\"HAS Normal\");\n    }\n\n    if (fvf & fvfFormat.Tangent) {\n      // console.log(\"HAS Tangent\");\n    }\n\n    if (fvf & fvfFormat.Bitangent) {\n      // console.log(\"HAS Bitangent\");\n    }\n    if (fvf & fvfFormat.TangentFrame) {\n      // console.log(\"HAS TangentFrame\");\n    }\n\n    /// Read data from each vertex data entry\n    for (let i = 0; i < numVerts; i++) {\n      /// Go to vertex memory position\n      vertDS.seek(i * stride);\n\n      /// Read position data\n      /// (we just hope all meshes has 32 bit position...)\n      let x = vertDS.readFloat32();\n      let z = vertDS.readFloat32();\n      let y = vertDS.readFloat32();\n\n      /// Write position data, transformed to Tyria3D coordinate system.\n      vertices[i * 3 + 0] = x; // - c.x;\n      vertices[i * 3 + 1] = -y; // + c.y;\n      vertices[i * 3 + 2] = -z; // + c.z;\n\n      /// Read data at UV position\n      if (hasUV) {\n        for (let uvIdx = 0; uvIdx < numUV; uvIdx++) {\n          vertDS.seek(i * stride + distToUV + uvIdx * (isUV32 ? 8 : 4));\n\n          /// Add one UV pair:\n\n          let u, v;\n          if (isUV32) {\n            u = vertDS.readUint32();\n            v = vertDS.readUint32();\n          } else {\n            u = MathUtils.f16(vertDS.readUint16());\n            v = MathUtils.f16(vertDS.readUint16());\n          }\n\n          /// Push to correct UV array\n          uvs[uvIdx][i * 2 + 0] = u;\n          uvs[uvIdx][i * 2 + 1] = v;\n        }\n      } /// End if has UV\n    } /// End each vertex\n\n    /// Each face descripbed in indices\n    let faces = new Uint16Array(indices.length);\n    for (let i = 0; i < indices.length; i += 3) {\n      // This is ONE face\n      faces[i + 0] = indices[i + 2];\n      faces[i + 1] = indices[i + 1];\n      faces[i + 2] = indices[i + 0];\n    } // End each index aka \"face\"\n\n    /// Add position, index and uv props to buffered geometry\n    geom.addAttribute(\"position\", new THREE.BufferAttribute(vertices, 3));\n    // geom.addAttribute( 'index', new THREE.BufferAttribute( faces, 1) );\n    geom.setIndex(new THREE.BufferAttribute(faces, 1));\n\n    if (normals) {\n      console.log(\"adding normals\");\n      geom.addAttribute(\"normal\", new THREE.BufferAttribute(normals, 3));\n      geom.normalizeNormals();\n      geom.normalsNeedUpdate = true;\n    } else {\n      /// Calculate normals\n      geom.computeVertexNormals();\n    }\n\n    if (hasUV) {\n      for (let uvIdx = 0; uvIdx < numUV; uvIdx++) {\n        /// Names are \"uv\", \"uv2\", \"uv3\", ... , \"uvN\"\n        let uvName = \"uv\" + (uvIdx > 0 ? uvIdx + 1 : \"\");\n\n        /// Set \"custom\" attribute uvN\n        geom.addAttribute(uvName, new THREE.BufferAttribute(uvs[uvIdx], 2));\n\n        /// Flag for update\n        geom.attributes[uvName].needsUpdate = true;\n      }\n\n      /// Not needed anymore?\n      geom.uvsNeedUpdate = true;\n    }\n\n    /// Tell geometry to update its UVs and buffers\n    geom.buffersNeedUpdate = true;\n\n    /// DONE READING VERTEX DATA\n\n    /// Get material used for this mesh\n    let matIdx = rawMesh.materialIndex;\n    let mat = mats[matIdx];\n    let materialFile = null;\n\n    if (mat && matFiles[mat.filename]) {\n      materialFile = matFiles[mat.filename];\n    }\n\n    let finalMaterial = MaterialUtils.getMaterial(\n      mat,\n      materialFile,\n      localReader,\n      sharedTextures\n    );\n\n    /// IF we could not find a material abort OR use a wireframe placeholder.\n    if (!finalMaterial) {\n      if (showUnmaterialed) {\n        finalMaterial = new THREE.MeshLambertMaterial({\n          color: 0x5bb1e8,\n          wireframe: false,\n          side: THREE.DoubleSide\n        });\n      } else {\n        return;\n      }\n    }\n\n    /// Create the final mesh from the BufferedGeometry and MeshBasicMaterial\n    let finalMesh = new THREE.Mesh(geom, finalMaterial);\n\n    /// Set material info on the returned mesh\n    if (mat) {\n      finalMesh.materialFlags = mat.materialFlags;\n      finalMesh.materialFilename = mat.filename;\n    }\n\n    finalMesh.materialName = rawMesh.materialName;\n\n    /// Use materialFilename, materialName, and material.textureFilename in order to build export\n\n    /// Set lod info on the returned mesh\n    finalMesh.numLods = rawMesh.geometry.lods.length;\n    finalMesh.lodOverride = modelDataChunk.data.lodOverride;\n\n    /// Set flag and UV info on the returned mehs\n    finalMesh.flags = rawMesh.flags;\n    finalMesh.numUV = numUV;\n\n    /// Add mesh to returned Array\n    meshes.push(finalMesh);\n  }); /// End rawMeshes forEach\n\n  return meshes;\n}\n\n/**\n * Loads mesh array from Model file and sends as argument to callback.\n *\n * @memberof RenderUtils\n * @async\n * @param  {Number} filename Name of the model file to load data from.\n * @param  {Array} solidColor RGBA array of 4 integers\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n\n * @param  {Function} callback Fired once all meshes have been loaded.\n * two arguments are passed to the callback function.\n *\n * The first argument is an Array with each textured THREE.Mesh objects.\n *\n * The second argument is the bounding spehere of this model file.\n *\n */\n\nfunction loadMeshFromModelFile(\n  filename,\n  solidColor,\n  localReader,\n  sharedTextures,\n  showUnmaterialed,\n  callback\n) {\n  // Short handles prop attributes\n  let finalMeshes = [];\n\n  /// Load file\n  localReader.loadFile(filename, function(inflatedData) {\n    try {\n      if (!inflatedData) {\n        throw \"Could not find MFT entry for \" + filename;\n      }\n\n      let ds = new DataStream(inflatedData);\n\n      let modelFile = new GW2File(ds, 0);\n\n      // MODL for materials -> textures\n      let modelDataChunk = modelFile.getChunk(\"modl\");\n\n      // GEOM for geometry\n      let geometryDataChunk = modelFile.getChunk(\"geom\");\n\n      /// Hacky fix for not being able to adjust for position\n      let boundingSphere = modelDataChunk.data.boundingSphere;\n      let bsc = boundingSphere.center;\n      boundingSphere.radius += Math.sqrt(\n        bsc[0] * bsc[0] + Math.sqrt(bsc[1] * bsc[1] + bsc[2] * bsc[2])\n      );\n\n      /// Load all material files\n      let allMats = modelDataChunk.data.permutations[0].materials;\n\n      //eslint-disable-next-line no-inner-declarations\n      function loadMaterialIndex(mIdx, matCallback) {\n        if (mIdx >= allMats.length) {\n          matCallback();\n          return;\n        }\n\n        let mat = allMats[mIdx];\n\n        /// Skip if file is loaded\n        if (matFiles[mat.filename]) {\n          loadMaterialIndex(mIdx + 1, matCallback);\n          return;\n        }\n\n        localReader.loadFile(mat.filename, function(inflatedData) {\n          if (inflatedData) {\n            let ds = new DataStream(inflatedData);\n            let materialFile = new GW2File(ds, 0);\n            matFiles[mat.filename] = materialFile;\n          }\n\n          loadMaterialIndex(mIdx + 1, matCallback);\n        });\n      }\n\n      loadMaterialIndex(0, function() {\n        /// Create meshes\n        let meshes = renderGeomChunk(\n          localReader,\n          geometryDataChunk,\n          modelDataChunk,\n          sharedTextures,\n          showUnmaterialed\n        );\n\n        // Build mesh group\n        meshes.forEach(function(mesh) {\n          /// Material flags\n          let knownflags = [\n            /*\n\t\t\t\t\t\t\t1-5\n\t\t\t\t\t\t\tHas Tex?\tIDK\t\t\tLight?\t\tAlpha?\n\n\t\t\t\t\t\t\t5-8\n\t\t\t\t\t\t\t0\t\t\t0\t \t\tIDK\t\t \tWater?\n\n\t\t\t\t\t\t\t9-12\n\t\t\t\t\t\t\tHas Tex?\t0\t\t\tAlpha?\t\tAlpha?\n\n\t\t\t\t\t\t\t13\n\t\t\t\t\t\t\tIDK KEV\n\t\t\t    \t\t*/\n\n            0, // 0 0000 0000 0000\t\tGround / Wall splashes\n            8, // 0 0000 0000 1000\t\tBroken Khylo roof DDS\n            9, // 0 0000 0000 1001\t\tTree leaves\n\n            520, // 0 0010 0000 1000\t\tSome LOD modules, fires, smoke, inside of tents (some DSS textures)\n\n            2056, // 0 1000 0000 1000\t\tSolid objects, also broken animations\n\n            /// Solids here are unhappy, or are they? could be animations etc\n            2057, // 0 1000 0000 1001\t\tWindmill sails, bushes, trees, but also a statue and a few pieces of wall\n\n            2060, // 0 1000 0000 1100\t\tA few solid objects, like wooden barricades, one(!) painting\n            2061, // 0 1000 0000 1101\t\tA few bushes, two paintings\n\n            2312, // 0 1001 0000 1000\t\tOpaque Clock tower main walls AND IVY\n            2316, // 0 1001 0000 1100\t\tBushes, inner flower walkway a ramp and a box\n\n            // Number 10\n            2568, // 0 1010 0000 1000\t\tLots of solids; walls, tents also some tent details WITH alpa\n\n            // Number 11\n            2569, // 0 1010 0000 1001\t\tSolids like walls and roofs and appernt non solids like ropes\n\n            2572, // 0 1010 0000 1100\t\tSolid wooden beems, lamp posts\n            2573, // 0 1010 0000 1101\t\tLamp holders, bushes, fences, apparent non solids\n            2584, // 0 1010 0001 1000\t\tFountain Well water\n\n            2824, // 0 1011 0000 1000\t\tWindows, sign arrows, cloth roofs (non solids) BUT straw roofs\n            2828, // 0 1011 0000 1100\t\tA few fence post (non solids)\n            2840, // 0 1011 0001 1000\t\tFountain running water + pipe water\n\n            4617, // 1 0010 0000 1001\t\tFound nothing\n            6664 // 1 1010 0000 1000\t\tTwo groups of solid boxes\n          ];\n\n          // let alphaMask0 = 0x0001 // + 0x0100 + 0x0200;\n          // let alphaMask1 = 0x0010\n          // let alphaMask2 = 0x0100 + 0x0200\n          // let alphaMask2b = 0x0200\n\n          let texMask = 0x8 + 0x0800;\n\n          if (knownflags.indexOf(mesh.materialFlags) !== 11) {\n            // return;\n          }\n\n          // No smoke etc\n          if (mesh.materialFlags === 520) {\n            // return;\n          }\n\n          // Must have texture\n          if (!showUnmaterialed && !(mesh.materialFlags & texMask)) {\n            return;\n          }\n\n          // NO lods\n          if (mesh.flags === 4 || mesh.flags === 1 || mesh.flags === 0) {\n            // return;\n          }\n\n          // Add to final colection\n          finalMeshes.push(mesh);\n        }); /// END FOR EACH meshes\n\n        callback(finalMeshes, boundingSphere);\n      }); /// END LOAD MATERIALS CALLBACK\n    } catch (e) {\n      console.warn(\"Failed rendering model \" + filename, e);\n      let mesh = new THREE.Mesh(\n        new THREE.BoxGeometry(200, 2000, 200),\n        new THREE.MeshNormalMaterial()\n      );\n      mesh.flags = 4;\n      mesh.materialFlags = 2056;\n      mesh.lodOverride = [1000000, 1000000];\n      finalMeshes.push(mesh);\n\n      /// Send the final meshes to callback function\n      callback(finalMeshes);\n    }\n  }); /// END FILE LOADED CALLBACK FUNCTION\n}\n\n/**\n * Gets a mesh array from Model file and sends as argument to callback. Uses a cache of meshes in order\n * to never read the same model file twice.\n *\n * @memberof RenderUtils\n * @async\n * @param  {Number} filename The fileId or baseId of the Model file to load\n * @param  {Array} color RGBA array of 4 integers\n * @param  {LocalReader} localReader The LocalReader object used to read data from the GW2 .dat file.\n * @param {Object} sharedMeshes  Value Object for keeping the texture cache.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n * @param  {Function} callback Fired once all meshes have been loaded.\n * three arguments are passed to the callback function.\n *\n * The first argument is an Array with each textured THREE.Mesh objects.\n *\n * The second argument is a boolean, true indicates that these meshes were not\n * loaded from the dat file, but retrieved from the run time cache.\n *\n * The third argument is the bounding spehere of this model file.\n */\nfunction getMeshesForFilename(\n  filename,\n  color,\n  localReader,\n  sharedMeshes,\n  sharedTextures,\n  showUnmaterialed,\n  callback\n) {\n  /// If this file has already been loaded, just return a reference to the meshes.\n  /// isCached will be set to true to inform the caller the meshes will probably\n  /// have to be cloned in some way.\n  if (sharedMeshes[filename]) {\n    callback(\n      sharedMeshes[filename].meshes,\n      true,\n      sharedMeshes[filename].boundingSphere\n    );\n  }\n\n  /// If this file has never been loaded, load it using loadMeshFromModelFile\n  /// the resulting mesh array will be cached within this model's scope.\n  else {\n    loadMeshFromModelFile(\n      filename,\n      color,\n      localReader,\n      sharedTextures,\n      showUnmaterialed,\n      function(meshes, boundingSphere) {\n        /// Cache result if any.\n        if (meshes) {\n          sharedMeshes[filename] = {\n            meshes: meshes,\n            boundingSphere: boundingSphere\n          };\n        }\n\n        /// Allways fire callback.\n        callback(meshes, false, boundingSphere);\n      }\n    );\n  }\n}\n\n/**\n * WIP, Tries to find all fileIds refered by a model file.\n *\n * @memberof RenderUtils\n * @async\n * @param  {Number}   filename    Model file Id\n * @param  {LocalReader}   localReader LocalReader instance to read from\n * @param  {Function} callback   First argument is list of used file IDs\n */\nfunction getFilesUsedByModel(filename, localReader, callback) {\n  let fileIds = [filename];\n\n  /// Load model file\n  localReader.loadFile(filename, function(inflatedData) {\n    try {\n      if (!inflatedData) {\n        throw \"Could not find MFT entry for \" + filename;\n      }\n\n      let ds = new DataStream(inflatedData);\n      let modelFile = new GW2File(ds, 0);\n\n      // MODL for materials -> textures\n      let modelDataChunk = modelFile.getChunk(\"modl\");\n\n      /// Get materials used by model\n      let mats = modelDataChunk.data.permutations[0].materials;\n\n      /// Add each material file AND referenced TEXTURES\n      mats.forEach(function(mat) {\n        /// Add material file id\n        let matFileName = mat.filename;\n        fileIds.push(matFileName);\n\n        /// Add each texture file id\n        mat.textures.forEach(function(tex) {\n          fileIds.push(tex.filename);\n        });\n      });\n    } catch (e) {\n      console.warn(\"Could not export any data\", e);\n    }\n\n    callback(fileIds);\n  });\n}\n\nmodule.exports = {\n  renderRect: renderRect,\n  loadLocalTexture: loadLocalTexture,\n  renderGeomChunk: renderGeomChunk,\n  loadMeshFromModelFile: loadMeshFromModelFile,\n  getMeshesForFilename: getMeshesForFilename,\n  getFilesUsedByModel: getFilesUsedByModel\n};\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = {\n  /// TODO: port fog from in-engine\n\n  getFragmentShader: function() {\n    return [\n      \"uniform vec2 uvScale;\",\n      \"uniform vec2 offset;\",\n      \"uniform sampler2D texturePicker;\",\n      \"uniform sampler2D texturePicker2;\",\n      \"uniform sampler2D texture1;\",\n      \"uniform sampler2D texture2;\",\n      \"uniform sampler2D texture3;\",\n      \"uniform sampler2D texture4;\",\n\n      THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"],\n\n      \"varying vec2 vUv;\",\n      \"varying vec3 vecNormal;\",\n\n      \"vec3 blend(\",\n      \"vec4 texture1, float a1, vec4 texture2, float a2,\",\n      \"vec4 texture3, float a3, vec4 texture4, float a4)\",\n      \"{\",\n      \"float depth = 2.0;\",\n      \"float alphaMult = 1.0;\",\n      \"float alphaAdd  = 0.0;\",\n      \"a1 *= 4.0;\",\n      \"a2 *= 4.0;\",\n      \"a3 *= 4.0;\",\n      \"a4 *= 4.0;\",\n      \"a1 =  a1+(1.5+texture1.a);\",\n      \"a2 =  a2+(1.5+texture2.a);\",\n      \"a3 =  a3+(1.5+texture3.a);\",\n      \"a4 =  a4+(1.5+texture4.a);\",\n      \"float ma = max(a1,a2);\",\n      \"ma = max(ma,a3);\",\n      \"ma = max(ma,a4);\",\n      \"ma -= depth;\",\n      \"float b1 = max(a1 - ma, 0.0);\",\n      \"float b2 = max(a2 - ma, 0.0);\",\n      \"float b3 = max(a3 - ma, 0.0);\",\n      \"float b4 = max(a4 - ma, 0.0);\",\n      \"return (\",\n      \"texture1.rgb * b1 + texture2.rgb * b2 +\",\n      \"texture3.rgb * b3 + texture4.rgb * b4 \",\n      \") / (b1 + b2 + b3 + b4);\",\n      \"}\",\n\n      \"void main( void ) {\",\n      \"vec2 position = vUv*uvScale;\",\n      \"float edge = 1.0/1024.0;\",\n      \"vec2 compPos = edge + (vUv*0.25 + offset) * (1.0-edge*2.0);\",\n      \"vec4 tp1 = texture2D( texturePicker, compPos);\",\n      \"vec4 tp2 = texture2D( texturePicker2, compPos);\",\n      \"vec4 composite = tp1;\",\n      \"vec4 t1 = texture2D( texture1, position );\",\n      \"vec4 t2 = texture2D( texture2, position );\",\n      \"vec4 t3 = texture2D( texture3, position );\",\n      \"vec4 t4 = texture2D( texture4, position );\",\n      \"vec3 color = blend(\",\n      \"t1, tp1.a,\",\n      \"t2, tp1.b,\",\n      \"t3, tp1.g,\",\n      \"t4, tp1.r\",\n      \");\",\n      \"color *= 0.5+tp2.r;\",\n      \"gl_FragColor = vec4(color,1.0);\",\n      THREE.ShaderChunk[\"logdepthbuf_fragment\"],\n      \"}\"\n    ].join(\"\\n\");\n  },\n  getVertexShader: function() {\n    return [\n      \"varying vec2 vUv;\",\n      \"varying vec3 vecNormal;\",\n      THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"],\n      \"void main()\",\n      \"{\",\n\n      \"vUv =  uv;\",\n      \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n      \"vecNormal = (modelMatrix * vec4(normal, 0.0)).xyz;\",\n      \"gl_Position = projectionMatrix * mvPosition;\",\n      THREE.ShaderChunk[\"logdepthbuf_vertex\"],\n      \"}\"\n    ].join(\"\\n\");\n  }\n};\n"]}