{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/t3d-lib/src/LocalReader/ArchiveParser.js","node_modules/t3d-lib/src/LocalReader/DataReader.js","node_modules/t3d-lib/src/LocalReader/FileTypes.js","node_modules/t3d-lib/src/LocalReader/LocalReader.js","node_modules/t3d-lib/src/LocalReader/PersistantStore.js","node_modules/t3d-lib/src/Logger.js","node_modules/t3d-lib/src/MapFileList.js","node_modules/t3d-lib/src/T3DLib.js","node_modules/t3d-lib/src/dataRenderer/DataRenderer.js","node_modules/t3d-lib/src/dataRenderer/EnvironmentRenderer.js","node_modules/t3d-lib/src/dataRenderer/HavokRenderer.js","node_modules/t3d-lib/src/dataRenderer/PropertiesRenderer.js","node_modules/t3d-lib/src/dataRenderer/SingleModelRenderer.js","node_modules/t3d-lib/src/dataRenderer/StringRenderer.js","node_modules/t3d-lib/src/dataRenderer/TerrainRenderer.js","node_modules/t3d-lib/src/dataRenderer/ZoneRenderer.js","node_modules/t3d-lib/src/format/file/GW2Chunk.js","node_modules/t3d-lib/src/format/file/GW2File.js","node_modules/t3d-lib/src/util/MaterialUtils.js","node_modules/t3d-lib/src/util/MathUtils.js","node_modules/t3d-lib/src/util/ParserUtils.js","node_modules/t3d-lib/src/util/RenderUtils.js","node_modules/t3d-lib/src/util/TerrainShader.js","src/FlyControls.js","src/SceneUtils.js","src/Tyria3DApp.js","src/UI.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","MathUtils","parseANDatHeader","ds","header","version","readUint8","magic","readString","headerSize","readUint32","seek","position","chunkSize","crc","mftOffset","arr32To64","mftSize","flags","T3D","Logger","log","TYPE_DEBUG","TYPE_ERROR","parseMFTTable","nbOfEntries","fullTable","item","readUint16","table","mftIndexOffset","offset","mftIndexSize","size","parseMFTIndex","indexTable","id","mftIndex","getFilePart","file","Promise","resolve","reject","reader","FileReader","onerror","onload","fileEvent","buffer","target","result","DataStream","endianness","LITTLE_ENDIAN","len","readAsArrayBuffer","slice","readArchive","async","archiveHeader","mftData","metaTable","[object Object]","settings","this","_settings","_workerPool","_workerLoad","_inflateCallbacks","workersNb","_startWorker","workerPath","mftId","isImage","capLength","arrayBuffer","byteLength","TYPE_WARNING","push","workerId","_getBestWorkerIndex","postMessage","path","self","worker","Worker","selfWorkerId","onmessage","message_event","data","split","callback","dxtType","imageWidth","imageHeight","indexOf","Math","min","GW2File","FileTypes","getFileType","first4","readCString","type","ArchiveParser","PersistantStore","DataReader","MapFileList","_dataReader","_persistantStore","_file","undefined","_indexTable","_fileMetaTable","noIndexedDB","baseId","raw","fileLength","extractLength","meta","getFileMeta","compressed","inflate","then","catch","oldFileList","persistantId","persistantList","lastListing","getLastListing","name","array","complete","key","iterateList","Object","keys","map","Number","index","taskArray","task","persistantNeedsUpdate","_needsScan","scan","taskId","race","_readFileType","scanResult","fileType","change","floor","TYPE_PROGRESS","putListing","res","all","_persistantData","getFileList","mapArray","reversedIndex","getReverseIndex","maps","filter","getFileIndex","found","category","fileMap","find","fileName","toString","mapEntry","typeList","reverseBaseIdList","fileList","baseIds","baseIdList","reduce","reversed","searchAll","restoreOuput","returnArray","elt","findIndex","sort","j","readFileList","getMapList","returnObj","fileEntry","readFile","loadFile","persistantData","metaData","_fileTypeCache","fileBuffer","DB_VERSION","_dbConnection","_getConnection","request","window","indexedDB","open","onblocked","onupgradeneeded","event","db","currentVersion","oldVersion","createObjectStore","autoIncrement","currentTarget","transaction","objectStore","createIndex","unique","onsuccess","isReady","listing","isComplete","store","put","filename","openCursor","IDBKeyRange","only","cursor","value","primaryKey","TYPE_MESSAGE","logFunctions","Array","arguments","argArr","argsToArr","unshift","severity","max","shift","apply","args","console","error","warn","debug","LocalReader","t3dtoolsWorker","concurrentTasks","navigator","hardwareConcurrency","GW2Chunk","DataRenderer","EnvironmentRenderer","HavokRenderer","PropertiesRenderer","SingleModelRenderer","TerrainRenderer","ZoneRenderer","StringRenderer","MaterialUtils","ParserUtils","RenderUtils","getLocalReader","lrInstance","openArchive","getFileListAsync","localReader","loadFileList","readFileListAsync","getMapListAsync","readMapListAsync","mapList","loadMapList","renderMapContentsAsync","renderers","logger","runAllRenderers","context","parseInt","mapFile","runRenderer","renderClass","assign","bind","cb","renderAsync","getContextValue","clazz","propName","defaultValue","output","hasWebGL","return_context","WebGLRenderingContext","canvas","document","createElement","names","getContext","getParameter","gl","numErrors","global","THREE","checkRequirements","constructor","prototype","getOutput","otherClass","inflatedData","fileId","rawData","uarr","Uint8Array","rawStrings","String","fromCharCode","subarray","rawString","join","loadTextureFile","imageHeigth","image","width","height","getMat","tex","MeshBasicMaterial","side","BackSide","fog","depthWrite","loadTextureWithFallback","targetMatIndices","materialArray","fallbackFilename","hazeColorAsInt","writeMat","mat","forEach","loadFallback","TextureLoader","load","loadLocalTexture","setTimeout","getHazeColor","environmentChunkData","hazes","dataGlobal","haze","farColor","parseLights","lights","ambientLight","hasLight","lighting","backlightIntensity","backlightColor","light","sumDirLightIntensity","dirLightData","color","Color","directionalLight","DirectionalLight","getHex","intensity","set","direction","normalize","lightDir","AmbientLight","ambientTotal","g","b","parseSkybox","parameterChunkData","skyElements","skyModeTex","texPathNE","texPathSW","texPathT","bounds","rect","mapW","abs","x1","x2","mapD","y1","y2","visible","skyGeometry","BoxGeometry","boxSize","faceVertexUvs","vecs","idx","face","vec2","x","y","uvsNeedUpdate","skyBox","Mesh","translateY","create","getChunk","hazeColor","lastP","seed","meshes","renderModels","models","title","MeshNormalMaterial","DoubleSide","parseAllModels","getCollisionsForAnimation","animation","collisions","ret","collisionIndices","collision","round","animationFromGeomIndex","geometryIndex","geometries","animations","havokChunkData","renderMesh","propGeomIndex","l","model","pos","translate","rot","rotate","scale","mesh","parseHavokMesh","rotation","order","seedRandom","sin","clone","geom","Geometry","vertices","v","Vector3","indices","f1","f2","f3","faces","Face3","computeFaceNormals","boundingBox","boundsMax","propModels","zoneModels","obsModels","mdl","renderZoneModelsCB","propertiesChunkData","props","propArray","animProps","propAnimArray","instanceProps","propInstanceArray","metaProps","propMetaArray","concat","meshCache","textureCache","lastPct","renderIndex","pct","pctStr","prop","addMeshToLOD","groups","lod","needsClone","lodDist","lod2","lodOverride","geometry","material","updateMatrix","matrixAutoUpdate","add","group","Group","addLevel","getMeshesForFilename","isCached","boundingSphere","meshArray","LOD","maxDist","boundingSphereRadius","radius","transforms","transform","update","addMeshesToScene","getFileIdsAsync","fileIds","getIdsForProp","getFilesUsedByModel","propFileIds","strings","end","entryHeaderDef","entryIndex","entry","readStruct","decryptionOffset","bitsPerSymbol","readUCS2String","recid","language","TerrainShader","drawWater","wireframe","opacity","transparent","renderRect","parseNumChunks","terrainData","numChunksD_1","sqrt","dims","chunkArray","numChunksD_2","loadPagedImageCallback","infaltedBuffer","terrainTiles","pimgDS","pimgTableDataChunk","pimgData","mapRect","parameterData","maxAnisotropy","anisotropy","xChunks","yChunks","allMaterials","materials","allTextures","texFileArray","dx","dy","cdx","cdy","allMats","customMaterial","MeshLambertMaterial","flatShading","chunkTextures","strippedPages","page","layer","coord","matName","chunkTex","wrapS","RepeatWrapping","wrapT","stepChunk","cx","cy","water","chunkIndex","pageX","pageY","chunkTextureIndices","loResMaterial","texIndexArray","pageOffetX","pageOffetY","fileNames","gi","textureFileName","pageTexName","pageTexName2","near","far","envOutput","uniforms","UniformsUtils","merge","UniformsLib","uvScale","Vector2","texturePicker","texturePicker2","texture1","texture2","texture3","texture4","ShaderMaterial","fragmentShader","getFragmentShader","vertexShader","getVertexShader","chunkGeo","PlaneBufferGeometry","chunkW","cn","getAttribute","heightMapArray","chunk","mS","Matrix4","identity","elements","applyMatrix","SceneUtils","createMultiMaterialObject","PI","globalOffsetX","chunkOffsetX","globalOffsetY","chunkOffsetY","z","px","py","updateMatrixWorld","renderChunk","pagedImageId","pagedImage","terrainChunk","texture","renderZone","zone","zoneDefs","renderZoneCallback","zoneDef","zd","token","defToken","modelGroups","getModelGroups","groupKeys","stepModels","meshGroups","instanceIdx","meshIdx","materialFlags","move","mg","readVerts","verts","Float32Array","readIndices","getIndex","Uint32Array","readUVs","uvs","readNormals","normals","writeVerts","stride","writeIndices","strideIndices","writeUvs","uvStride","writeNormals","normalStride","meshGroup","mergedGeom","BufferGeometry","addAttribute","BufferAttribute","setIndex","buffersNeedUpdate","mapX","mapY","zoneRect","vertRect","encodeData","zdx","linearPos","flag","zoneDefLayer","layerDefArray","modelX","modelY","modelZ","startZ","raycaster","Raycaster","intersections","intersectObject","distance","modelIdx","modelFilename","modelArray","rotRangeX","rotRangeY","rotRangeZ","scaleRange","fadeRange","zoneChunkData","zones","zoneArray","zoneDefArray","stepZone","HEAD_STRUCT","DUPLICATE_SETTINGS","PACKTOCHUNK","pack","root","addr","setting","regex","RegExp","chunkDef","formats","defsIdx","defs","versions","getRootName","pop","match","definition","__root","genDuplicateSettings","headerLength","NaN","loadHead","useNthIndex","fileTypes","defsFound","chunkVersion","def","getDefinition","chunkDataSize","Chunk","noChunks","chunks","readHead","readChunks","ch","loadData","next","toLowerCase","buildVS","numUv","vdefs","adefs","reads","generateDataTexture","DataTexture","RGBAFormat","buildPS","textures","alphaTest","lightMap","t1uv","uvIdx","discard","writeColor","varyings","getUVMat","numUV","attributes","vs","FrontSide","getTexture","texURL","sharedTextures","finalTexture","flipY","mapping","defaultColor","random","minFilter","LinearMipMapLinearFilter","magFilter","LinearFilter","generateMipmaps","format","needsUpdate","getMaterial","materialFile","finalMaterial","dxChunk","grChunk","finalTextures","textureToken","samplerTex","effect","techniques","passes","effects","samplerTextures","samplerIndex","samplerIdx","sampler","samplers","texTokens","textureIndex","uvPSInputIndex","ft","nt","MeshPhongMaterial","normalMap","textureFilename","shading","FlatShading","alphaMask0","alphaMask1","lightMask","base32Max","pow","f16","h","s","Infinity","popcount","bits","arr","sort_unique","arr_in","comparator","hasOwnProperty","getArrayReader","structDef","maxCount","struct","arr_len","arr_ptr","readType","getRefArrayReader","ret_arr","orgPos","offsets","readInt32Array","pointer","getQWordReader","getStringReader","ptr","getString16Reader","stringOffset","num","getPointerReader","getFileNameReader","fileRef","m_highPart","m_lowPart","matFiles","fvfFormat","Position","Weights","Normal","Tangent","Bitangent","TangentFrame","UV32Mask","UV16Mask","Unknown1","Unknown2","Unknown3","Unknown4","PositionCompressed","Unknown5","renderGeomChunk","modelDataChunk","showUnmaterialed","rawMeshes","mats","permutations","rawMesh","rawGeom","fvf","numVerts","vertexCount","rawVerts","vertDS","distToUV","uv32Flag","uv16Flag","isUV32","hasUV","masked","readFloat32","Uint16Array","computeVertexNormals","uvName","matIdx","materialIndex","finalMesh","materialFilename","materialName","numLods","lods","loadMeshFromModelFile","solidColor","finalMeshes","modelFile","geometryDataChunk","bsc","center","loadMaterialIndex","mIdx","matCallback","yPos","dz","cz","plane","overdraw","sharedMeshes","matFileName","ShaderChunk","controls","velocity","moveUp","moveForward","moveBackward","moveLeft","moveRight","canJump","speed","isFly","mapReady","FlyControls","updateURL","getObject","pitch","getPitchObject","yaw","positionURL","$","val","loadZone","loadProp","showHavok","location","hash","param","getControls","setSpeed","toggleFly","setSensitivity","invertMouse","delta","enabled","underwater","object","dirSpeed","getDirection","multiplyScalar","translateX","ray","origin","copy","intersectObjects","getCollisions","translateZ","lock","element","body","requestPointerLock","mozRequestPointerLock","webkitRequestPointerLock","setMapReady","init","exitPointerLock","mozExitPointerLock","webkitExitPointerLock","pointerlockchange","pointerLockElement","mozPointerLockElement","webkitPointerLockElement","controlsEnabled","fadeOut","fadeIn","pointerlockerror","addEventListener","getRenderer","domElement","on","PointerLockControls","getCamera","getScene","keyCode","scene","skyScene","camera","oCamera","currentCamera","skyCamera","cameraOpts","renderer","nonCollisions","terrainChunks","skyObjects","fogDistance","renderCounter","traverseLODs","setupScene","Scene","sceneWidth","innerWidth","PerspectiveCamera","innerHeight","globalAmbient","Fog","WebGLRenderer","sortObjects","stencil","premultipliedAlpha","antialiasing","setSize","autoClear","style","appendChild","resize","render","setPerspective","setOrthographic","fac","aspect","m","OrthographicCamera","setHSLa","setHSL","setRenderVisible","display","applyCameraRotationTo","parent","rx","ry","traverse","clear","getClearColor","elem","remove","updateProjectionMatrix","setAmbientAdd","added","addScalar","setFog","showProgressPanel","pp","is","html","showPanel","showMapPanel","panelIn","currentPanel","swapPanels","panelOut","dir","css","removeClass","animateOutProp","animateInProp","addClass","right","left","animate","getSkyScene","getNonCollisions","getTerrainChunks","getSkyObjects","getLights","UI","Tyria3DApp","stats","controller","hasPointerLock","ui","lastTs","animating","_mapRect","mapAutoLoad","animationTime","ready","onDocumentReady","initAnim","first","margin-top","slideUp","delay","parseUri","hide","Stats","append","loadMap","filePicker","fileIcon","click","trigger","evt","files","applyMapList","deepSearchButton","confirm","searchParagraph","keyDownListener","mouseWheelListener","absolute","getMaxAnisotropy","onMapLoaded","mapData","setClearColor","slider","picker","empty","compareName","each","Event","sign","wheelDelta","timestamp","requestAnimationFrame","toggle","xMin","xMax","yMin","yMax","uri","one","holder","selectMap","mapListObject","logProgress","op","parseFloat","$UI","outputWrapper","top","progressOutput","errorOutput","suspendedPanel","mapOpts","reload","label","blur","movementOpts","step","exp","sens","select"],"mappings":"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","file":"T3DAPP-1.0.6.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst MathUtils = require(\"../util/MathUtils\");\n\n/**\n * @file The ArchiveParser module is a set of helper tools to correctly read the Archive.\n * @namespace ArchiveParser\n */\n\n/**\n *    All in one function to read a GW2.dat file and parse all the needed informations to work with it\n *\n * @memberof ArchiveParser\n * @param {File} file\n * @returns {Promise<{archiveHeader: ArchiveHeader, metaTable: MetaTable, indexTable: IndexTable}>}\n */\nasync function readArchive(file) {\n  let archiveHeader = parseANDatHeader((await getFilePart(file, 0, 40)).ds);\n  let mftData = parseMFTTable(\n    (await getFilePart(file, archiveHeader.mftOffset, archiveHeader.mftSize)).ds\n  );\n  let { ds, len } = await getFilePart(\n    file,\n    mftData.mftIndexOffset,\n    mftData.mftIndexSize\n  );\n  let indexTable = parseMFTIndex(ds, len);\n\n  return {\n    archiveHeader: archiveHeader,\n    metaTable: mftData.table,\n    indexTable: indexTable\n  };\n}\n\n/**\n * The header of the archive.\n * @typedef {Object} ArchiveHeader\n * @property {number} version\n * @property {number} magic\n * @property {number} headerSize\n * @property {number} chunkSize\n * @property {number} crc\n * @property {number} mftOffset\n * @property {number} mftSize\n * @property {number} flags\n */\n\n/**\n *   Parse the main information about the archive like format version, positions of information tables, crc etc...\n *\n * @memberof ArchiveParser\n * @param {DataStream} ds\n * @returns {ArchiveIndex} Returns undefined if the header couldn't be parsed\n */\nfunction parseANDatHeader(ds) {\n  let header = {};\n\n  // Header parsing\n  header.version = ds.readUint8();\n  header.magic = ds.readString(3);\n  header.headerSize = ds.readUint32();\n  ds.seek(ds.position + 4); // Skip uint32\n  header.chunkSize = ds.readUint32();\n  header.crc = ds.readUint32();\n  ds.seek(ds.position + 4); // Skip uint32\n  header.mftOffset = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\n  header.mftSize = ds.readUint32();\n  header.flags = ds.readUint32();\n  // End header parsing\n\n  // Check MAGIC\n  if (header.magic !== \"AN\\u001A\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"ANDat header is not valid\",\n      header.magic\n    );\n    return undefined;\n  }\n\n  T3D.Logger.log(T3D.Logger.TYPE_DEBUG, \"Loaded Main .dat header\");\n\n  return header;\n}\n\n/**\n * The array containing all the meta information concerning the contained files\n * @typedef {Array<{offset: number, size: number, compressed: number, crc: number}>} MetaTable\n */\n\n/**\n *   Parse the main information table that contains the offset, size, compression flags and crc\n *\n * @memberof ArchiveParser\n * @param {Datastream}  ds\n * @returns {{header: {magic: String, nbOfEntries: number}, table: MetaTable, mftIndexOffset: number, mftIndexSize: number}|undefined}\n *   Returns undefined if it couldn't parse the table\n */\nfunction parseMFTTable(ds) {\n  // Parse the table header\n  let header = {};\n  header.magic = ds.readString(4);\n  ds.seek(ds.position + 8); // Skip uint64\n  header.nbOfEntries = ds.readUint32();\n  ds.seek(ds.position + 4 + 4); // Skip uint32 * 2\n\n  // check MAGIC\n  if (header.magic !== \"Mft\\u001A\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"MFTTable header is not valid\",\n      header.magic\n    );\n    return undefined;\n  }\n\n  // Where we put all the parsed data\n  // We don't pre-alloc anymore since not having the data aligned together procs too many\n  // cache misses during a fullscan\n  let fullTable = [];\n\n  // Go through the table\n  for (let i = 1; i < header.nbOfEntries; i++) {\n    let item = {};\n    item[\"offset\"] = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\n    item[\"size\"] = ds.readUint32();\n    item[\"compressed\"] = ds.readUint16();\n    ds.seek(ds.position + 4 + 2); // Skip uint16 + uint32\n    item[\"crc\"] = ds.readUint32();\n    fullTable[i] = item;\n  }\n\n  T3D.Logger.log(T3D.Logger.TYPE_DEBUG, \"Loaded MFTTable\");\n\n  return {\n    header: header,\n    table: fullTable,\n    // Register the MFTIndex table position and size\n    mftIndexOffset: fullTable[2].offset,\n    mftIndexSize: fullTable[2].size\n  };\n}\n\n/**\n * The array linking all the file indexes to their respective files\n * @typedef {Array<number>} IndexTable\n */\n\n/**\n *   This function used to be much more complex with the use of\n *   a \"fileId\" which in the end was just the equivalent of\n *   MFTbaseIds[mftId].sort().reverse()[0] (aka the bigger baseId found)\n *\n * @memberof ArchiveParser\n * @param {DataStream} ds\n * @param {number} size\n * @returns {IndexTable}\n */\nfunction parseMFTIndex(ds, size) {\n  let length = size / 8;\n\n  let indexTable = [];\n\n  for (let i = 0; i < length; i++) {\n    // Parse table\n    let id = ds.readUint32();\n    let mftIndex = ds.readUint32();\n    // Store the values\n    indexTable[id] = mftIndex;\n  }\n\n  T3D.Logger.log(T3D.Logger.TYPE_DEBUG, \"Finished indexing MFT\");\n\n  return indexTable;\n}\n\n/**\n *   Get a chunk of the specified file. Used mainly to take parts of the Archive before parsing.\n *\n * @memberof ArchiveParser\n * @param {File} file\n * @param {number} offset\n * @param {number} length\n * @returns {Promise<{ds: DataStream, len: number}>}\n */\nfunction getFilePart(file, offset, length) {\n  return new Promise((resolve, reject) => {\n    let reader = new FileReader();\n\n    reader.onerror = reject;\n\n    reader.onload = function(fileEvent) {\n      let buffer = fileEvent.target.result;\n      let ds = new DataStream(buffer);\n      ds.endianness = DataStream.LITTLE_ENDIAN;\n      // Pass data stream and data length to callback function\n      resolve({ ds: ds, len: length });\n    };\n\n    // Slicing a File is just reducing the scope of the ArrayBuffer, but doesn't load anything in memory.\n    reader.readAsArrayBuffer(file.slice(offset, offset + length));\n  });\n}\n\nmodule.exports = {\n  readArchive: readArchive,\n  parseANDatHeader: parseANDatHeader,\n  parseMFTTable: parseMFTTable,\n  parseMFTIndex: parseMFTIndex,\n  getFilePart: getFilePart\n};\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Organized thread pool of extractors\n * @class DataReader\n */\nclass DataReader {\n  /**\n   * @constructor\n   * @param {Object} settings\n   * @param {number} settings.workersNb Amount of concurrent spawned workers\n   * @param {string} settings.workerPath Path to the worker script\n   */\n  constructor(settings) {\n    this._settings = settings;\n    this._workerPool = [];\n    this._workerLoad = [];\n    this._inflateCallbacks = [];\n    for (let i = 0; i < settings.workersNb; i++) {\n      this._startWorker(settings.workerPath);\n    }\n  }\n\n  /**\n   * @param {DataStream} ds\n   * @param {number} size\n   * @param {number} mftId\n   * @param {boolean} [isImage] Parses the output as a dxt texture\n   * @param {number} [capLength] Output size\n   * @returns {Promise<{buffer: ArrayBuffer, dxtType: number, imageWidth: number, imageHeight: number}>}\n   */\n  inflate(ds, size, mftId, isImage, capLength) {\n    return new Promise((resolve, reject) => {\n      let arrayBuffer = ds.buffer;\n\n      // If no capLength then inflate the whole file\n      if (!capLength || capLength < 0) {\n        capLength = 0;\n      }\n\n      // Buffer length size check\n      if (arrayBuffer.byteLength < 12) {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_WARNING,\n          `not inflating, length is too short (${arrayBuffer.byteLength})`,\n          mftId\n        );\n        reject(new Error(\"Couldn't inflate \" + mftId + \" (mftId)\"));\n        return;\n      }\n\n      // Register the callback\n      if (this._inflateCallbacks[mftId]) {\n        this._inflateCallbacks[mftId].push({\n          resolve: resolve,\n          reject: reject\n        });\n\n        /// No need to make another call, just wait for callback event to fire.\n        return;\n      } else {\n        this._inflateCallbacks[mftId] = [{ resolve: resolve, reject: reject }];\n      }\n\n      // Add the load to the worker\n      let workerId = this._getBestWorkerIndex();\n      this._workerLoad[workerId] += 1;\n      this._workerPool[workerId].postMessage([\n        mftId,\n        arrayBuffer,\n        isImage === true,\n        capLength\n      ]);\n    });\n  }\n\n  // Initialization function for creating a new worker (thread)\n  _startWorker(path) {\n    let self = this;\n    let worker = new Worker(path);\n    let selfWorkerId = this._workerPool.push(worker) - 1;\n    if (this._workerLoad.push(0) !== selfWorkerId + 1) {\n      throw new Error(\"WorkerLoad and WorkerPool don't have the same length\");\n    }\n\n    worker.onmessage = function(message_event) {\n      let mftId;\n      // Remove load\n      self._workerLoad[selfWorkerId] -= 1;\n\n      // If error\n      if (typeof message_event.data === \"string\") {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_WARNING,\n          \"Inflater threw an error\",\n          message_event.data\n        );\n        mftId = message_event.data.split(\":\")[0];\n        for (let callback of self._inflateCallbacks[mftId]) {\n          callback.reject();\n        }\n      } else {\n        mftId = message_event.data[0];\n        // On success\n        if (self._inflateCallbacks[mftId]) {\n          for (let callback of self._inflateCallbacks[mftId]) {\n            let data = message_event.data;\n            // Array buffer, dxtType, imageWidth, imageHeight\n            callback.resolve({\n              buffer: data[1],\n              dxtType: data[2],\n              imageWidth: data[3],\n              imageHeight: data[4]\n            });\n          }\n          // Remove triggered listeners\n          self._inflateCallbacks[mftId] = null;\n        }\n\n        // Unknown error\n        else {\n          T3D.Logger.log(\n            T3D.Logger.TYPE_ERROR,\n            \"Inflater threw an error\",\n            message_event.data\n          );\n        }\n      }\n    };\n  }\n\n  // Get the worker with the less load\n  _getBestWorkerIndex() {\n    return this._workerLoad.indexOf(Math.min(...this._workerLoad));\n  }\n}\n\nmodule.exports = DataReader;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require(\"../format/file/GW2File.js\");\n\n/**\n * @namespace FileTypes\n */\n\nlet FileTypes = {};\n\n/**\n * Parse the beginning of a file to find its type\n *\n * @memberof FileTypes\n * @param {DataStream} ds\n * @return {number}\n */\nFileTypes.getFileType = function(ds) {\n  let first4 = ds.readCString(4);\n\n  // Parse textures\n  switch (first4) {\n    case \"ATEC\":\n      return \"TEXTURE_ATEC\";\n    case \"ATEP\":\n      return \"TEXTURE_ATEP\";\n    case \"ATET\":\n      return \"TEXTURE_ATET\";\n    case \"ATEU\":\n      return \"TEXTURE_ATEU\";\n    case \"ATEX\":\n      return \"TEXTURE_ATEX\";\n    case \"ATTX\":\n      return \"TEXTURE_ATTX\";\n  }\n\n  if (first4.indexOf(\"DDS\") === 0) return \"TEXTURE_DDS\";\n\n  if (first4.indexOf(\"PNG\") === 1) return \"TEXTURE_PNG\";\n\n  if (first4.indexOf(\"RIFF\") === 0) return \"TEXTURE_RIFF\";\n\n  if (first4.indexOf(\"YUI\") === 0) return \"TEXT_YUI\";\n\n  // PackFiles\n  if (first4.indexOf(\"PF\") === 0) {\n    let file = new GW2File(ds, 0, true); /// true for \"plz no load chunkz\"\n    return \"PF_\" + file.header.type;\n  }\n\n  // Binaries\n  if (first4.indexOf(\"MZ\") === 0) return \"BINARIES\";\n\n  // Strings\n  if (first4.indexOf(\"strs\") === 0) return \"STRINGS\";\n\n  // Raw asnd chunk (without pack file)\n  if (first4.indexOf(\"asnd\") === 0) return \"CHUNK_ASND\";\n\n  // TODO: parse all datastream and if all bytes are valid unicode symbols then\n  // return TEXT_UNKNOWN;\n\n  // Unknown\n  return \"UNKNOWN\";\n};\n\nmodule.exports = FileTypes;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst ArchiveParser = require(\"./ArchiveParser\");\nconst PersistantStore = require(\"./PersistantStore\");\nconst DataReader = require(\"./DataReader\");\nconst MapFileList = require(\"../MapFileList\");\nconst FileTypes = require(\"./FileTypes\");\n\n/**\n * A statefull class that handles reading and inflating data from a local GW2 dat file.\n * LocalReader have been completely rewritten from scratch,\n * the API changed quite a lot between 1.0.4 and 1.1.0.\n *\n * API CHANGES: LocalReader (1.1.0 from 1.0.4)\n * - The constructor have __changed__.\n * - parseHeaderAsync have been __removed__.\n * - connectInflated have been __removed__.\n * - NaClListener have been __removed__.\n * - readANDatHeader have been __removed__.\n * - readMFTHeader have been __removed__.\n * - readMFTIndexFile have been __removed__.\n * - loadFileList is now __deprecated__.\n * - loadMapList is now __deprecated__.\n * - storeFileList have been __removed__.\n * - storeMapList have been __removed__.\n * - readFileListAsync is now __deprecated__.\n * - readMapListAsync is now __deprecated__.\n * - listFiles have been __removed__.\n * - getFileIndex have been slightly __changed__.\n * - loadTextureFile is now __deprecated__.\n * - loadFile have been __removed__.\n * - inflate have been __removed__.\n * - loadFilePart have been __removed__.\n *\n * @param {{workerPath: String, workersNb: number, noIndexedDB: boolean}} settings\n *   * workerPath: the path to the t3dtools worker script file.\n *   * workersNb: amount of threads spawned for decompression.\n *   * noIndexedDB: Do not use indexedDB (persistant storage, default is true)\n */\nclass LocalReader {\n  constructor(settings) {\n    this._settings = settings;\n\n    /**\n     * @private\n     * @type {DataReader}\n     */\n    this._dataReader = new DataReader(settings);\n\n    /**\n     * @private\n     * @type {PersistantStore}\n     */\n    this._persistantStore;\n\n    /**\n     * @private\n     * @type {File}\n     */\n    this._file = undefined;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this._indexTable = [];\n\n    /**\n     * @private\n     * @type {Array<{offset: number, size: number, compressed: number, crc: number}>}\n     */\n    this._fileMetaTable = [];\n\n    if (settings.noIndexedDB !== false) {\n      this._persistantStore = new PersistantStore();\n    }\n  }\n\n  /**\n   *   Asynchronously loads the archive by parsing its file index and header.\n   *\n   * @param {File} file\n   * @returns {Promise}\n   */\n  async openArchive(file) {\n    let { metaTable, indexTable } = await ArchiveParser.readArchive(file);\n    this._fileMetaTable = metaTable;\n    this._indexTable = indexTable;\n    this._file = file;\n  }\n\n  /**\n   *   Gets MFT index by baseId\n   *\n   * @param  {Number} baseId   A base Id\n   * @return {Number}          MFT index\n   */\n  getFileIndex(baseId) {\n    return this._indexTable[baseId];\n  }\n\n  /**\n   *   \"Meta\" informations to deal with files in the archive.\n   * @typedef     {Object}    FileMetaData\n   * @property    {number}    offset\n   * @property    {number}    size\n   * @property    {number}    compressed\n   * @property    {number}    crc\n   */\n\n  /**\n   *   Returns the metadata of a file stored in the archive\n   *\n   * @param {number} mftId Mft index of the file\n   * @returns {FileMetaData} Metadata informations\n   */\n  getFileMeta(mftId) {\n    return this._fileMetaTable[mftId];\n  }\n\n  /**\n   *   Fetch a file and uncompress it if needed / required.\n   *\n   * @param {number} mftId File's archive ID\n   * @param {boolean} [isImage] Try to read the data as a Dxt texture.\n   * @param {boolean} [raw] Force no decompression.\n   * @param {number} [fileLength] Slice the uncompressed file.\n   * @param {number} [extractLength] Slice the decompression.\n   * @returns {Promise<{buffer: ArrayBuffer, dxtType: number|undefined, imageWidth: number|undefined, imageHeight: number|undefined}>}\n   */\n  async readFile(mftId, isImage, raw, fileLength, extractLength) {\n    //let buffer, dxtType, imageWidth, imageHeight;\n    let meta = this.getFileMeta(mftId);\n    if (!meta) throw new Error(\"Unexistant file\");\n\n    // Slice up the data\n    let { ds, len } = await ArchiveParser.getFilePart(\n      this._file,\n      meta.offset,\n      fileLength || meta.size\n    );\n\n    // If needed we decompress, if not we keep raw\n    if (meta.compressed || raw !== false) {\n      let data;\n      await this._dataReader\n        .inflate(ds, len, mftId, isImage, extractLength || 0)\n        .then(result => {\n          data = result;\n        })\n        .catch(() => {\n          data = {\n            buffer: undefined,\n            dxtType: undefined,\n            imageWidth: undefined,\n            imageHeight: undefined\n          };\n        });\n      return data;\n    } else return { buffer: ds.buffer };\n  }\n\n  /**\n   *   Scans asynchronously the types of all the files listed in the archive.\n   *   Uses persistant store to cache and speed up a rescan.\n   *\n   * @param {Array<{baseId: number, size: number, crc: number, fileType: string}>|undefined} oldFileList\n   *   Way for platform not supporting indexDB to provide their own persistant storage.\n   * @returns {Promise<Array<FileItem>>}\n   */\n  async readFileList(oldFileList) {\n    let self = this;\n\n    let persistantList = oldFileList || [];\n    let persistantId;\n\n    // Load previously saved data\n    if (this._persistantStore) {\n      let lastListing = await this._persistantStore.getLastListing(\n        this._file.name\n      );\n      persistantList = lastListing.array;\n      // If the last scan was not completed then we will just update it..\n      if (!lastListing.complete) {\n        persistantId = lastListing.key;\n      }\n    }\n\n    // Create a list of all the baseIds we need to inspect\n    let iterateList = Object.keys(self._indexTable).map(i => Number(i));\n    for (let index in persistantList) {\n      if (!(index in self._indexTable)) iterateList.push(index);\n    }\n\n    // Helps us to know when we need to update the persistant store\n    // let updatePersistant = false;\n\n    // Spawn the decompression tasks\n    let taskArray = [];\n    for (let i = 0; i < 1; i++) {\n      taskArray[i] = Promise.resolve({ task: i });\n    }\n\n    let persistantNeedsUpdate = false;\n\n    // Iterate through the array\n    for (let index in iterateList) {\n      let baseId = iterateList[index];\n\n      // First use a synchronous function to know if we need to scan the file\n      let result = this._needsScan(baseId, persistantList);\n      if (result.scan === true) {\n        let taskId = (await Promise.race(taskArray)).task;\n        taskArray[taskId] = this._readFileType(baseId).then(scanResult => {\n          // Put the result into our persistant storage\n          persistantList[baseId] = {\n            baseId: baseId,\n            size: scanResult.size,\n            crc: scanResult.crc,\n            fileType: scanResult.fileType\n          };\n          return { task: taskId };\n        });\n      }\n      if (result.change === \"removed\") {\n        // Update the persistant storage\n        delete persistantList[baseId];\n      }\n\n      // Handle persistant storage update\n      if (result.change !== \"none\") persistantNeedsUpdate = true;\n\n      // Tasks to do only every %\n      if (index % Math.floor(iterateList.length / 100) === 0) {\n        // Print progress\n        T3D.Logger.log(\n          T3D.Logger.TYPE_PROGRESS,\n          \"Finding types\",\n          index / Math.floor(iterateList.length / 100)\n        );\n\n        // Update the persistant storage if needed\n        if (self._persistantStore && persistantNeedsUpdate) {\n          persistantNeedsUpdate = false;\n          self._persistantStore\n            .putListing(persistantId, persistantList, self._file.name, false)\n            .then(res => (persistantId = res));\n        }\n      }\n    }\n\n    await Promise.all(taskArray).then(() => {\n      // Finally update the listing as complete\n      if (self._persistantStore) {\n        self._persistantStore.putListing(\n          persistantId,\n          persistantList,\n          self._file.name,\n          true\n        );\n      }\n    });\n    this._persistantData = persistantList;\n    return this.getFileList();\n  }\n\n  /**\n   * @typedef {Object} MapItem\n   * @property {string} name\n   * @property {string} category\n   * @property {number} baseId\n   */\n\n  /**\n   *   Returns a list of all the maps with their name and category.\n   *   Uncategorized maps are available only if readFileList have been used before.\n   *\n   * @returns {Array<MapItem>}\n   */\n  getMapList() {\n    let self = this;\n    let mapArray = [];\n    // If the archive have been scanned for all its file we iterate through the results\n    if (this._persistantData) {\n      // Filter the maps out of all our files\n      let reversedIndex = this.getReverseIndex();\n      let maps = this._persistantData\n        .filter(file => file.fileType === \"PF_mapc\")\n        .filter(\n          id => id.baseId === reversedIndex[self.getFileIndex(id.baseId)][0]\n        );\n\n      for (let map of maps) {\n        let found = false;\n        // Try to see if we already have some informations on this map\n        for (let category of MapFileList.maps) {\n          let fileMap = category.maps.find(\n            item => Number(item.fileName.split(\".data\")[0]) === map.baseId\n          );\n          if (fileMap) {\n            mapArray.push({\n              name: fileMap.name,\n              category: category.name,\n              baseId: map.baseId\n            });\n            found = true;\n            break;\n          }\n        }\n        // If not we register it as Uncategorized\n        if (!found) {\n          mapArray.push({\n            name: map.baseId.toString(),\n            category: \"Uncategorized\",\n            baseId: map.baseId\n          });\n        }\n      }\n    }\n    // If not then we check only known maps\n    else {\n      for (let category of MapFileList.maps) {\n        for (let mapEntry of category.maps) {\n          if (Number(mapEntry.fileName.split(\".data\")[0]) in this._indexTable) {\n            mapArray.push({\n              name: mapEntry.name,\n              category: category.name,\n              baseId: Number(mapEntry.fileName.split(\".data\")[0])\n            });\n          }\n        }\n      }\n    }\n    return mapArray;\n  }\n\n  /**\n   * @typedef {Object} FileItem\n   * @property {number} mftId\n   * @property {Array<number>} baseIdList\n   * @property {number} size\n   * @property {number} crc\n   * @property {string} fileType\n   **/\n\n  /**\n   *   Return the meta table with extra information such as an array of baseIds and the file types.\n   *   The filetype is available only if readFileList have been used before of course.\n   *\n   * @returns {Array<FileItem>}\n   */\n  getFileList() {\n    let typeList = this._persistantData\n      ? this._persistantData.map(i => i.fileType)\n      : [];\n    let reverseBaseIdList = this.getReverseIndex();\n\n    let fileList = this._fileMetaTable.map((meta, mftId) => {\n      let baseIds = reverseBaseIdList[mftId] ? reverseBaseIdList[mftId] : [];\n      let type = reverseBaseIdList[mftId]\n        ? typeList[baseIds[0]]\n        : \"Non-Registered\";\n      return {\n        mftId: mftId,\n        baseIdList: baseIds,\n        size: meta.size,\n        crc: meta.crc,\n        fileType: type\n      };\n    });\n    fileList[0] = {\n      mftId: 0,\n      baseIdList: [],\n      size: 0,\n      crc: 0,\n      fileType: \"Non-Registered\"\n    };\n    return fileList;\n  }\n\n  /**\n   * @returns {Array<Array<number>>}\n   */\n  getReverseIndex() {\n    return this._indexTable.reduce((reversed, mftId, baseId) => {\n      if (mftId in reversed) reversed[mftId].push(baseId);\n      else reversed[mftId] = [baseId];\n      return reversed;\n    }, []);\n  }\n\n  // API Compatibility\n\n  /**\n     * Looks up mft indices for all mapc pack files in the dat. Either looks trough all files or\n     * only the list defined in {@link MapFileList}\n     *\n     * @deprecated Use now the getFileList method.\n     * @param  {boolean}   searchAll if true forces re-indexing of entire dat.\n     * If false only reads indices specified in \"T3D/MapFileList\".\n     * @param  {Function} callback Fired when the list is generated\n     *\n     * First argument is the a list of mft indices grouped by file type. For exmample:\n     *\n     * \t\t{\n     * \t\t\tmaps:[\n     * \t\t\t\t{\n     * \t\t\t\t\tname: 'Heart of Maguuma',\n     * \t\t\t\t\tmaps: [\n     * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\n     * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\n     * \t\t\t\t\t]\n     * \t\t\t\t},\n     * \t\t\t\t{\n     * \t\t\t\t\tname: 'Unknown maps',\n     * \t\t\t\t\tmaps: [\n     * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\n     * \t\t\t\t\t]\n     * \t\t\t\t}\n     * \t\t\t]\n\n    *\t    };\n    */\n  readMapListAsync(searchAll, callback) {\n    let self = this;\n    T3D.Logger.log(\n      T3D.Logger.TYPE_WARNING,\n      \"LocalReader.readMapListAsync is deprecated !\"\n    );\n\n    // Let's preserve the old output way\n    function restoreOuput(array) {\n      let returnArray = [];\n      for (let elt of array) {\n        let category = returnArray.findIndex(i => i.name === elt.category);\n        if (category === -1) {\n          category = returnArray.push({ name: elt.category, maps: [] }) - 1;\n        }\n        returnArray[category].maps.push({\n          fileName: elt.baseId,\n          name: elt.name\n        });\n      }\n      // And resort it in order\n      returnArray.sort((i, j) => {\n        if (i.name < j.name) return -1;\n        if (i.name > j.name) return 1;\n        return 0;\n      });\n      return { maps: returnArray };\n    }\n\n    /// If seachAll flag is true, force a deep search\n    if (searchAll) {\n      this.readFileList().then(() => {\n        callback(restoreOuput(self.getMapList()));\n      });\n    } else {\n      callback(restoreOuput(self.getMapList()));\n    }\n  }\n\n  /**\n   * Reads the file type of each file in the dat and stores the resulting list in\n   * the browser's local storage.\n   *\n   * @deprecated Use now the readFileList or getFileList methods.\n   * @param  {Function} callback Fired when the list is generated and stores\n   *\n   * First argument is the a list of mft indices grouped by file type.\n   */\n  readFileListAsync(callback) {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_WARNING,\n      \"LocalReader.readFileListAsync is deprecated !\"\n    );\n\n    // Because the API changed we reform the data as wanted previously\n    this.readFileList().then(result => {\n      let returnObj = {};\n      for (let fileEntry of result) {\n        if (returnObj[fileEntry.fileType] === undefined) {\n          returnObj[fileEntry.fileType] = [];\n        }\n        returnObj[fileEntry.fileType].push(fileEntry.mftId);\n      }\n      callback(returnObj);\n    });\n  }\n\n  /**\n   * Reads data from a file in the dat.\n   *\n   * @deprecated Use now the Promise-based method readFile.\n   * @param  {Number}   baseId   Base or File id of the texture to load\n   * @param  {Function} callback Fires when the inflater has read the data.\n   *\n   * The passed arguments are\n   * -ArrayBuffer raw data\n   * -Number DXT Type if applicable\n   * -Number image width if applicable\n   * -Number image height if applicable\n   *\n   *\n   * @param  {boolean}  isImage\n   * @param  {boolean}   raw      If true, any infation is skipped and raw data is returned.\n   */\n  loadFile(baseId, callback, isImage, raw) {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_WARNING,\n      \"LocalReader.loadFile is deprecated !\"\n    );\n    let mftId = this.getFileIndex(baseId);\n    if (mftId <= 0) return callback(null);\n    this.readFile(mftId, isImage, raw).then(result => {\n      if (result.buffer === undefined) return callback(null);\n      callback(\n        result.buffer,\n        result.dxtType,\n        result.imageWidth,\n        result.imageHeight\n      );\n    });\n  }\n\n  /**\n   * Reads a bitmap from a texture file in the dat.\n   *\n   * @deprecated\n   * @param  {Number}   baseId   Base or File id of the texture to load\n   * @param  {Function} callback Fires when the inflater has read the texture data.\n   *\n   * The passed arguments are\n   * -ArrayBuffer Bitmap\n   * -Number DXT Type\n   * -Number image width\n   * -Number image height\n   *\n   */\n  loadTextureFile(baseId, callback) {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_WARNING,\n      \"LocalReader.loadTextureFile is deprecated !\"\n    );\n\n    this.loadFile(baseId, callback, true);\n  }\n\n  /**\n   * Used to read the cached list of files corresponding to the reader's .dat from the localStorage.\n   * Now kept only for backward compatibility, but doesn't do anything.\n   * Please use getFileList now.\n   *\n   * @deprecated\n   */\n  loadFileList() {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_WARNING,\n      \"LocalReader.loadFileList is deprecated !\"\n    );\n    return undefined;\n  }\n\n  /**\n   * Used to read the cached list of maps corresponding to the reader's .dat from the localStorage.\n   * Now kept only for backward compatibility, but doesn't do anything.\n   * Please use getMapList now.\n   *\n   * @deprecated\n   */\n  loadMapList() {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_WARNING,\n      \"LocalReader.loadMapList is deprecated !\"\n    );\n    return undefined;\n  }\n\n  // Private\n\n  /**\n   * @private\n   * @param {number} baseId\n   * @param {Array<{baseId: number, crc: number, size: number, fileType: string}>} persistantData\n   * @returns {{scan: boolean, change: string }}\n   */\n  _needsScan(baseId, persistantData) {\n    if (baseId <= 0) return { change: \"none\", scan: false };\n\n    let mftId = this.getFileIndex(baseId);\n    let metaData = this.getFileMeta(mftId);\n\n    // Nothing interesting\n    if (metaData === undefined && !(baseId in persistantData)) {\n      return { change: \"none\", scan: false };\n    }\n    // If the file have been deleted\n    else if (metaData === undefined) {\n      return { change: \"removed\", scan: false };\n    }\n    // If the file is new\n    else if (!(baseId in persistantData)) {\n      return { change: \"added\", scan: true };\n    }\n    // If the size or crc don't match\n    else if (\n      metaData.size !== persistantData[baseId].size ||\n      metaData.crc !== persistantData[baseId].crc\n    ) {\n      return { change: \"modified\", scan: true };\n    }\n    // If everything is the same\n    else {\n      return { change: \"none\", scan: false };\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} baseId\n   * @param {Array<{baseId: number, crc: number, size: number, fileType: string}>} persistantData\n   * @returns {Promise<{fileType: string, crc: number, size: number}>}\n   */\n  async _readFileType(baseId) {\n    if (!this._fileTypeCache) this._fileTypeCache = [];\n\n    let mftId = this.getFileIndex(baseId);\n    let metaData = this.getFileMeta(mftId);\n\n    let fileType;\n    if (this._fileTypeCache[baseId] !== undefined) {\n      fileType = this._fileTypeCache[baseId];\n    } else {\n      let fileBuffer = (await this.readFile(\n        mftId,\n        false,\n        false,\n        Math.min(metaData.size, 1000),\n        32\n      )).buffer;\n      if (fileBuffer === undefined) return undefined;\n      fileType = FileTypes.getFileType(new DataStream(fileBuffer));\n    }\n    return { fileType: fileType, crc: metaData.crc, size: metaData.size };\n  }\n}\n\nmodule.exports = LocalReader;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/// Indexed DB versioning\nconst DB_VERSION = 4;\n\n/**\n * This class handles offline storage of the .dat indexes and files metadata\n * @class PersistantStore\n */\nclass PersistantStore {\n  constructor() {\n    // They may be multiple connection request issued at the same time, but it's actually okay since\n    // as soon as they are registered, the not-used ones will get garbage collected\n    this._dbConnection = undefined;\n    this._getConnection(() => {});\n  }\n\n  /**\n   *   Initialize the IndexedDB connection and manages version changes.\n   *\n   * @async\n   * @private\n   * @returns {Promise<IDBDatabase>} Promise to the Database connection\n   */\n  _getConnection() {\n    let self = this;\n    return new Promise((resolve, reject) => {\n      if (self._dbConnection) resolve(self._dbConnection);\n\n      // Let us open our database\n      let request = window.indexedDB.open(\"Tyria3DLibrary\", DB_VERSION);\n\n      /// onblocked is fired when the db needs an upgrade but an older version is opened in another tab\n      request.onblocked = () => {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_ERROR,\n          \"The T3D persistant database cannot be upgraded while the app is opened somewhere else.\"\n        );\n      };\n\n      /// fired when the database needs to be upgraded (or the first time)\n      request.onupgradeneeded = event => {\n        /** @type {IDBDatabase} */\n        let db = event.target.result;\n        let currentVersion = event.oldVersion;\n\n        if (currentVersion < 2) {\n          db.createObjectStore(\"listings\", {\n            autoIncrement: true\n          });\n        }\n\n        if (currentVersion < 3) {\n          let storeListing = event.currentTarget.transaction.objectStore(\n            \"listings\"\n          );\n          storeListing.createIndex(\"filename\", \"filename\", { unique: false });\n        }\n      };\n\n      request.onsuccess = event => {\n        self._dbConnection = event.target.result;\n        self.isReady = true;\n        resolve(self._dbConnection);\n      };\n\n      request.onerror = () => {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_ERROR,\n          \"The T3D persistant database could not be opened.\"\n        );\n        reject();\n      };\n    });\n  }\n\n  /**\n   *   Add or update a listing into the database\n   *\n   * @async\n   * @param {number|undefined} id This ID doesn't really matter, it's just the index of the object in the database, can be undefined\n   * @param {Array} listing\n   * @param {string} fileName .dat file name, allows to have multiple listings for different .dat files.\n   * @param {boolean} isComplete Keep back the information if that was the last update on the current scan or not.\n   * @returns {Promise<number>} On success, the number is the object key in the database\n   */\n  putListing(id, listing, fileName, isComplete) {\n    let self = this;\n    return new Promise((resolve, reject) => {\n      self._getConnection().then(db => {\n        let store = db\n          .transaction([\"listings\"], \"readwrite\")\n          .objectStore(\"listings\");\n\n        let request = id\n          ? store.put(\n              { array: listing, filename: fileName, complete: isComplete },\n              id\n            )\n          : store.put({ array: listing, name: fileName });\n\n        request.onsuccess = () => {\n          resolve(request.result);\n        };\n        request.onerror = () => {\n          reject();\n        };\n      });\n    });\n  }\n\n  /**\n   * Returns the last valid listing in the database\n   *\n   * @async\n   * @param {string} fileName .dat file name, allows to have multiple listings for different .dat files.\n   * @returns {Promise<{array: Array, key: number, complete: boolean}>}\n   *      array: the last listing\n   *      key: the index of the last listing in the database\n   */\n  getLastListing(fileName) {\n    let self = this;\n    return new Promise(resolve => {\n      self._getConnection().then(db => {\n        let listingsStore = db\n          .transaction([\"listings\"], \"readonly\")\n          .objectStore(\"listings\")\n          .index(\"filename\");\n\n        listingsStore.openCursor(\n          IDBKeyRange.only(fileName),\n          \"prev\"\n        ).onsuccess = event => {\n          let cursor = event.target.result;\n          if (!cursor) resolve({ array: [], key: undefined, complete: true });\n          else {\n            resolve({\n              array: cursor.value.array,\n              key: cursor.primaryKey,\n              complete: cursor.value.complete\n            });\n          }\n        };\n      });\n    });\n  }\n}\n\nmodule.exports = PersistantStore;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * A Logger class for T3D\n *\n * This satic class defines severity levels of messages and provides\n * basic logging functionality. Replacing the reference to\n *\n * @namespace\n * @static\n */\nlet Logger = {};\n\n/**\n * @readonly\n * @property {number} TYPE_ERROR\n */\nLogger.TYPE_ERROR = 4;\n\n/**\n * @readonly\n * @property {number} TYPE_WARNING\n */\nLogger.TYPE_WARNING = 3;\n\n/**\n * @readonly\n * @property {number} TYPE_MESSAGE\n */\nLogger.TYPE_MESSAGE = 2;\n\n/**\n * @readonly\n * @property {number} TYPE_PROGRESS\n */\nLogger.TYPE_PROGRESS = 1;\n\n/**\n * @readonly\n * @property {number} TYPE_DEBUG\n */\nLogger.TYPE_DEBUG = 0;\n\n/**\n * The logging functions, indexed by severity/type.\n *\n * @property logFunctions\n * @type Function[]\n */\nLogger.logFunctions = new Array(5);\n\n/**\n * Main logging method. Takes 1 to N arguments. If there are more than 1 arguments\n * the first argument is interpreted as severity. If there is only one argument\n * severity defaults to\n * {{#crossLink \"Logger/TYPE_MESSAGE:property\"}}{{/crossLink}}.\n *\n * The following arguments are passed to a logging function matching the\n * severity.\n *\n\n *\n */\nLogger.log = function() {\n  /// Require at least 1 argument\n  if (arguments.length === 0) {\n    return;\n  }\n\n  /// Parse arguments to an actual array\n  let argArr = Logger.argsToArr(arguments);\n\n  /// Default to message if just one argument was passed\n  if (argArr.length === 1) {\n    argArr.unshift(Logger.TYPE_MESSAGE);\n  }\n\n  /// Otherwise 1st arg is severity, log/warn/error\n  let severity = Math.max(\n    0,\n    Math.min(Logger.logFunctions.length, argArr.shift())\n  );\n  let logFunc = Logger.logFunctions[severity];\n\n  /// Ouput the rest of the arguments\n  logFunc.apply(this, argArr);\n};\n\nLogger.argsToArr = function(args) {\n  let argArr = new Array(args.length);\n  for (let i = 0; i < argArr.length; ++i) {\n    argArr[i] = args[i];\n  }\n  return argArr;\n};\n\nLogger.logFunctions[Logger.TYPE_ERROR] = function() {\n  console.error.apply(console, arguments);\n};\n\nLogger.logFunctions[Logger.TYPE_WARNING] = function() {\n  console.warn.apply(console, arguments);\n};\n\nLogger.logFunctions[Logger.TYPE_MESSAGE] = function() {\n  console.log.apply(console, arguments);\n};\n\nLogger.logFunctions[Logger.TYPE_PROGRESS] = function() {\n  let argArr = Logger.argsToArr(arguments);\n  argArr.unshift(\"Progress: \");\n  console.log.apply(console, argArr);\n};\n\nLogger.logFunctions[Logger.TYPE_DEBUG] = function() {\n  let argArr = Logger.argsToArr(arguments);\n  console.debug.apply(console, argArr);\n};\n\nmodule.exports = Logger;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = {\n  /**\n   * @property maps\n   * @type {Array.<{name: String, maps: Array.<{fileName: String, name: String}>}>}\n   */\n  maps: [\n    {\n      name: \"01. Shiverpeaks\",\n      maps: [\n        { fileName: \"125199.data\", name: \"Wayfarer Foothills (0)\" },\n        { fileName: \"187611.data\", name: \"Wayfarer Foothills (1)\" },\n        { fileName: \"568778.data\", name: \"Cragstead\" },\n        { fileName: \"132434.data\", name: \"Hoelbrak (0)\" },\n        { fileName: \"197122.data\", name: \"Hoelbrak (1)\" },\n        { fileName: \"1966018.data\", name: \"Hoelbrak (2)\" },\n        { fileName: \"124093.data\", name: \"Snowden Drifts (0)\" },\n        { fileName: \"186397.data\", name: \"Snowden Drifts (1)\" },\n        { fileName: \"275155.data\", name: \"Dredgehaunt Cliffs\" },\n        { fileName: \"276252.data\", name: \"Frostgorge Sound\" },\n        { fileName: \"277587.data\", name: \"Lornar's Pass\" },\n        { fileName: \"278717.data\", name: \"Timberline Falls (0)\" },\n        { fileName: \"846866.data\", name: \"Timberline Falls (1)\" },\n        { fileName: \"1018612.data\", name: \"Timberline Falls (2)\" },\n        { fileName: \"295282.data\", name: \"Eye of the North\" }\n      ]\n    },\n    {\n      name: \"02. Ascalon\",\n      maps: [\n        { fileName: \"126118.data\", name: \"Plains of Ashford (0)\" },\n        { fileName: \"188591.data\", name: \"Plains of Ashford (1)\" },\n        { fileName: \"127888.data\", name: \"Diessa Plateau (0)\" },\n        { fileName: \"190490.data\", name: \"Diessa Plateau (1)\" },\n        { fileName: \"131944.data\", name: \"Black Citadel (0)\" },\n        { fileName: \"196585.data\", name: \"Black Citadel (1)\" },\n        { fileName: \"1968107.data\", name: \"Black Citadel (2)\" },\n        { fileName: \"280025.data\", name: \"Blazeridge Steppes\" },\n        { fileName: \"281313.data\", name: \"Fireheart Rise\" },\n        { fileName: \"282668.data\", name: \"Iron Marches\" },\n        { fileName: \"283574.data\", name: \"Fields of Ruin\" }\n      ]\n    },\n    {\n      name: \"03. Kryta\",\n      maps: [\n        { fileName: \"191000.data\", name: \"Lion's Arch (0)\" },\n        { fileName: \"814803.data\", name: \"Lion's Arch (1)\" },\n        { fileName: \"1019669.data\", name: \"Lion's Arch (Legacy)\" },\n        { fileName: \"1796999.data\", name: \"Lion's Arch (2)\" },\n        { fileName: \"1869665.data\", name: \"Lion's Arch (3)\" },\n        { fileName: \"1968576.data\", name: \"Lion's Arch (4)\" },\n        { fileName: \"128151.data\", name: \"Divinity's Reach (0)\" },\n        { fileName: \"191265.data\", name: \"Divinity's Reach (1)\" },\n        { fileName: \"705746.data\", name: \"Divinity's Reach (2)\" },\n        { fileName: \"1968748.data\", name: \"Divinity's Reach (3)\" },\n        { fileName: \"129834.data\", name: \"North of Divinity's Reach (0)\" },\n        { fileName: \"193081.data\", name: \"North of Divinity's Reach (1)\" },\n        { fileName: \"129524.data\", name: \"Queensdale (0)\" },\n        { fileName: \"192711.data\", name: \"Queensdale (1)\" },\n        { fileName: \"130970.data\", name: \"Kessex Hills (0)\" },\n        { fileName: \"194288.data\", name: \"Kessex Hills (1)\" },\n        { fileName: \"672138.data\", name: \"Kessex Hills (2)\" },\n        { fileName: \"861815.data\", name: \"Kessex Hills (3)\" },\n        { fileName: \"286945.data\", name: \"Bloodtide Coast\" },\n        { fileName: \"287870.data\", name: \"Harathi Hinterlands\" },\n        { fileName: \"289176.data\", name: \"Gendarran Fields\" },\n        { fileName: \"295005.data\", name: \"Chantry of Secrets\" },\n        { fileName: \"294938.data\", name: \"Claw Island\" }\n      ]\n    },\n    {\n      name: \"04. Maguuma Jungle\",\n      maps: [\n        { fileName: \"195149.data\", name: \"Caledon Forest\" },\n        { fileName: \"195493.data\", name: \"Metrica Province\" },\n        { fileName: \"922320.data\", name: \"Metrica Province Instance\" },\n        { fileName: \"198076.data\", name: \"The Grove (0)\" },\n        { fileName: \"1969341.data\", name: \"The Grove (1)\" },\n        { fileName: \"198272.data\", name: \"Rata Sum (0)\" },\n        { fileName: \"1968896.data\", name: \"Rata Sum (1)\" },\n        { fileName: \"291064.data\", name: \"Mount Maelstrom\" },\n        { fileName: \"292254.data\", name: \"Sparkfly Fen\" },\n        { fileName: \"293307.data\", name: \"Brisban Wildlands\" }\n      ]\n    },\n    {\n      name: \"05. Ruins of Orr\",\n      maps: [\n        { fileName: \"284829.data\", name: \"Straits of Devastation\" },\n        { fileName: \"285089.data\", name: \"Malchor's Leap\" },\n        { fileName: \"285634.data\", name: \"Cursed Shore\" },\n        { fileName: \"295179.data\", name: \"Cathedral of Hidden Depths\" },\n        { fileName: \"295962.data\", name: \"A Light in the Darkness\" }\n      ]\n    },\n    {\n      name: \"06. Living World S1\",\n      maps: [\n        { fileName: \"520479.data\", name: \"Southsun Cove\" },\n        { fileName: \"679089.data\", name: \"Tower of Nightmares\" }\n      ]\n    },\n    {\n      name: \"07. Living World S2\",\n      maps: [\n        { fileName: \"836211.data\", name: \"Dry top (0)\" },\n        { fileName: \"861770.data\", name: \"Dry top (1)\" },\n        { fileName: \"909361.data\", name: \"The Silverwastes (0)\" },\n        { fileName: \"996202.data\", name: \"The Silverwastes (1)\" },\n        { fileName: \"908730.data\", name: \"Glint's Lair\" }\n      ]\n    },\n    {\n      name: \"08. Heart of Maguuma\",\n      maps: [\n        { fileName: \"969663.data\", name: \"Verdant Brink\" },\n        { fileName: \"1262460.data\", name: \"Hearts and Minds\" },\n        { fileName: \"969964.data\", name: \"Unknown Airship in tree\" },\n        { fileName: \"1262310.data\", name: \"Dragon Stand\" },\n        { fileName: \"1263739.data\", name: \"Tarir\" },\n        { fileName: \"1264291.data\", name: \"Tangled Depths\" }\n      ]\n    },\n    {\n      name: \"09. Living World S3\",\n      maps: [\n        { fileName: \"1472635.data\", name: \"(E1) Bloodstone Fen\" },\n        { fileName: \"1498071.data\", name: \"(E2) Taimi Simulator\" },\n        { fileName: \"1498578.data\", name: \"(E2) Ring of Fire\" },\n        { fileName: \"1605211.data\", name: \"(E3) Bitterfrost Frontier\" },\n        { fileName: \"1645474.data\", name: \"(E4) Caudecus Manor\" },\n        { fileName: \"1646520.data\", name: \"(E4) Lake Doric\" },\n        { fileName: \"1682493.data\", name: \"(E5) Draconis Mons\" },\n        { fileName: \"1682763.data\", name: \"(E5) Titan's Throat\" },\n        { fileName: \"1734839.data\", name: \"(E6) White Mantle Fortress\" },\n        { fileName: \"1735346.data\", name: \"(E6) Siren's Landing\" },\n        { fileName: \"1735440.data\", name: \"(E6) Shining Blade Headquarters\" }\n      ]\n    },\n    {\n      name: \"10. Crystal Desert\",\n      maps: [\n        { fileName: \"1794574.data\", name: \"Crystal Oasis\" },\n        { fileName: \"1833034.data\", name: \"Desert Highlands\" },\n        { fileName: \"1833726.data\", name: \"PoF story instances\" },\n        { fileName: \"1839188.data\", name: \"Domain of Vabbi\" },\n        { fileName: \"1840103.data\", name: \"Elon Riverlands\" },\n        { fileName: \"1840368.data\", name: \"Kormir Sanctuary\" },\n        { fileName: \"1842533.data\", name: \"The Desolation\" }\n      ]\n    },\n    {\n      name: \"11. Living World S4\",\n      maps: [\n        { fileName: \"1901428.data\", name: \"(E1) Fahranur\" },\n        { fileName: \"1902235.data\", name: \"(E1) Istan\" },\n        { fileName: \"1903523.data\", name: \"(E1) Crystal Oasis\" },\n        { fileName: \"1954984.data\", name: \"(E2) Desert Highlands\" },\n        { fileName: \"1955224.data\", name: \"(E2) Inquest Lab Tower\" },\n        { fileName: \"1955471.data\", name: \"(E2) Rata Primus\" },\n        { fileName: \"1955642.data\", name: \"(E2) Divinity's Reach\" },\n        { fileName: \"1955915.data\", name: \"(E2) Mount Maelstrom\" },\n        { fileName: \"1956140.data\", name: \"(E2) Frostgorge Sound\" },\n        { fileName: \"1956245.data\", name: \"(E2) Void\" },\n        { fileName: \"1956299.data\", name: \"(E2) Hided Inquest Lab\" },\n        { fileName: \"1957526.data\", name: \"(E2) Sandswept Isles\" }\n      ]\n    },\n    {\n      name: \"12. Seasonal Activities\",\n      maps: [\n        { fileName: \"506592.data\", name: \"Ascent to Madness\" },\n        { fileName: \"506670.data\", name: \"Mad King's Labyrinth (Past)\" },\n        { fileName: \"662436.data\", name: \"Mad King's Labyrinth (Present)\" },\n        { fileName: \"506739.data\", name: \"Mad King's Clock Tower\" },\n        { fileName: \"622681.data\", name: \"The Crown Pavilion\" },\n        { fileName: \"569756.data\", name: \"SAB Hub (0)\" },\n        { fileName: \"636133.data\", name: \"SAB Hub (1)\" },\n        { fileName: \"635555.data\", name: \"SAB World 1\" },\n        { fileName: \"635960.data\", name: \"SAB World 2\" },\n        { fileName: \"606255.data\", name: \"Zephyr Sanctum\" },\n        { fileName: \"529896.data\", name: \"Tixx's Infinirarium\" },\n        { fileName: \"529945.data\", name: \"Winter Wonderland\" }\n      ]\n    },\n    {\n      name: \"13. Activites\",\n      maps: [\n        { fileName: \"605983.data\", name: \"Sanctum Sprint\" },\n        { fileName: \"606030.data\", name: \"Basket Brawl\" }\n      ]\n    },\n    {\n      name: \"14. Dungeons\",\n      maps: [\n        { fileName: \"126840.data\", name: \"Ascalonian Catacombs (0)\" },\n        { fileName: \"189364.data\", name: \"Ascalonian Catacombs (1)\" },\n        { fileName: \"275474.data\", name: \"Sorrow's Embrace\" },\n        { fileName: \"276520.data\", name: \"Honor of the Waves\" },\n        { fileName: \"284039.data\", name: \"Citadel of Flame\" },\n        { fileName: \"287214.data\", name: \"Caudecus's Manor\" },\n        { fileName: \"291284.data\", name: \"Twilight Arbor (0)\" },\n        { fileName: \"645968.data\", name: \"Twilight Arbor (1)\" },\n        { fileName: \"293606.data\", name: \"Crucible of Eternity\" },\n        { fileName: \"473930.data\", name: \"The Ruined City of Arah\" },\n        { fileName: \"473765.data\", name: \"Arah - Story\" },\n        { fileName: \"580061.data\", name: \"Molten Facility\" },\n        { fileName: \"595722.data\", name: \"Aetherblade Retreat\" }\n      ]\n    },\n    {\n      name: \"15. Fractals\",\n      maps: [\n        { fileName: \"519839.data\", name: \"Fractals of the Mists\" },\n        { fileName: \"697450.data\", name: \"Thaumanova Reactor\" },\n        { fileName: \"1426653.data\", name: \"Cliffside Fractal\" },\n        { fileName: \"1472361.data\", name: \"Chaos Isle Fractal\" },\n        { fileName: \"1472382.data\", name: \"Snowblind Fractal\" },\n        { fileName: \"1472406.data\", name: \"Swampland Fractal\" },\n        { fileName: \"1498016.data\", name: \"Mistlock Observatory\" },\n        { fileName: \"1498798.data\", name: \"Aetherblade/Mai Trin Fractal\" },\n        { fileName: \"1605344.data\", name: \"Nightmare Fractal\" },\n        { fileName: \"1733857.data\", name: \"Shattered Observatory Fractal\" },\n        { fileName: \"1733961.data\", name: \"Mistlock Sanctuary\" },\n        { fileName: \"1905739.data\", name: \"Molten Boss Fractal\" },\n        { fileName: \"1905889.data\", name: \"Twilight Oasis Fractal\" }\n      ]\n    },\n    {\n      name: \"16. Raid\",\n      maps: [\n        { fileName: \"1151420.data\", name: \"(W1) Spirit Vale\" },\n        { fileName: \"1383309.data\", name: \"(W2) Salvation Pass\" },\n        { fileName: \"1427048.data\", name: \"Special Forces Training Area\" },\n        { fileName: \"1454070.data\", name: \"(W3) Stronghold of the Faithful\" },\n        { fileName: \"1645215.data\", name: \"(W4) Bastion of the Penitent\" },\n        { fileName: \"1906329.data\", name: \"(W5) Hall of Chains\" }\n      ]\n    },\n    {\n      name: \"17. Structured PvP\",\n      maps: [\n        { fileName: \"871093.data\", name: \"Original Stronghold\" },\n        { fileName: \"870987.data\", name: \"Battle of Champion's Dusk (0)\" },\n        { fileName: \"1666233.data\", name: \"Battle of Champion's Dusk (1)\" },\n        { fileName: \"132570.data\", name: \"Heart of the Mists (0)\" },\n        { fileName: \"197249.data\", name: \"Heart of the Mists (1)\" },\n        { fileName: \"1734729.data\", name: \"Heart of the Mists (2)\" },\n        { fileName: \"1712986.data\", name: \"Hall of the Mists\" },\n        { fileName: \"132710.data\", name: \"The Battle of Khylo (0)\" },\n        { fileName: \"197402.data\", name: \"The Battle of Khylo (1)\" },\n        { fileName: \"132837.data\", name: \"Forest of Niflhel (0)\" },\n        { fileName: \"197545.data\", name: \"Forest of Niflhel (1)\" },\n        { fileName: \"376916.data\", name: \"Legacy of the Foefire\" },\n        { fileName: \"467374.data\", name: \"Raid on the Capricorn\" },\n        { fileName: \"520609.data\", name: \"Temple of the Silent Storm\" },\n        { fileName: \"579383.data\", name: \"Skyhammer (0)\" },\n        { fileName: \"677968.data\", name: \"Skyhammer (1)\" },\n        { fileName: \"1934470.data\", name: \"Skyhammer (2)\" },\n        { fileName: \"791564.data\", name: \"Courtyard (0)\" },\n        { fileName: \"1713054.data\", name: \"Courtyard (1)\" },\n        { fileName: \"556199.data\", name: \"Spirit Watch (0)\" },\n        { fileName: \"1473061.data\", name: \"Spirit Watch (1)\" },\n        { fileName: \"506539.data\", name: \"Reaper's Rumble\" },\n        { fileName: \"529718.data\", name: \"Snowball Mayhem\" },\n        { fileName: \"595582.data\", name: \"Dragon Ball Arena\" },\n        { fileName: \"617120.data\", name: \"Aspect Arena\" },\n        { fileName: \"1644624.data\", name: \"Revenge of the Capricorn\" },\n        { fileName: \"1704155.data\", name: \"Eternal Coliseum\" }\n      ]\n    },\n    {\n      name: \"18. World vs World\",\n      maps: [\n        { fileName: \"131235.data\", name: \"Eternal Battlegrounds (0)\" },\n        { fileName: \"195806.data\", name: \"Eternal Battlegrounds (1)\" },\n        { fileName: \"1885693.data\", name: \"Eternal Battlegrounds (2)\" },\n        { fileName: \"1918037.data\", name: \"Eternal Battlegrounds (3)\" },\n        { fileName: \"131574.data\", name: \"Alpine Borderlands (0)\" },\n        { fileName: \"641501.data\", name: \"Alpine Borderlands (1)\" },\n        { fileName: \"1799855.data\", name: \"Alpine Borderlands (2)\" },\n        { fileName: \"1647236.data\", name: \"Desert Borderlands (0)\" },\n        { fileName: \"1799442.data\", name: \"Desert Borderlands (1)\" },\n        { fileName: \"736241.data\", name: \"Edge of the Mists\" }\n      ]\n    },\n    {\n      name: \"19. Guild Halls\",\n      maps: [\n        { fileName: \"1255378.data\", name: \"Gilded Hollow\" },\n        { fileName: \"1256064.data\", name: \"Lost Precipice\" },\n        { fileName: \"1843274.data\", name: \"Windswept Haven\" }\n      ]\n    },\n    {\n      name: \"20. Concept and not released\",\n      maps: [\n        { fileName: \"122695.data\", name: \"Empty Plane\" },\n        { fileName: \"184799.data\", name: \"Empty Plane v1\" },\n        { fileName: \"197562.data\", name: \"Empty Plane v2\" },\n        { fileName: \"875614.data\", name: \"Unknown Mists Platforms\" },\n        { fileName: \"132853.data\", name: \"Empty Box\" },\n        { fileName: \"1255516.data\", name: \"Guild Coliseum\" },\n        { fileName: \"1498193.data\", name: \"Concept sPVP Map 1\" },\n        { fileName: \"1513556.data\", name: \"Concept sPVP Map 2\" },\n        { fileName: \"1513607.data\", name: \"Concept sPVP Map 3\" },\n        { fileName: \"1513620.data\", name: \"Concept sPVP Map 4\" },\n        { fileName: \"1513675.data\", name: \"Concept sPVP Map 5\" },\n        { fileName: \"1712945.data\", name: \"Concept sPVP Map 6\" }\n      ]\n    }\n  ]\n};\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* INCLUDES */\nlet LocalReader = require(\"./LocalReader/LocalReader\");\n\n/* PRIVATE VARS */\nlet _version = \"1.1.0\";\nlet _settings = {\n  t3dtoolsWorker: \"modules/t3dtools/t3dworker.js\",\n  concurrentTasks:\n    typeof navigator !== \"undefined\" ? navigator.hardwareConcurrency : 1\n};\n\nlet T3D;\n\n/* PUBLIC PROPERTIES */\n\n/**\n * Tyria 3D Library main module.\n *\n * Use this static class to access file parsers- and data renderer classes.\n *\n * This class also works as a factory for creating\n * LocalReader instances that looks up and inflates files from the Guild Wars 2 .dat.\n * @module T3D\n */\nT3D = module.exports = {\n  /**\n   * The current library version. Used to make sure local storage caches are not\n   * shared between different releases.\n   *\n   * @property version\n   * @type String\n   */\n  version: _version,\n\n  /* FILES */\n\n  /**\n   * A static reference to the GW2File class, the preferred way of\n   * accessing this class.\n   *\n   * @memberof T3D\n   * @property GW2File\n   * @type Class\n   */\n  GW2File: require(\"./format/file/GW2File\"),\n\n  /**\n   * A static reference to the GW2Chunk class, the preferred way of\n   * accessing this class.\n   *\n   * @memberOf T3D\n   * @property GW2Chunk\n   * @type Class\n   */\n  GW2Chunk: require(\"./format/file/GW2Chunk\"),\n\n  /* RENDERERS */\n\n  /**\n   * A static reference to the DataRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property DataRenderer\n   * @type Class\n   */\n  DataRenderer: require(\"./dataRenderer/DataRenderer\"),\n\n  /**\n   * A static reference to the EnvironmentRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property EnvironmentRenderer\n   * @type Class\n   */\n  EnvironmentRenderer: require(\"./dataRenderer/EnvironmentRenderer\"),\n\n  /**\n   * A static reference to the HavokRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property HavokRenderer\n   * @type Class\n   */\n  HavokRenderer: require(\"./dataRenderer/HavokRenderer\"),\n\n  /**\n   * A static reference to the PropertiesRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property PropertiesRenderer\n   * @type Class\n   */\n  PropertiesRenderer: require(\"./dataRenderer/PropertiesRenderer\"),\n\n  /**\n   * A static reference to the SingleModelRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property SingleModelRenderer\n   * @type Class\n   */\n  SingleModelRenderer: require(\"./dataRenderer/SingleModelRenderer\"),\n\n  /**\n   * A static reference to the TerrainRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property TerrainRenderer\n   * @type Class\n   */\n  TerrainRenderer: require(\"./dataRenderer/TerrainRenderer\"),\n\n  /**\n   * A static reference to the ZoneRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property ZoneRenderer\n   * @type Class\n   */\n  ZoneRenderer: require(\"./dataRenderer/ZoneRenderer\"),\n\n  /**\n   * A static reference to the StringRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property StringRenderer\n   * @type Class\n   */\n  StringRenderer: require(\"./dataRenderer/StringRenderer\"),\n\n  /* LOGGING */\n\n  /**\n   * A static reference to the static Logger object, the preferred way of\n   * accessing this object. A simple way of providing your own logging methods\n   * is to simply overwrite any or all of the logging methods specified in\n   * {{#crossLink \"Logger/logFunctions:property\"}}{{/crossLink}}\n   *\n   * @property Logger\n   * @type Object\n   */\n  Logger: require(\"./Logger\"),\n\n  /* SETTINGS */\n\n  /**\n   * Contains a list of known map fileID:s and their names. Used in order to quickly\n   * look up what maps are in a .dat file. Note that this property is hard coded and\n   * has high probablity of being outdated. Also note that the names are just guesses\n   * by RequestTimeout.\n   *\n   * The format of this list objects is\n   *\n   *\n   * \t{\n   *  \tmaps : [\n   *\t  \t\t{\n   *     \t\t\tname:\"World Area Name\",\n   *\t       \t\tmaps:[\n   *\t         \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name One\" },\n   *\t           \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name Two\" },\n   *\t             \t{ fileName :\"[numeric fileId].data\", name:\"Map Name Three\" }\n   *\t              ]\n   *           },\n   *\t         {\n   *\t\t\t    name:\"Another World Area Name\",\n   *\t\t \t   \tmaps:[\n   *\t\t \t\t   \t{ fileName :\"[numeric fileId].data\", name:\"Map Name 408\" }\n   *\t\t\t    ]\n   *\t\t     }\n   * \t\t]\n   *   }\n   *\n   * @readonly\n   * @property MapFileList\n   * @type Object\n   */\n  MapFileList: require(\"./MapFileList\"),\n\n  /* UTILS */\n\n  /**\n   * A static reference to the MaterialUtils class.\n   *\n   * @readonly\n   * @property MaterialUtils\n   * @type Object\n   */\n  MaterialUtils: require(\"./util/MaterialUtils.js\"),\n\n  /**\n   * A static reference to the MathUtils class.\n   *\n   * @readonly\n   * @property MathUtils\n   * @type Object\n   */\n  MathUtils: require(\"./util/MathUtils.js\"),\n\n  /**\n   * A static reference to the ParserUtils class.\n   *\n   * @readonly\n   * @property ParserUtils\n   * @type Object\n   */\n  ParserUtils: require(\"./util/ParserUtils.js\"),\n\n  /**\n   * A static reference to the RenderUtils class.\n   *\n   * @readonly\n   * @property RenderUtils\n   * @type Object\n   */\n  RenderUtils: require(\"./util/RenderUtils.js\"),\n\n  /**\n   * A static reference to the PersistantStore class.\n   *\n   * @readonly\n   * @property PersistantStore\n   * @type Class\n   */\n  PersistantStore: require(\"./LocalReader/PersistantStore\"),\n\n  /**\n   * A static reference to the FileTypes tools and list.\n   *\n   * @readonly\n   * @property FileTypes\n   * @type Object\n   */\n  FileTypes: require(\"./LocalReader/FileTypes\"),\n\n  /* PUBLIC METHODS */\n\n  /**\n   * Creates a new instance of LocalReader with an pNaCl inflater connected to it.\n   *\n   * @async\n   * @param  {File}   \tfile\t\tCore JS File instance, must refer to a GW2 .dat file\n   * @param  {Function}\tcallback\tCallback function, fired when the file index is fully\n   *                             \t\tconstructed. Takes no arguments.\n   *\n   * @param  {String} \tt3dtoolsWorker URL to the inflater file. If omitted\n   *                               \t_settings.t3dtoolsWorker will be used instead.\n   *\n   * @return {LocalReader}\t\t\tThe contructed LocalReader, note that this object\n   *                             \t\twill not be fully initialized until the callback\n   *                             \t\tis fired.\n   */\n  getLocalReader: function(file, callback, t3dtoolsWorker) {\n    let path = t3dtoolsWorker || _settings.t3dtoolsWorker;\n\n    // Create the instance and init the threads\n    let lrInstance = new LocalReader({\n      workerPath: path,\n      workersNb: _settings.concurrentTasks\n    });\n\n    /// Callback with the lrInstance\n    lrInstance.openArchive(file).then(() => {\n      callback(lrInstance);\n    });\n\n    return lrInstance;\n  },\n\n  /**\n   * Utility method for acceccing a list containing information about all files\n   * in the .dat connected to the provided LocalReader instance. This method first\n   * tries to read a local indexing list from the client's localstorage and\n   * fallbacks to generating the list by scanning the MFT indices of the .dat\n   * and peeking each file in order to find out what filetype it has.\n   *\n   * Note that peeking the files is the time consuming task, so if you don't want\n   * yout application to spend time indexing the .dat and have a priori knowledge\n   * about the required file Id's you should not use this method.\n   *\n   * @async\n   * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\n   * @param  {Function}\t\tcallback    Fires when the index has been loaded\n   *                                 \t\tfrom the localstorage or after it has\n   *                                 \t\tbeen built and stored in localstorage.\n   *                                 \t\tTakes the generated object list of\n   *                                 \t\tfiles as an argument. This list groups\n   *                                 \t\tarrays of MFT indices per file type,\n   *                                 \t\tfor exmample:\n   *\n   *\n   * \t{\n   *\t  \t\"Unknown\"\t: [444, 555, 333],\n   *\t  \t\"MODL\"\t\t: [444, 555, 333],\n   * \t  \t\"String\"\t: [666, 777, 888]\n   * \t}\n   *\n   * For more details see\n   * {{#crossLink \"LocalReader/listFiles:method\"}}{{/crossLink}}\n   */\n  getFileListAsync: function(localReader, callback) {\n    /// Check local storage for an existing file list\n    let fileList = localReader.loadFileList();\n\n    /// If there is no cached list, look for pre-defined maps.\n    if (!fileList) {\n      localReader.readFileListAsync(callback);\n    }\n\n    /// Otherwise, just fire the callback with the cached list\n    else {\n      callback(fileList);\n    }\n  },\n\n  /**\n\t * Utility method for acceccing a list containing information about all map files\n\t * in the .dat connected to the provided LocalReader instance. This method first\n\t * tries to read a local indexing list from the client's localstorage and\n\t * fallbacks to generating the list by scanning the MFT indices of the .dat\n\t * and peeking each file in order to find out what filetype it has.\n\t *\n\t * If the searchAll flag is not set to true, this process will only scan files\n\t * from the {{#crossLink \"T3D/MapFileList:property\"}}{{/crossLink}}\n\t *\n\t * @async\n\t * @param {LocalReader}\tlocalReader\tA fully initialized LocalReader instance\n\t * @param {Function}\tcallback\tFires when the index has been loaded\n\t *                                 \tfrom the localstorage or after it has\n\t *                                 \tbeen built and stored in localstorage.\n\t *                                 \tTakes the generated object list of\n\t *                                 \tfiles as an argument. This list groups\n\t *                                 \tarrays of MFT indices per file type,\n\t *                                 \tfor exmample:\n\t *\n\t * \t\t{\n\t * \t\t\tmaps:[\n\t * \t\t\t\t{\n\t * \t\t\t\t\tname: 'Heart of Maguuma',\n\t * \t\t\t\t\tmaps: [\n\t * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\n\t * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\n\t * \t\t\t\t\t]\n\t * \t\t\t\t},\n\t * \t\t\t\t{\n\t * \t\t\t\t\tname: 'Unknown maps',\n\t * \t\t\t\t\tmaps: [\n\t * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\n\t * \t\t\t\t\t]\n\t * \t\t\t\t}\n\t * \t\t\t]\n\n\t*\t    };\n\t* @param {boolean} searchAll if true forces re-indexing of entire dat.\n\t*/\n  getMapListAsync: function(localReader, callback, searchAll) {\n    /// If seachAll flag is true, force a deep search\n    if (searchAll) {\n      localReader.readMapListAsync(true, callback);\n      return;\n    }\n\n    /// Check local storage for an existing map list\n    let mapList = localReader.loadMapList();\n\n    /// If there is no cached list, look for pre-defined maps.\n    if (!mapList) {\n      localReader.readMapListAsync(false, callback);\n    }\n\n    /// Otherwise, just fire the callback with the cached list\n    else {\n      callback(mapList);\n    }\n  },\n\n  /**\n   * Utility method used for rendering map files. Loads a map file and applies\n   * the provided renderers to it.\n   *\n   * @async\n   * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\n   * @param  {Number}   \t\tfileName\tThe File Id of a mapc file.\n   * @param  {Array}   \t\trenderers\tAn array of renderer classes. Each\n   *                               \t\tclass should extend\n   *                               \t\t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\n   * @param  {Function}\t\tcallback    Callback function, takes the shared\n   *                                 \t\trenderer context as an argument.\n   * @param  {Class}\t\t\tlogger      A logger class of the same type as\n   *                               \t\t{{#crossLink \"Logger\"}}{{/crossLink}}\n   */\n  renderMapContentsAsync: function(\n    localReader,\n    fileName,\n    renderers,\n    callback,\n    logger\n  ) {\n    /// VO for storing result from renderers\n    let context = {};\n\n    let runAllRenderers;\n\n    /// Make sure we got an actuall ID number\n    if (parseInt(fileName)) {\n      /// File name is baseId, load using local reader.\n      localReader.loadFile(fileName, function(arrayBuffer) {\n        /// Set up datastream\n        let ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);\n\n        /// Initiate Map file object. Connect callback\n        let mapFile = new T3D.GW2File(ds, 0);\n\n        /// Populate VO by running the renderers\n        runAllRenderers = function(i) {\n          /// Run each renderer\n          if (i < renderers.length) {\n            T3D.runRenderer(\n              renderers[i].renderClass,\n              localReader,\n              Object.assign(renderers[i].settings, { mapFile: mapFile }),\n              context,\n              runAllRenderers.bind(this, i + 1)\n            );\n          }\n\n          /// Fire callback with VO when done\n          else {\n            callback(context);\n          }\n        };\n\n        /// Starting point for running each renderer\n        runAllRenderers(0);\n      });\n    }\n\n    /// Primitive error message...\n    else {\n      let outputLogger = logger || T3D.Logger;\n      outputLogger.log(\n        T3D.Logger.TYPE_ERROR,\n        \"Map id must be an integer!, was:\",\n        fileName\n      );\n    }\n  },\n\n  /**\n   * Utility method for applying a single renderer to a LocalReader insatnce.\n   *\n   * @async\n   *\n   * @param  {Class}\t\trenderClass\tA class extending\n   *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\n   * @param  {LocalReader}localReader A fully initialized LocalReader instance\n   * @param  {Object}\t\tsettings    Settings passed to the renderer. Often\n   *                               \tspecifies thinks like what file ID should\n   *                               \tbe loaded.\n   * @param  {Object}\t\tcontext     The shared renderer context value object.\n   * @param  {Function} \tcb          Callback method passed to the renderAsync\n   *                                 \tmethod of the renderer.\n   */\n  runRenderer: function(renderClass, localReader, settings, context, cb) {\n    let r = new renderClass(localReader, settings, context);\n\n    r.renderAsync(cb);\n  },\n\n  /**\n   * @param  {Object} context      \tA shared renderer context value object.\n   * @param  {Class} \tclazz        \tA class extending\n   *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}.\n   *                                \tSpecifies for renderer class you want to read\n   *                                \toutput.\n   * @param  {String} propName     \tThe name of the property written by the\n   *                                \trenderer that should retrtieved.\n   * @param  {any} \tdefaultValue \tThis value is passed back if no data could\n   *                              \tbe found.\n   * @return {any}    \t\t\t\tThe specified value from the conext if any,\n   *                          \t\totherwise defaultValue.\n   */\n  getContextValue: function(context, clazz, propName, defaultValue) {\n    let output = context[clazz.name];\n    if (output) {\n      return output[propName] ? output[propName] : defaultValue;\n    }\n    return defaultValue;\n  },\n\n  /**\n   * Check if the client web browser can render WebGL 3D content.\n   *\n   * @private\n   * @param  {boolean} return_context flag making this method return the canvas object instead of true\n   * @return {boolean} true if the client is WebGL enabled, false otherwise\n   */\n  hasWebGL: function(return_context) {\n    if (window.WebGLRenderingContext) {\n      let canvas = document.createElement(\"canvas\");\n      let names = [\"webgl\", \"experimental-webgl\", \"moz-webgl\", \"webkit-3d\"];\n      let context = false;\n\n      for (let i = 0; i < 4; i++) {\n        try {\n          context = canvas.getContext(names[i]);\n          if (context && typeof context.getParameter === \"function\") {\n            // WebGL is enabled\n            if (return_context) {\n              // return WebGL object if the function's argument is present\n              return { name: names[i], gl: context };\n            }\n            // else, return just true\n            return true;\n          }\n        } catch (e) {\n          //continue\n        }\n      }\n\n      // WebGL is supported, but disabled\n      return false;\n    }\n\n    // WebGL not supported\n    return false;\n  }\n};\n\n/* PRIVATE METHODS */\n\n/**\n * Performs checks for required browser capabilities and required third party libraries.\n * Loggs any warnings or error messages.\n *\n * @private\n * @return {Number} The ammount of errors and warnings generated.\n */\nfunction checkRequirements() {\n  let numErrors = 0;\n\n  if (!global.window || !window.indexedDB) {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"T3D persistant storing and loading requires indexedDB support.\"\n    );\n    numErrors++;\n  }\n\n  if (typeof DataStream === \"undefined\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"T3D core functionality requires DataStream library.\"\n    );\n    numErrors++;\n  }\n\n  if (typeof THREE === \"undefined\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_WARNING,\n      \"T3D mesh generation requires three.js library.\"\n    );\n    numErrors++;\n  }\n\n  if (numErrors < 1) {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_MESSAGE,\n      \"Tyria 3D API v\" + T3D.version + \" initialized.\"\n    );\n  }\n\n  return numErrors;\n}\n\n/**\n * Performs a quick and dirty check to find what chunk name definitions\n * appear multiple times in th formats array. Note that anything that\n * appears more than 2 times wil get a too hight value due to the\n * algorithm being... incorrect.\n *\n * @private\n * @return {Object} An object mapping duplicate chunk definition names.\n * to the number of apperances.\n */\n// eslint-disable-next-line no-unused-vars\nfunction findDuplicateChunkDefs() {\n  let dups = {};\n  T3D.formats.forEach(function(f1) {\n    T3D.formats.forEach(function(f2) {\n      if (f2.name === f1.name && f2 !== f1) {\n        if (dups[f1.name]) {\n          dups[f1.name]++;\n        } else {\n          dups[f1.name] = 1;\n        }\n      }\n    });\n  });\n  return dups;\n}\n\n/// Library checks requirements on startup\ncheckRequirements();\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require(\"../format/file/GW2File\");\n\n/**\n * Base class for data interpretors a.k.a. 'Renderers'\n *\n * Renderers are classes that collect and interpret data from the dat file.\n *\n * A {{#crossLink \"LocalReader\"}}{{/crossLink}} instance is used for accessing data from the dat.\n *\n * A {{#crossLink \"Logger\"}}{{/crossLink}} is used for posting progress output or error messages.\n *\n * Most Renderers use one or more\n * {{#crossLink \"GW2Chunk\"}}GW2Chunks{{/crossLink}}, typed data structures that can be read from\n * {{#crossLink \"GW2File\"}}GW2Files{{/crossLink}}.\n *\n * The generated data, be it strings, numbers or meshes are put into a value object structure called\n * the 'context'. The context can store data generated by multiple renderers and makes sure each\n * renderer type, or class has it's own value object within the context. This enables one renderer\n * to read data written by another renderer wihtout having to worry about overwriting existing data\n * within the context. Keep in mind that you will have to manually pass and clean the conext object!\n *\n * A clean context object should just be the empty javasript object : {}.\n *\n * When a Renderer is done it will fire the callback and any view interrested in retrieving the generated\n * data from the context can read it using\n * {{#crossLink \"T3D/getContextValue:method\"}}{{/crossLink}}.\n *\n *\n *\n *\n * @class DataRenderer\n * @constructor\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nlet DataRenderer = function(localReader, settings, context, logger) {\n  /// Just storing parameters\n  this.localReader = localReader;\n  this.settings = settings;\n  if (!settings) {\n    settings = {};\n  }\n  this.context = context;\n  this.context[this.constructor.name] = {};\n\n  if (logger) this.logger = logger;\n  else this.logger = T3D.Logger;\n};\n\n/**\n * Gets the output value object for a specified class within the context.\n *\n * @param  {Class} otherClass The class to fetch the output value object for.\n * If not specified the class of this instance will be used.\n * @return {Object}            The output value object for this class within the context.\n */\nDataRenderer.prototype.getOutput = function(otherClass) {\n  return this.context[otherClass ? otherClass.name : this.constructor.name];\n};\n\n/**\n * Basic rendering of unknown files. Output fileds generated:\n *\n * - *fileId* The fileId passed in the settings parameter when constructing this instance.\n *\n * - *rawData* An ArrayBuffer containg the infalted binary data of the loaded file.\n *\n * - *rawString* A string representation of the rawData\n *\n * - *image* A value object witht he fields 'width', 'height' and 'data' describing a RGBA bitmap\n * image. Only set if the loaded file was a texture.\n *\n * - *file* A GW2File representation of the loaded file. Only set if the loaded file was a Pack File.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nDataRenderer.prototype.renderAsync = function(callback) {\n  let self = this;\n\n  this.localReader.loadFile(this.settings.id, function(inflatedData) {\n    /// Set fileId so callers can identify this VO\n    self.getOutput().fileId = self.settings.id;\n\n    /// Share inflated data\n    self.getOutput().rawData = inflatedData;\n\n    /// Construct raw string\n    let uarr = new Uint8Array(inflatedData);\n    let rawStrings = [];\n    let chunksize = 0xffff;\n    let len = Math.min(uarr.length, 10000);\n\n    // There is a maximum stack size. We cannot call String.fromCharCode with as many arguments as we want\n    for (let i = 0; i * chunksize < len; i++) {\n      rawStrings.push(\n        String.fromCharCode.apply(\n          null,\n          uarr.subarray(i * chunksize, (i + 1) * chunksize)\n        )\n      );\n    }\n\n    if (len < uarr.length) {\n      rawStrings.push(\n        \"T3D Ignored the last \" +\n          (uarr.length - len) +\n          \" bytes when generating this raw output\"\n      );\n    }\n\n    self.getOutput().rawString = rawStrings.join();\n\n    /// Check if this is an PF or ATEX file\n    // Binareis are MZ\n    let ds = new DataStream(inflatedData);\n    let first4 = ds.readCString(4);\n\n    /// Do special stuff for different fcc signatures\n    ///\n    /// fourcc != fcc::ATEX && fourcc != fcc::ATEC && fourcc != fcc::ATEP &&\n    /// fourcc != fcc::ATET && fourcc != fcc::ATEU && fourcc != fcc::ATTX)\n    ///\n    if (\n      first4 === \"ATEX\" ||\n      first4 === \"ATEC\" ||\n      first4 === \"ATEP\" ||\n      first4 === \"ATET\" ||\n      first4 === \"ATEU\" ||\n      first4 === \"ATTX\"\n    ) {\n      /// TODO: MOVE TO GW2 texture file!!\n      /// Load file using LocalReader.\n      self.localReader.loadTextureFile(self.settings.id, function(\n        inflatedData,\n        dxtType,\n        imageWidth,\n        imageHeigth\n      ) {\n        /// Create image using returned data.\n        let image = {\n          data: new Uint8Array(inflatedData),\n          width: imageWidth,\n          height: imageHeigth\n        };\n\n        self.getOutput().image = image;\n        callback();\n      });\n    } else if (first4.indexOf(\"PF\") === 0) {\n      self.getOutput().file = new GW2File(ds, 0);\n      callback();\n    } else {\n      self.getOutput().file = null;\n      callback();\n    }\n  });\n};\n\nmodule.exports = DataRenderer;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"../util/RenderUtils\");\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates some of the environment objects of a map.\n *\n * @class EnvironmentRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction EnvironmentRenderer(localReader, settings, context, logger) {\n  DataRenderer.call(this, localReader, settings, context, logger);\n\n  this.mapFile = this.settings.mapFile;\n\n  this.getMat = function(tex) {\n    return new THREE.MeshBasicMaterial({\n      map: tex,\n      side: THREE.BackSide,\n      fog: false,\n      depthWrite: false\n    });\n  };\n\n  this.loadTextureWithFallback = function(\n    targetMatIndices,\n    materialArray,\n    filename,\n    fallbackFilename,\n    hazeColorAsInt\n  ) {\n    let self = this;\n\n    function writeMat(mat) {\n      targetMatIndices.forEach(function(i) {\n        materialArray[i] = mat;\n      });\n    }\n\n    function loadFallback() {\n      let mat = self.getMat(new THREE.TextureLoader().load(fallbackFilename));\n\n      writeMat(mat);\n    }\n\n    function errorCallback() {\n      setTimeout(loadFallback, 1);\n    }\n\n    let mat = self.getMat(\n      RenderUtils.loadLocalTexture(\n        localReader,\n        filename,\n        null,\n        hazeColorAsInt,\n        errorCallback\n      )\n    );\n\n    writeMat(mat);\n  };\n\n  this.getHazeColor = function(environmentChunkData) {\n    let hazes = environmentChunkData && environmentChunkData.dataGlobal.haze;\n\n    if (!hazes || hazes.length <= 0) {\n      return [190, 160, 60];\n    } else {\n      return hazes[0].farColor;\n    }\n  };\n\n  this.parseLights = function(environmentChunkData) {\n    let self = this;\n\n    /// Set up output array\n    self.getOutput().lights = [];\n\n    let lights = environmentChunkData\n      ? environmentChunkData.dataGlobal.lighting\n      : [\n          {\n            lights: [],\n            backlightIntensity: 1.0,\n            backlightColor: [255, 255, 255]\n          }\n        ];\n\n    let ambientLight;\n\n    // var light = lights[0];\n    //\n    let hasLight = false;\n    lights.forEach(function(light /*, idx*/) {\n      if (hasLight) return;\n\n      /// Directional lights\n      // eslint-disable-next-line no-unused-vars\n      let sumDirLightIntensity = 0;\n\n      light.lights.forEach(function(dirLightData /*, idx*/) {\n        hasLight = true;\n\n        let color = new THREE.Color(\n          dirLightData.color[2] / 255.0,\n          dirLightData.color[1] / 255.0,\n          dirLightData.color[0] / 255.0\n        );\n\n        let directionalLight = new THREE.DirectionalLight(\n          color.getHex(),\n          dirLightData.intensity\n        );\n\n        directionalLight.position\n          .set(\n            -dirLightData.direction[0],\n            dirLightData.direction[2],\n            dirLightData.direction[1]\n          )\n          .normalize();\n\n        sumDirLightIntensity += dirLightData.intensity;\n\n        self.getOutput().lights.push(directionalLight);\n      }); // END for each directional light in light\n\n      /// Add some random directional lighting if there was no, in order to se SOME depth on models\n      if (!light.lights || light.lights.length === 0) {\n        let directions = [[0, 1, 0, 0.3], [1, 2, 1, 0.3], [-1, -2, -1, 0.3]];\n\n        directions.forEach(function(lightDir) {\n          let color = new THREE.Color(1, 1, 1);\n          let intensity = lightDir[3];\n          let directionalLight = new THREE.DirectionalLight(\n            color.getHex(),\n            intensity\n          );\n\n          directionalLight.position\n            .set(lightDir[0], lightDir[1], lightDir[2])\n            .normalize();\n\n          sumDirLightIntensity += intensity;\n\n          self.getOutput().lights.push(directionalLight);\n        });\n      }\n\n      /// Ambient light\n      // light.backlightIntensity /= sumDirLightIntensity +light.backlightIntensity;\n      // light.backlightIntensity = light.backlightIntensity;\n      let color = new THREE.Color(\n        (light.backlightIntensity * (255.0 - light.backlightColor[2])) / 255.0,\n        (light.backlightIntensity * (255.0 - light.backlightColor[1])) / 255.0,\n        (light.backlightIntensity * (255.0 - light.backlightColor[0])) / 255.0\n      );\n\n      ambientLight = new THREE.AmbientLight(color);\n    }); // END for each light in lighting\n\n    let ambientTotal = 0;\n    if (ambientLight) {\n      ambientTotal =\n        ambientLight.color.r + ambientLight.color.g + ambientLight.color.b;\n      this.getOutput().lights.push(ambientLight);\n    }\n\n    /// Parsing done, set hasLight flag and return\n    this.getOutput().hasLight = hasLight || ambientTotal > 0;\n  };\n\n  this.parseSkybox = function(\n    environmentChunkData,\n    parameterChunkData,\n    hazeColorAsInt\n  ) {\n    /// set up output array\n    this.getOutput().skyElements = [];\n\n    /// Grab sky texture.\n    /// index 0 and 1 day\n    /// index 2 and 3 evening\n    let skyModeTex =\n      this.environmentChunkData &&\n      this.environmentChunkData.dataGlobal.skyModeTex[0];\n\n    /// Fallback skyboxfrom dat.\n    if (!skyModeTex) {\n      skyModeTex = {\n        texPathNE: 1930687,\n        texPathSW: 193069,\n        texPathT: 193071\n      };\n    }\n\n    /// Calculate bounds\n    let bounds = parameterChunkData.rect;\n    let mapW = Math.abs(bounds.x1 - bounds.x2);\n    let mapD = Math.abs(bounds.y1 - bounds.y2);\n    // eslint-disable-next-line no-unused-vars\n    let boundSide = Math.max(mapW, mapD);\n\n    let materialArray = [];\n\n    /// Load skybox textures, fallback to hosted png files.\n    this.loadTextureWithFallback(\n      [1, 4],\n      materialArray,\n      skyModeTex.texPathNE + 1,\n      \"img/193068.png\",\n      hazeColorAsInt\n    );\n    this.loadTextureWithFallback(\n      [0, 5],\n      materialArray,\n      skyModeTex.texPathSW + 1,\n      \"img/193070.png\",\n      hazeColorAsInt\n    );\n    this.loadTextureWithFallback(\n      [2],\n      materialArray,\n      skyModeTex.texPathT + 1,\n      \"img/193072.png\",\n      hazeColorAsInt\n    );\n    materialArray[3] = new THREE.MeshBasicMaterial({ visible: false });\n\n    /// Create skybox geometry\n    let boxSize = 1024;\n    let skyGeometry = new THREE.BoxGeometry(boxSize, boxSize / 2, boxSize); // Width Height Depth\n\n    /// Ugly way of fixing UV maps for the skybox (I think)\n    skyGeometry.faceVertexUvs[0].forEach(function(vecs, idx) {\n      let face = Math.floor(idx / 2);\n\n      // PX NX\n      // PY NY\n      // PZ NZ\n\n      /// PX - WEST \tNX - EAST\n      if (face === 0 || face === 1) {\n        vecs.forEach(function(vec2) {\n          vec2.x = 1 - vec2.x;\n          vec2.y /= 2.0;\n          vec2.y += 0.5;\n        });\n      }\n\n      /// NZ - SOUTH \tPZ - NORTH\n      else if (face === 5 || face === 4) {\n        vecs.forEach(function(vec2) {\n          vec2.y /= -2.0;\n          vec2.y += 0.5;\n        });\n      } else {\n        vecs.forEach(function(vec2) {\n          vec2.x = 1 - vec2.x;\n        });\n      }\n    });\n\n    skyGeometry.uvsNeedUpdate = true;\n\n    /// Generate final skybox\n    let skyBox = new THREE.Mesh(skyGeometry, materialArray);\n\n    /// Put horizon in camera center\n    skyBox.translateY(boxSize / 4);\n    // skyBox.translateY( -environmentChunk.data.dataGlobal.sky.verticalOffset );\n\n    /// Write to output\n    this.getOutput().skyElements.push(skyBox);\n  };\n}\n\n/// DataRenderer inheritance:\nEnvironmentRenderer.prototype = Object.create(DataRenderer.prototype);\nEnvironmentRenderer.prototype.constructor = EnvironmentRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *hazeColor* Array of RGBA values describing the global haze color of the map.\n * - *lights* An array of THREE.DirectionalLight and  THREE.AmbientLight objects.\n * - *hasLight* Boolean is false if no directional lights were added to \"lights\".\n * - *skyElements* A textured THREE.Mesh skybox.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nEnvironmentRenderer.prototype.renderAsync = function(callback) {\n  let environmentChunkData = this.mapFile.getChunk(\"env\").data;\n  let parameterChunkData = this.mapFile.getChunk(\"parm\").data;\n\n  /// Set renderer clear color from environment haze\n  let hazeColor = this.getHazeColor(environmentChunkData);\n  let hazeColorAsInt =\n    hazeColor[2] * 256 * 256 + hazeColor[1] * 256 + hazeColor[0];\n  this.getOutput().hazeColor = hazeColor;\n\n  /// Add directional lights to output. Also write hasLight flag\n  this.parseLights(environmentChunkData);\n\n  /// Generate skybox\n  this.parseSkybox(environmentChunkData, parameterChunkData, hazeColorAsInt);\n\n  /// All parsing is synchronous, just fire callback\n  callback();\n};\n\nmodule.exports = EnvironmentRenderer;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates meshes describing the collisions of a map.\n *\n * @class HavokRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File. If \"visible\" is specified and true, the generated meshes will be textured\n * with a MeshNormalMaterial, otherwise they will not be visible.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction HavokRenderer(localReader, settings, context, logger) {\n  DataRenderer.call(this, localReader, settings, context, logger);\n\n  this.mapFile = this.settings.mapFile;\n\n  this.lastP = -1;\n  this.seed = 1;\n  this.meshes = [];\n\n  /**\n   * TODO\n   *\n   * @param  {Function} callback         [description]\n   * @async\n   */\n  this.renderModels = function(models, title, callback) {\n    let mat;\n    if (this.settings && this.settings.visible) {\n      mat = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide });\n    } else {\n      mat = new THREE.MeshBasicMaterial({ visible: false });\n    }\n\n    this.parseAllModels(models, mat, title, 200, 0, callback);\n  };\n\n  /**\n   * TODO\n   *\n   * @param  {*} animation  [description]\n   * @param  {*} collisions [description]\n   * @return {*}            [description]\n   */\n  this.getCollisionsForAnimation = function(animation, collisions) {\n    let ret = [];\n\n    for (let i = 0; i < animation.collisionIndices.length; i++) {\n      let index = animation.collisionIndices[i];\n      let collision = collisions[index];\n      collision.index = index;\n      ret.push(collision);\n    }\n\n    return ret;\n  };\n\n  /**\n   * TODO\n   *\n   * @param  {*} models       [description]\n   * @param  {*} mat       [description]\n   * @param  {*} title     [description]\n   * @param  {*} chunkSize [description]\n   * @param  {*} offset    [description]\n   * @return {*} callback          [description]\n   * @async\n   */\n  this.parseAllModels = function(\n    models,\n    mat,\n    title,\n    chunkSize,\n    offset,\n    callback\n  ) {\n    let i = offset;\n\n    for (; i < offset + chunkSize && i < models.length; i++) {\n      let p = Math.round((i * 100) / models.length);\n      if (p !== this.lastP) {\n        this.logger.log(\n          T3D.Logger.TYPE_PROGRESS,\n          \"Loading Collision Models (\" + title + \")\",\n          p\n        );\n        this.lastP = p;\n      }\n\n      /// Get animation object\n      let animation = this.animationFromGeomIndex(\n        models[i].geometryIndex,\n        this.geometries,\n        this.animations\n      );\n\n      let collisions = this.getCollisionsForAnimation(\n        animation,\n        this.havokChunkData.collisions\n      );\n\n      for (let j = 0; j < collisions.length; j++) {\n        let collision = collisions[j];\n        this.renderMesh(collision, models[i], mat);\n      }\n    }\n\n    if (i < models.length) {\n      window.setTimeout(\n        this.parseAllModels.bind(\n          this,\n          models,\n          mat,\n          title,\n          chunkSize,\n          offset + chunkSize,\n          callback\n        ),\n        10 /* time in ms to next call */\n      );\n    } else {\n      callback();\n    }\n  };\n\n  /**\n   * TODO\n   *\n   * @param  {*} propGeomIndex [description]\n   * @param  {*} geometries    [description]\n   * @param  {*} animations    [description]\n   * @return {*}               [description]\n   */\n  this.animationFromGeomIndex = function(\n    propGeomIndex,\n    geometries,\n    animations\n  ) {\n    // geometries is just list of all geometries.animations[end] for now\n    let l = geometries[propGeomIndex].animations.length;\n\n    return animations[geometries[propGeomIndex].animations[l - 1]];\n    // return animations[ geometries[propGeomIndex].animations[0] ];\n  };\n\n  /**\n   * TODO\n   *\n   * @param  {*} collision [description]\n   * @param  {*} model     [description]\n   * @param  {*} mat       [description]\n   * @return {*}           [description]\n   */\n  this.renderMesh = function(collision, model, mat) {\n    let pos = model.translate;\n    let rot = model.rotate;\n    let scale = 32 * model.scale;\n\n    /// Generate mesh\n    let mesh = this.parseHavokMesh(collision, mat);\n\n    /// Position mesh\n    /// \"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"\n    mesh.position.set(pos[0], -pos[2], -pos[1]);\n\n    /// Scale mesh\n    if (scale) mesh.scale.set(scale, scale, scale);\n\n    /// Rotate mesh\n    if (rot) {\n      mesh.rotation.order = \"ZXY\";\n\n      // [\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"],\n      mesh.rotation.set(rot[0], -rot[2], -rot[1]);\n    }\n\n    /// Add mesh to scene and collisions\n    this.getOutput().meshes.push(mesh);\n  };\n\n  /**\n   * TODO\n   *\n   * @return {*} [description]\n   */\n  this.seedRandom = function() {\n    let x = Math.sin(this.seed++) * 10000;\n    return x - Math.floor(x);\n  };\n\n  /**\n   * TODO\n   *\n   * @param  {*} collision [description]\n   * @param  {*} mat       [description]\n   * @return {*}           [description]\n   */\n  this.parseHavokMesh = function(collision, mat) {\n    let index = collision.index;\n\n    if (!this.meshes[index]) {\n      let geom = new THREE.Geometry();\n\n      /// Pass vertices\n      for (let i = 0; i < collision.vertices.length; i++) {\n        let v = collision.vertices[i];\n        // \"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"]\n        geom.vertices.push(new THREE.Vector3(v[0], v[2], -v[1]));\n      }\n\n      /// Pass faces\n      for (let i = 0; i < collision.indices.length; i += 3) {\n        let f1 = collision.indices[i];\n        let f2 = collision.indices[i + 1];\n        let f3 = collision.indices[i + 2];\n\n        if (\n          f1 <= collision.vertices.length &&\n          f2 <= collision.vertices.length &&\n          f3 <= collision.vertices.length\n        ) {\n          geom.faces.push(new THREE.Face3(f1, f2, f3));\n        } else {\n          this.logger.log(\n            T3D.Logger.TYPE_ERROR,\n            \"Errorus index in havok model geometry.\"\n          );\n        }\n      }\n\n      /// Prepare geometry and pass new mesh\n      geom.computeFaceNormals();\n      // geom.computeVertexNormals();\n\n      this.meshes[index] = new THREE.Mesh(geom, mat);\n\n      return this.meshes[index];\n    } else {\n      return this.meshes[index].clone();\n    }\n  };\n}\n\n/// DataRenderer inheritance:\nHavokRenderer.prototype = Object.create(DataRenderer.prototype);\nHavokRenderer.prototype.constructor = HavokRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *boundingBox* Array of values describing the bounding box of all collision.\n * - *meshes* An array of THREE.Mesh objects visualizing all collision in the map.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nHavokRenderer.prototype.renderAsync = function(callback) {\n  let self = this;\n\n  // TODO:The design of this method pretty much requires one instance\n  // of the class per parallel async render. Should probably fix this\n  // at some point...\n\n  /// Get required chunks\n  this.havokChunkData = this.mapFile.getChunk(\"havk\").data;\n\n  /// Set static bounds to the bounds of the havk models\n  this.getOutput().boundingBox = this.havokChunkData.boundsMax;\n\n  /// Clear old meshes\n  this.meshes = [];\n\n  /// Set up output array\n  this.getOutput().meshes = [];\n\n  /// Grab model raw data from the chunk.\n  /// Add missing scale value to obs models.\n  let propModels = this.havokChunkData.propModels;\n  let zoneModels = this.havokChunkData.zoneModels;\n  let obsModels = this.havokChunkData.obsModels;\n  obsModels.forEach(function(mdl) {\n    mdl.scale = 1;\n  });\n\n  /// Store geoms and animations from the file in hte instance so we don't\n  /// have to pass them arround too much. (fix this later)\n  this.geometries = this.havokChunkData.geometries;\n  this.animations = this.havokChunkData.animations;\n\n  /// Render \"prop\", \"zone\" and \"obs\" models in that order.\n  let renderZoneModelsCB = function() {\n    self.renderModels(obsModels, \"obs\", callback);\n  };\n  let renderPropModelsCB = function() {\n    self.renderModels(zoneModels, \"zone\", renderZoneModelsCB);\n  };\n  self.renderModels(propModels, \"prop\", renderPropModelsCB);\n};\n\nmodule.exports = HavokRenderer;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"../util/RenderUtils\");\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates property models for a map.\n *\n * @class PropertiesRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction PropertiesRenderer(localReader, settings, context, logger) {\n  DataRenderer.call(this, localReader, settings, context, logger);\n  this.mapFile = this.settings.mapFile;\n}\n\n/// DataRenderer inheritance:\nPropertiesRenderer.prototype = Object.create(DataRenderer.prototype);\nPropertiesRenderer.prototype.constructor = PropertiesRenderer;\n\n/**\n * Renders all property meshes in a GW2 map described by the map's PROP chunk.\n * Output fileds generated:\n *\n * - *meshes* An array of THREE.Mesh objects visualizing all property models refered by this map.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nPropertiesRenderer.prototype.renderAsync = function(callback) {\n  let self = this;\n\n  self.getOutput().meshes = [];\n\n  let propertiesChunkData = this.mapFile.getChunk(\"prp2\").data;\n\n  if (!propertiesChunkData) {\n    callback();\n    return;\n  }\n\n  let props = propertiesChunkData.propArray;\n  let animProps = propertiesChunkData.propAnimArray;\n  let instanceProps = propertiesChunkData.propInstanceArray;\n  let metaProps = propertiesChunkData.propMetaArray;\n\n  /// Concat all prop types\n  props = props\n    .concat(animProps)\n    .concat(instanceProps)\n    .concat(metaProps);\n\n  /// Create mesh cache\n  self.meshCache = {};\n  self.textureCache = {};\n\n  // For now, we'll do all load in serial\n  // TODO: load unique meshes and textures in parallell (asynch), then render!\n  let lastPct = -1;\n\n  let renderIndex = function(idx) {\n    if (idx >= props.length) {\n      /// Empty mesh cache\n      self.meshCache = {};\n      self.textureCache = {};\n      callback();\n      return;\n    }\n\n    let pct = Math.round((1000.0 * idx) / props.length);\n    pct /= 10.0;\n\n    /// Log progress\n    if (lastPct !== pct) {\n      let pctStr = pct + (pct.toString().indexOf(\".\") < 0 ? \".0\" : \"\");\n\n      self.logger.log(\n        T3D.Logger.TYPE_PROGRESS,\n        \"Loading 3D Models (Props)\",\n        pctStr\n      );\n      lastPct = pct;\n    }\n\n    /// Read prop at index.\n    let prop = props[idx];\n\n    /// Adds a single mesh to a group.\n    let addMeshToLOD = function(mesh, groups, lod, prop, needsClone) {\n      /// Read lod distance before overwriting mesh variable\n      let lodDist = prop.lod2 !== 0 ? prop.lod2 : mesh.lodOverride[1];\n\n      /// Read flags before overwriting mesh variable\n      let flags = mesh.flags;\n\n      /// Mesh flags are 0 1 4\n      /// For now, use flag 0 as the default level of detail\n      if (flags === 0) lodDist = 0;\n\n      /// Create new empty mesh if needed\n      if (needsClone) {\n        mesh = new THREE.Mesh(mesh.geometry, mesh.material);\n      }\n\n      mesh.updateMatrix();\n      mesh.matrixAutoUpdate = false;\n\n      // Find group for this LOD distance\n      if (groups[lodDist]) {\n        groups[lodDist].add(mesh);\n      }\n      // Or create LOD group and add to a level of detail\n      // WIP, needs some testing!\n      else {\n        let group = new THREE.Group();\n        group.updateMatrix();\n        group.matrixAutoUpdate = false;\n        group.add(mesh);\n        groups[lodDist] = group;\n        lod.addLevel(group, lodDist);\n      }\n\n      return lodDist;\n    };\n\n    /// Adds array of meshes to the scene, also adds transform clones\n    let addMeshesToScene = function(meshArray, needsClone, boundingSphere) {\n      /// Add original\n\n      /// Make LOD object and an array of groups for each LOD level\n      let groups = {};\n      let lod = new THREE.LOD();\n\n      /// Each mesh is added to a group corresponding to its LOD distane\n      let maxDist = 0;\n      meshArray.forEach(function(mesh) {\n        maxDist = Math.max(\n          maxDist,\n          addMeshToLOD(mesh, groups, lod, prop, needsClone)\n        );\n      });\n\n      /// Add invisible level (the raycaster crashes on lod without any levels)\n      lod.addLevel(new THREE.Group(), 100000);\n\n      /// Set position, scale and rotation of the LOD object\n      if (prop.rotation) {\n        lod.rotation.order = \"ZXY\";\n        // [\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"],\n        lod.rotation.set(\n          prop.rotation[0],\n          -prop.rotation[2],\n          -prop.rotation[1]\n        );\n      }\n      lod.scale.set(prop.scale, prop.scale, prop.scale);\n      lod.position.set(prop.position[0], -prop.position[2], -prop.position[1]);\n\n      lod.boundingSphereRadius =\n        (boundingSphere && boundingSphere.radius\n          ? boundingSphere.radius\n          : 1.0) * prop.scale;\n\n      lod.updateMatrix();\n      lod.matrixAutoUpdate = false;\n\n      /// Show highest level always\n      // lod.update(lod);\n\n      // Add LOD containing mesh instances to scene\n      self.getOutput().meshes.push(lod);\n\n      // Add one copy per transform, needs to be within it's own LOD\n      if (prop.transforms) {\n        prop.transforms.forEach(function(transform) {\n          /// Make LOD object and an array of groups for each LOD level\n          let groups = {};\n          let lod = new THREE.LOD();\n\n          /// Each mesh is added to a group corresponding to its LOD distane\n          let maxDist = 0;\n          meshArray.forEach(function(mesh) {\n            maxDist = Math.max(\n              maxDist,\n              addMeshToLOD(mesh, groups, lod, prop, true)\n            );\n          });\n\n          /// Add invisible level\n          // lod.addLevel(new THREE.Group(),10000);\n\n          /// Set position, scale and rotation of the LOD object\n          if (transform.rotation) {\n            lod.rotation.order = \"ZXY\";\n            lod.rotation.set(\n              transform.rotation[0],\n              -transform.rotation[2],\n              -transform.rotation[1]\n            );\n          }\n          lod.scale.set(transform.scale, transform.scale, transform.scale);\n          lod.position.set(\n            transform.position[0],\n            -transform.position[2],\n            -transform.position[1]\n          );\n\n          lod.updateMatrix();\n          lod.matrixAutoUpdate = false;\n\n          lod.boundingSphereRadius =\n            (boundingSphere && boundingSphere.radius\n              ? boundingSphere.radius\n              : 1.0) * prop.scale;\n\n          /// Show highest level always\n          lod.update(lod);\n\n          /// Add LOD containing mesh instances to scenerender: function(propertiesChunkHeader, map, localReader, renderCallback){\n          self.getOutput().meshes.push(lod);\n        });\n      }\n    };\n\n    /// Get meshes\n    let showUnmaterialed = false;\n    RenderUtils.getMeshesForFilename(\n      prop.filename,\n      prop.color,\n      self.localReader,\n      self.meshCache,\n      self.textureCache,\n      showUnmaterialed,\n      function(meshes, isCached, boundingSphere) {\n        if (meshes) {\n          addMeshesToScene(meshes, isCached, boundingSphere);\n        }\n\n        /// Render next prop\n        renderIndex(idx + 1);\n      }\n    );\n  };\n\n  /// Start serial loading and redering. (to allow re-using meshes and textures)\n  renderIndex(0);\n};\n\n/**\n * TODO: write description. Used for export feature\n * @param  {Function} callback [description]\n * @return {*}            [description]\n */\nPropertiesRenderer.prototype.getFileIdsAsync = function(callback) {\n  let fileIds = [];\n\n  let propertiesChunkData = this.mapFile.getChunk(\"prp2\").data;\n\n  let props = propertiesChunkData.propArray;\n  let animProps = propertiesChunkData.propAnimArray;\n  let instanceProps = propertiesChunkData.propInstanceArray;\n  let metaProps = propertiesChunkData.propMetaArray;\n\n  props = props\n    .concat(animProps)\n    .concat(instanceProps)\n    .concat(metaProps);\n\n  let getIdsForProp = function(idx) {\n    if (idx >= props.length) {\n      callback(fileIds);\n      return;\n    }\n\n    if (idx % 100 === 0) {\n      this.logger.log(\n        T3D.Logger.TYPE_MESSAGE,\n        \"getting ids for entry\",\n        idx,\n        \"of\",\n        props.length\n      );\n    }\n\n    let prop = props[idx];\n    RenderUtils.getFilesUsedByModel(\n      prop.filename,\n      {\n        /* broken, needs localReader */\n      },\n      function(propFileIds) {\n        fileIds = fileIds.concat(propFileIds);\n        getIdsForProp(idx + 1);\n      }\n    );\n  };\n\n  getIdsForProp(0);\n};\n\nmodule.exports = PropertiesRenderer;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"../util/RenderUtils\");\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates meshes for a single model file.\n *\n * @class SingleModelRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"id\" the base ID or file ID of the model to generate meshes for.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction SingleModelRenderer(localReader, settings, context, logger) {\n  DataRenderer.call(this, localReader, settings, context, logger);\n}\n\n/// DataRenderer inheritance:\nSingleModelRenderer.prototype = Object.create(DataRenderer.prototype);\nSingleModelRenderer.prototype.constructor = SingleModelRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *meshes* An array of THREE.Mesh objects visualizing this model file.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nSingleModelRenderer.prototype.renderAsync = function(callback) {\n  let self = this;\n\n  /// Get file id\n  let fileId = this.settings.id;\n  let showUnmaterialed = true;\n\n  /// Load the model file\n  let meshCache = {};\n  let textureCache = {};\n\n  /// Set up output array\n  self.getOutput().meshes = [];\n\n  RenderUtils.getMeshesForFilename(\n    fileId,\n    0x00ff00,\n    self.localReader,\n    meshCache,\n    textureCache,\n    showUnmaterialed,\n    function(meshes, isCached, boundingSphere) {\n      if (meshes) {\n        meshes.forEach(function(mesh) {\n          mesh.boundingSphere = boundingSphere;\n          self.getOutput().meshes.push(mesh);\n        });\n      }\n\n      /// Fire callback after all meshes have been added.\n      meshCache = {};\n      callback();\n    }\n  );\n};\n\nmodule.exports = SingleModelRenderer;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates a list of readable strings from a \"strs\" file.\n *\n * @class StringRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"id\" the base ID or file ID of the string file to read strings from.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction StringRenderer(localReader, settings, context, logger) {\n  DataRenderer.call(this, localReader, settings, context, logger);\n}\n\n/// DataRenderer inheritance:\nStringRenderer.prototype = Object.create(DataRenderer.prototype);\nStringRenderer.prototype.constructor = StringRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *strings* An array of objects. Each object has a \"recid\"-property specifing on what index within the file\n * a given string was found, and a \"value\"-property specigying the string value.\n *\n * - *language* An integer specifing the language of the loaded file.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nStringRenderer.prototype.renderAsync = function(callback) {\n  let self = this;\n\n  /// Get file id\n  // eslint-disable-next-line no-unused-vars\n  let fileId = this.settings.id;\n  // eslint-disable-next-line no-unused-vars\n  let showUnmaterialed = true;\n\n  /// Load the string file\n\n  /// Set up output array\n  this.getOutput().strings = [];\n\n  this.localReader.loadFile(this.settings.id, function(inflatedData) {\n    let ds = new DataStream(inflatedData);\n    let end = ds.byteLength - 2;\n\n    /// skip past fcc\n    ds.seek(4);\n\n    let entryHeaderDef = [\n      \"size\",\n      \"uint16\",\n      \"decryptionOffset\",\n      \"uint16\",\n      \"bitsPerSymbol\",\n      \"uint16\"\n    ];\n\n    let entryIndex = 0;\n\n    while (end - ds.position > 6) {\n      let entry = ds.readStruct(entryHeaderDef);\n      entry.size -= 6;\n\n      if (entry.size > 0) {\n        let isEncrypted =\n          entry.decryptionOffset !== 0 || entry.bitsPerSymbol !== 0x10;\n\n        /// UTF-16\n        if (!isEncrypted) {\n          let value = ds.readUCS2String(entry.size / 2);\n          self.getOutput().strings.push({\n            value: value,\n            recid: entryIndex\n          });\n        }\n\n        /// Other... ignored\n        else {\n          //continue\n        }\n      }\n\n      entryIndex++;\n    }\n\n    ds.seek(ds.byteLength - 2);\n    self.getOutput().language = ds.readUint16();\n    callback();\n  });\n};\n\nmodule.exports = StringRenderer;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"../util/RenderUtils\");\nconst DataRenderer = require(\"./DataRenderer\");\nconst GW2File = require(\"../format/file/GW2File.js\");\n\nconst TerrainShader = require(\"../util/TerrainShader.js\");\n\n/**\n *\n * A renderer that generates the meshes for the terrain of a map.\n *\n *\n * Requires a context previously populated by a\n * {{#crossLink \"EnvironmentRenderer\"}}{{/crossLink}}.\n *\n * @class TerrainRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction TerrainRenderer(localReader, mapFile, settings, context, logger) {\n  DataRenderer.call(this, localReader, mapFile, settings, context, logger);\n  this.mapFile = this.settings.mapFile;\n\n  this.drawWater = function(rect) {\n    /// Add Water\n    let material =\n      material ||\n      new THREE.MeshBasicMaterial({\n        color: 0x5bb1e8,\n        wireframe: false,\n        opacity: 0.35\n      });\n\n    material.transparent = true;\n    return RenderUtils.renderRect(rect, 0, material);\n  };\n\n  this.parseNumChunks = function(terrainData) {\n    terrainData.numChunksD_1 = Math.sqrt(\n      (terrainData.dims[0] * terrainData.chunkArray.length) /\n        terrainData.dims[1]\n    );\n    terrainData.numChunksD_2 =\n      terrainData.chunkArray.length / terrainData.numChunksD_1;\n  };\n\n  this.loadPagedImageCallback = function(callback, infaltedBuffer) {\n    let self = this;\n\n    // Prep output array\n    self.getOutput().terrainTiles = [];\n\n    let pimgDS = new DataStream(infaltedBuffer);\n    let pimgFile = new GW2File(pimgDS, 0);\n    let pimgTableDataChunk = pimgFile.getChunk(\"pgtb\");\n    let pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\n\n    this.mapRect = null;\n\n    /// Fetch chunks\n    let terrainData = this.mapFile.getChunk(\"trn\").data;\n    let parameterData = this.mapFile.getChunk(\"parm\").data;\n\n    /// Read settings\n    let maxAnisotropy = this.settings.anisotropy ? this.settings.anisotropy : 1;\n\n    //let chunks = [];\n    let chunkW = 35;\n\n    /// Calculate numChunksD_1 and _2\n    this.parseNumChunks(terrainData);\n\n    let xChunks = terrainData.numChunksD_1;\n    let yChunks = terrainData.numChunksD_2;\n\n    let allMaterials = terrainData.materials.materials;\n    let allTextures = terrainData.materials.texFileArray;\n\n    // Total map dx and dy\n    /*\n\t\told parameter data definition:\n\t\t\"x1\", \"float32\",\n\t\t\"y1\", \"float32\",\n\t\t\"x2\", \"float32\",\n\t\t\"y2\", \"float32\"\n\t\t*/\n    // var dx = parameterData.rect.x2 - parameterData.rect.x1;\n    // var dy = parameterData.rect.y2 - parameterData.rect.y1;\n    let dx = parameterData.rect[2] - parameterData.rect[0];\n    let dy = parameterData.rect[3] - parameterData.rect[1];\n\n    // Each chunk dx and dy\n    let cdx = (dx / terrainData.numChunksD_1) * 1; //  35/33;\n    let cdy = (dy / terrainData.numChunksD_2) * 1; // 35/33;\n    let n = 0;\n    let allMats = [];\n    let customMaterial = new THREE.MeshLambertMaterial({\n      side: THREE.DoubleSide,\n      color: 0x666666,\n      flatShading: true\n    });\n    //let texMats = {};\n\n    /// Load textures from PIMG and inject as material maps (textures)\n    let chunkTextures = {};\n\n    /// Load textures\n    if (pimgData) {\n      let strippedPages = pimgData.strippedPages;\n\n      /// Only use layer 0\n      strippedPages.forEach(function(page) {\n        /// Only load layer 0 and 1\n        if (page.layer <= 1) {\n          let filename = page.filename;\n          //let color = page.solidColor;\n          let coord = page.coord;\n\n          let matName = coord[0] + \",\" + coord[1];\n          if (page.layer === 1) matName += \"-2\";\n\n          /// Add texture to list, note that coord name is used, not actual file name\n          if (!chunkTextures[matName]) {\n            /// Load local texture, here we use file name!\n            let chunkTex = RenderUtils.loadLocalTexture(\n              self.localReader,\n              filename\n            );\n\n            if (chunkTex) {\n              /// Set repeat, antistropy and repeat Y\n              chunkTex.anisotropy = maxAnisotropy;\n              chunkTex.wrapS = THREE.RepeatWrapping;\n              chunkTex.wrapT = THREE.RepeatWrapping;\n            }\n\n            /// ...But store in coord name\n            chunkTextures[matName] = chunkTex;\n          }\n        }\n      }); /// end for each stripped page in pimgData\n    }\n\n    /// Render Each chunk\n    /// We'll make this async in order for the screen to be able to update\n\n    let renderChunk = function(cx, cy) {\n      let chunkIndex = cy * xChunks + cx;\n\n      let pageX = Math.floor(cx / 4);\n      let pageY = Math.floor(cy / 4);\n\n      // TODO: Terrain texture LOD ?\n      let chunkTextureIndices =\n        allMaterials[chunkIndex].loResMaterial.texIndexArray;\n      // let matFileName = allMaterials[chunkIndex].loResMaterial.materialFile;\n      // let chunkTextureIndices = allMaterials[chunkIndex].hiResMaterial.texIndexArray;\n      // let matFileName = allMaterials[chunkIndex].hiResMaterial.materialFile;\n      // let chunkData = terrainData.chunkArray[chunkIndex];\n      // let mainTex = allTextures[chunkTextureIndices[0]];\n      let mat = customMaterial;\n\n      /// TODO: just tick invert y = false...?\n      let pageOffetX = (cx % 4) / 4.0;\n      let pageOffetY = 0.75 - (cy % 4) / 4.0;\n\n      // offset 0 -> 0.75\n\n      // Make sure we have shared textures\n\n      /// Load and store all tiled textures\n      let fileNames = [];\n      for (let gi = 0; gi < chunkTextureIndices.length / 2; gi++) {\n        let textureFileName = allTextures[chunkTextureIndices[gi]].filename;\n\n        fileNames.push(textureFileName);\n\n        /// If the texture is not already loaded, read it from the .dat!\n        if (!chunkTextures[textureFileName]) {\n          /// Load local texture\n          let chunkTex = RenderUtils.loadLocalTexture(\n            self.localReader,\n            textureFileName\n          );\n\n          if (chunkTex) {\n            /// Set repeat, antistropy and repeat Y\n            chunkTex.anisotropy = maxAnisotropy;\n            chunkTex.wrapS = THREE.RepeatWrapping;\n            chunkTex.wrapT = THREE.RepeatWrapping;\n          }\n\n          chunkTextures[textureFileName] = chunkTex;\n        }\n      } /// End for each chunkTextureIndices\n\n      /// Create Composite texture material, refering the shared textures\n      let pageTexName = pageX + \",\" + pageY;\n      let pageTexName2 = pageX + \",\" + pageY + \"-2\";\n\n      /// TODO USe mapData (Chunk: env -> haze)\n      // var fog = SceneUtils.getScene().fog;\n      let fog = {\n        color: { r: 1, g: 1, b: 1 },\n        near: 0,\n        far: 0\n      };\n\n      /// Get haze color from environment rednerer\n      let envOutput = self.getOutput(T3D.EnvironmentRenderer);\n      if (envOutput.hazeColor) {\n        fog.color.r = envOutput.hazeColor[2] / 255.0;\n        fog.color.g = envOutput.hazeColor[1] / 255.0;\n        fog.color.b = envOutput.hazeColor[0] / 255.0;\n      }\n\n      let uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib[\"lights\"]]);\n\n      /// TODO: READ FROM VO, don't default to hard coded scale\n      uniforms.uvScale = { type: \"v2\", value: new THREE.Vector2(8.0, 8.0) };\n      uniforms.offset = {\n        type: \"v2\",\n        value: new THREE.Vector2(pageOffetX, pageOffetY)\n      };\n\n      uniforms.texturePicker = { type: \"t\", value: chunkTextures[pageTexName] };\n      uniforms.texturePicker2 = {\n        type: \"t\",\n        value: chunkTextures[pageTexName2]\n      };\n\n      uniforms.texture1 = { type: \"t\", value: chunkTextures[fileNames[0]] };\n      uniforms.texture2 = { type: \"t\", value: chunkTextures[fileNames[1]] };\n      uniforms.texture3 = { type: \"t\", value: chunkTextures[fileNames[2]] };\n      uniforms.texture4 = { type: \"t\", value: chunkTextures[fileNames[3]] };\n\n      mat = new THREE.ShaderMaterial({\n        uniforms: uniforms,\n        fragmentShader: TerrainShader.getFragmentShader(),\n        vertexShader: TerrainShader.getVertexShader()\n      });\n\n      /// Store referenceto each material\n      allMats.push(mat);\n\n      /// -1 for faces -> vertices , -2 for ignoring outer faces\n      let chunkGeo = new THREE.PlaneBufferGeometry(\n        cdx,\n        cdy,\n        chunkW - 3,\n        chunkW - 3\n      );\n\n      let cn = 0;\n\n      /// Render chunk\n\n      /// Each chunk vertex\n      for (let y = 0; y < chunkW; y++) {\n        for (let x = 0; x < chunkW; x++) {\n          if (x !== 0 && x !== chunkW - 1 && y !== 0 && y !== chunkW - 1) {\n            chunkGeo.getAttribute(\"position\").array[cn * 3 + 2] =\n              terrainData.heightMapArray[n];\n            cn++;\n          }\n\n          n++;\n        }\n      } // End each chunk vertex\n\n      /// Flip the plane to fit wonky THREE js world axes\n      let mS = new THREE.Matrix4().identity();\n      mS.elements[5] = -1;\n      chunkGeo.applyMatrix(mS);\n\n      /// Compute face normals for lighting, not used when textured\n      chunkGeo.computeFaceNormals();\n      // chunkGeo.computeVertexNormals();\n\n      /// Build chunk mesh!\n      let chunk;\n      chunk = new THREE.Mesh(chunkGeo, customMaterial);\n      if (mat.length) {\n        chunk = THREE.SceneUtils.createMultiMaterialObject(chunkGeo, mat);\n      } else {\n        chunk = new THREE.Mesh(chunkGeo, mat);\n      }\n\n      /// Move and rotate Mesh to fit in place\n      chunk.rotation.set(Math.PI / 2, 0, 0);\n\n      /// Last term is the new one: -cdx*(2/35)\n      let globalOffsetX = parameterData.rect[0] + cdx / 2;\n      let chunkOffsetX = cx * cdx;\n\n      chunk.position.x = globalOffsetX + chunkOffsetX;\n\n      /// Adjust for odd / even number of chunks\n      if (terrainData.numChunksD_2 % 2 === 0) {\n        /// Last term is the new one: -cdx*(2/35)\n        let globalOffsetY = parameterData.rect[1] + cdy / 2 - 0; // -cdy*(1/35);\n        let chunkOffsetY = cy * cdy * 1; // 33/35;\n\n        chunk.position.z = chunkOffsetY + globalOffsetY;\n      } else {\n        let globalOffsetY = parameterData.rect[1] - cdy / 2 + 0; // cdy*(1/35);\n        let chunkOffsetY = cy * cdy * 1; // 33/35;\n\n        chunk.position.z = globalOffsetY + chunkOffsetY;\n      }\n\n      let px = chunk.position.x;\n      let py = chunk.position.z;\n\n      if (!self.mapRect) {\n        self.mapRect = {\n          x1: px - cdx / 2,\n          x2: px + cdx / 2,\n          y1: py - cdy / 2,\n          y2: py + cdy / 2\n        };\n      }\n\n      self.mapRect.x1 = Math.min(self.mapRect.x1, px - cdx / 2);\n      self.mapRect.x2 = Math.max(self.mapRect.x2, px + cdx / 2);\n\n      self.mapRect.y1 = Math.min(self.mapRect.y1, py - cdy / 2);\n      self.mapRect.y2 = Math.max(self.mapRect.y2, py + cdy / 2);\n\n      chunk.updateMatrix();\n      chunk.updateMatrixWorld();\n\n      /// Add to list of stuff to render\n      /// TODO: Perhaps use some kind of props for each entry instead?\n      self.getOutput().terrainTiles.push(chunk);\n    }; /// End render chunk function\n\n    let stepChunk = function(cx, cy) {\n      if (cx >= xChunks) {\n        cx = 0;\n        cy++;\n      }\n\n      if (cy >= yChunks) {\n        /// Draw water surface using map bounds\n        self.getOutput().water = self.drawWater(self.mapRect);\n\n        /// Set bounds in output VO\n        self.getOutput().bounds = self.mapRect;\n\n        /// Fire call back, we're done rendering.\n        callback();\n        return;\n      }\n\n      let pct = Math.floor((100 * (cy * xChunks + cx)) / (xChunks * yChunks));\n\n      self.logger.log(T3D.Logger.TYPE_PROGRESS, \"Loading Terrain\", pct);\n\n      renderChunk(cx, cy);\n      setTimeout(stepChunk, 1, cx + 1, cy);\n    };\n\n    stepChunk(0, 0);\n  };\n}\n\n/// DataRenderer inheritance:\nTerrainRenderer.prototype = Object.create(DataRenderer.prototype);\nTerrainRenderer.prototype.constructor = TerrainRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *terrainTiles* An array of THREE.Mesh objects visualizing terrain of the map.\n *\n * - *water* A THREE.Mesh object visualizing the bounds of the map.\n *\n * - *bounds* An object wiht x1, x2, y1, and y2 properties specifying the bounds of the map.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nTerrainRenderer.prototype.renderAsync = function(callback) {\n  /// Load all paged Images, requires inflation of other pack files!\n  let pagedImageId = this.mapFile.getChunk(\"trn\").data.materials.pagedImage;\n  this.localReader.loadFile(\n    pagedImageId,\n    this.loadPagedImageCallback.bind(this, callback)\n  );\n};\n\n/**\n * TODO: write description. Used for export feature\n *\n * @param  {Function} callback [description]\n * @return {*}            [description]\n */\nTerrainRenderer.prototype.getFileIdsAsync = function(/* callback */) {\n  let terrainChunk = this.mapFile.getChunk(\"trn\");\n  let pimgTableDataChunk = this.mapFile.getChunk(\"pimg\");\n  let fileIds = [];\n\n  /// ------------ SPLASH TEXTURES ------------\n  let pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\n  let strippedPages = pimgData.strippedPages;\n\n  /// Only use layer 0\n  strippedPages.forEach(function(page) {\n    /// Only load layer 0 and 1\n    if (page.layer <= 1 && page.filename > 0) {\n      fileIds.push(page.filename);\n    }\n  });\n  /// ------------ END SPLASH TEXTURES ------------\n\n  /// ------------ TILED IMAGES ------------\n  let terrainData = terrainChunk.data;\n  let allTextures = terrainData.materials.texFileArray;\n  allTextures.forEach(function(texture) {\n    if (texture.filename > 0) fileIds.push(texture.filename);\n  });\n  /// ------------ END TILED IMAGES ------------\n\n  return fileIds;\n};\n\nmodule.exports = TerrainRenderer;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"../util/RenderUtils\");\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates zone models for a map.\n *\n * @class ZoneRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction ZoneRenderer(localReader, settings, context, logger) {\n  DataRenderer.call(this, localReader, settings, context, logger);\n  this.mapFile = this.settings.mapFile;\n\n  /**\n   * TODO\n   *\n   * @param  {*} zone               [description]\n   * @param  {*} zoneDefs           [description]\n   * @param  {*} mapRect            [description]\n   * @param  {*} renderZoneCallback [description]\n   * @return {*}                    [description]\n   */\n  this.renderZone = function(zone, zoneDefs, mapRect, renderZoneCallback) {\n    let self = this;\n\n    /// Get Zone Definition\n    let zoneDef = null;\n    zoneDefs.forEach(function(zd) {\n      if (!zoneDef && zd.token === zone.defToken) zoneDef = zd;\n    });\n\n    /// Create array of all models to add:\n    // let models = []\n    let modelGroups = this.getModelGroups(zone, zoneDef, mapRect);\n\n    /// Create empty mesh cache\n    self.meshCache = {};\n    self.textureCache = {};\n\n    /*\n     * ---Keeping this out of the doc for now---\n     * Steps trough each model and renders it to the scene, allowing for efficient caching.\n     * @param  {Number} i - Current index within the models array\n     */\n    // var lastPct = -1;\n    let groupKeys = Object.keys(modelGroups);\n    function stepModels(i) {\n      /* var pct = Math.round(100.0*i / groupKeys.length);\n\t\t\tif(lastPct!=pct){\n\t\t\t\tconsole.log(\"Rendering ZONE models \"+pct);\n\t\t\t\tlastPct = pct;\n\t\t\t} */\n\n      if (i >= groupKeys.length) {\n        /// Empty mesh cache\n        self.meshCache = {};\n        self.textureCache = {};\n\n        /// Tell caller this zone is done loading\n        renderZoneCallback();\n        return;\n      }\n\n      /// Read model at index\n      /// var model = models[i];\n      let key = groupKeys[i]; /// key is model filename\n      let group = modelGroups[key];\n\n      let meshGroups = [];\n\n      /// Get model just once for this group\n      let showUnmaterialed = false;\n      RenderUtils.getMeshesForFilename(\n        key,\n        null,\n        self.localReader,\n        self.meshCache,\n        self.textureCache,\n        showUnmaterialed,\n\n        function(meshes /*, isCached*/) {\n          /// If there were meshes, add them to the scene with correct scaling rotation etc.\n          if (meshes /* && meshes.length == 3 */) {\n            /// Add one copy per model instance\n            /// TODO: add rotation!\n            /// TODO: fine tune position?\n            /// TODO: POTIMIZE!\n\n            group.forEach(function(model, instanceIdx) {\n              //let isCached = true;\n              //let scale = 1.0;\n\n              /// For each Mesh in the model\n              meshes.forEach(function(mesh, meshIdx) {\n                if (\n                  mesh.materialFlags ===\n                  525 /* || mesh.materialFlags == 520 || mesh.materialFlags == 521 */\n                ) {\n                  // console.log(\"Skipping lod\");\n                  return;\n                }\n\n                let move = { x: 0, y: 0, z: 0 };\n\n                /// Add to big mesh\n                if (!meshGroups[meshIdx]) {\n                  let mg = mesh.geometry.clone();\n                  meshGroups[meshIdx] = {\n                    readVerts: mg.getAttribute(\"position\").array,\n                    verts: new Float32Array(\n                      group.length * mg.getAttribute(\"position\").array.length\n                    ),\n\n                    readIndices: mg.getIndex().array,\n                    indices: new Uint32Array(\n                      group.length * mg.getIndex().array.length\n                    ),\n\n                    readUVs: mg.getAttribute(\"uv\").array,\n                    uvs: new Float32Array(\n                      group.length * mg.getAttribute(\"uv\").array.length\n                    ),\n\n                    readNormals: mg.getAttribute(\"normal\").array,\n                    normals: new Float32Array(\n                      group.length * mg.getAttribute(\"normal\").array.length\n                    ),\n\n                    material: mesh.material,\n                    // material:new THREE.MeshBasicMaterial( {color: 0xffcccc, wireframe:true} ),\n                    /* material : new THREE.PointCloudMaterial ({\n\t\t\t\t\t\t\t\t\t      color: 0xFF0000,\n\t\t\t\t\t\t\t\t\t      size: 20\n\t\t\t\t\t\t\t\t\t    }), */\n                    position: { x: model.x, y: model.y, z: model.z }\n                  };\n                } else {\n                  /// Translate\n                  move.x = model.x - meshGroups[meshIdx].position.x;\n                  move.y = model.z - meshGroups[meshIdx].position.z;\n                  move.z = model.y - meshGroups[meshIdx].position.y;\n                }\n\n                /// Add geom verts\n                let readVerts = meshGroups[meshIdx].readVerts;\n                let writeVerts = meshGroups[meshIdx].verts;\n                let stride = readVerts.length;\n\n                for (\n                  let i = 0, j = instanceIdx * stride;\n                  i < stride;\n                  i += 3, j += 3\n                ) {\n                  writeVerts[j + 0] = readVerts[i + 0] + move.x;\n                  writeVerts[j + 1] = readVerts[i + 1] + move.y;\n                  writeVerts[j + 2] = readVerts[i + 2] + move.z;\n                }\n\n                let readIndices = meshGroups[meshIdx].readIndices;\n                let writeIndices = meshGroups[meshIdx].indices;\n                let strideIndices = readIndices.length;\n                let shift = (stride * instanceIdx) / 3;\n\n                for (\n                  let i = 0, j = instanceIdx * strideIndices;\n                  i < strideIndices;\n                  i++, j++\n                ) {\n                  writeIndices[j] = readIndices[i] + shift;\n                }\n\n                let readUVs = meshGroups[meshIdx].readUVs;\n                let writeUvs = meshGroups[meshIdx].uvs;\n                let uvStride = readUVs.length;\n                for (\n                  let i = 0, j = instanceIdx * uvStride;\n                  i < uvStride;\n                  i++, j++\n                ) {\n                  writeUvs[j] = readUVs[i];\n                }\n\n                let readNormals = meshGroups[meshIdx].readNormals;\n                let writeNormals = meshGroups[meshIdx].normals;\n                let normalStride = readNormals.length;\n                for (\n                  let i = 0, j = instanceIdx * normalStride;\n                  i < normalStride;\n                  i++, j++\n                ) {\n                  writeNormals[j] = readNormals[i];\n                }\n              });\n            }); // End for each model in group\n          } /// End if meshes\n\n          /// Add each cluster of merged meshes to scene\n          meshGroups.forEach(function(meshGroup) {\n            let mergedGeom = new THREE.BufferGeometry();\n\n            mergedGeom.addAttribute(\n              \"position\",\n              new THREE.BufferAttribute(meshGroup.verts, 3)\n            );\n            // mergedGeom.addAttribute( 'index', new THREE.BufferAttribute( meshGroup.indices, 1) );\n            mergedGeom.setIndex(\n              new THREE.BufferAttribute(meshGroup.indices, 1)\n            );\n            mergedGeom.addAttribute(\n              \"normal\",\n              new THREE.BufferAttribute(meshGroup.normals, 3)\n            );\n            mergedGeom.addAttribute(\n              \"uv\",\n              new THREE.BufferAttribute(meshGroup.uvs, 2)\n            );\n\n            mergedGeom.buffersNeedUpdate = true;\n\n            let mesh = new THREE.Mesh(mergedGeom, meshGroup.material);\n            mesh.position.set(\n              meshGroup.position.x,\n              meshGroup.position.z,\n              meshGroup.position.y\n            );\n\n            self.getOutput().meshes.push(mesh);\n          }); // End for each meshgroup\n\n          /// Rendering is done, render next.\n          stepModels(i + 1);\n        }\n      );\n    } /// End function stepModels\n\n    /// Begin stepping trough the models, rendering them.\n    stepModels(0);\n  };\n\n  /**\n   * TODO\n   *\n   * @param  {*} zone    [description]\n   * @param  {*} zoneDef [description]\n   * @param  {*} mapRect [description]\n   * @return {*}         [description]\n   */\n  this.getModelGroups = function(zone, zoneDef, mapRect) {\n    /// Calculate rect in global coordinates\n    // let zPos = zone.zPos;\n\n    let mapX = mapRect[0];\n    let mapY = mapRect[1];\n    let c = 32 + 16;\n\n    // [\"x1\",\"uint32\",\"y1\",\"uint32\",\"x2\",\"uint32\", \"y2\", \"uint32\"]\n    let zoneRect = {\n      x1: zone.vertRect[0] * c + mapX,\n      x2: zone.vertRect[2] * c + mapX,\n      y1: zone.vertRect[1] * -c - mapY,\n      y2: zone.vertRect[3] * -c - mapY\n    };\n\n    /// Zone width and depth in local corrdinates\n    /* var zdx = zone.vertRect.x1-zone.vertRect.x2;\n\t\tvar zdy = zone.vertRect.y1-zone.vertRect.y2; */\n\n    /// These zones seems to overflow :/\n    if (zone.encodeData.length === 0) {\n      return {};\n    }\n\n    // console.log(\"Get mdl groups\", zone);\n    /// Testing: Render Zone Vert Rect\n    // RenderUtils.renderRect(zoneRect, -zPos);\n\n    let zdx = zone.vertRect[0] - zone.vertRect[2];\n    // let zdy = zone.vertRect[1] - zone.vertRect[3];\n\n    /// Zone Flags increases a linear position, used to step trough the Zone.\n    let linearPos = 0;\n\n    let modelGroups = {};\n\n    let terrainTiles = this.getOutput(T3D.TerrainRenderer).terrainTiles;\n\n    for (let i = 0; i < zone.flags.length; i += 2) {\n      /// Step forward\n      linearPos += zone.flags[i];\n\n      /// Check if a model should be placed\n      let flag = zone.flags[i + 1];\n      if (flag !== 0) {\n        /// Extract flag data\n        /// Layer is written in the last 4 bytes\n        let zoneDefLayer = flag >> 4;\n\n        /// Get Zone Definition Layer\n        let layer = zoneDef.layerDefArray[zoneDefLayer - 1];\n\n        /// TESTING Only show layers with height >= 3\n        if (layer /* && layer.height >= 0 */) {\n          /// Get X and Y from linear position\n          let modelX = (linearPos % zdx) * c + zoneRect.x1;\n          let modelY = Math.floor(linearPos / zdx) * c + zoneRect.y1;\n\n          /// Get Z from intersection with terrain\n          let modelZ = null;\n\n          let startZ = 100000;\n\n          let raycaster = new THREE.Raycaster(\n            new THREE.Vector3(modelX, startZ, modelY),\n            new THREE.Vector3(0, -1, 0)\n          );\n\n          /// TODO: OPT?\n          terrainTiles.forEach(function(chunk) {\n            if (modelZ === null) {\n              let intersections = raycaster.intersectObject(chunk);\n              if (intersections.length > 0) {\n                modelZ = startZ - intersections[0].distance;\n              }\n            }\n          });\n\n          /// Get model id\n          /// TODO: check with modelIdx = flag & 0xf;\n          let modelIdx = 0;\n          let model = layer.modelArray[modelIdx];\n          let modelFilename = model.filename;\n          // let zOffsets = model.zOffsets;\n\n          // let layerFlags = layer.layerFlags; // NOrmaly 128, 128\n\n          // TODO: flip z,y?\n          let rotRangeX = layer.rotRangeX; // max min\n          let rotRangeY = layer.rotRangeY; // max min\n          let rotRangeZ = layer.rotRangeZ; // max min\n          let scaleRange = layer.scaleRange; // max min\n          let fadeRange = layer.fadeRange; // max min\n\n          // Unused\n          // tiling: 3\n          // type: 1\n          // width: 2\n          // radiusGround: 2\n\n          /// Create modelGroup (this zone only)\n          if (!modelGroups[modelFilename]) {\n            modelGroups[modelFilename] = [];\n          }\n\n          /// Add entry to model group\n          modelGroups[modelFilename].push({\n            x: modelX,\n            y: modelY,\n            z: modelZ,\n            rotRangeX: rotRangeX,\n            rotRangeY: rotRangeY,\n            rotRangeZ: rotRangeZ,\n            scaleRange: scaleRange,\n            fadeRange: fadeRange\n          });\n        } /// End if layer\n      } /// End if flag != 0\n    } /// End for each flag\n\n    return modelGroups;\n  };\n}\n\n/// NOT USED??\n// eslint-disable-next-line no-unused-vars\nfunction addZoneMeshesToScene(meshes, isCached, position, scale, rotation) {\n  /// Called for each mesh in the zone\n  /// TODO: Opt opt opt...\n\n  meshes.forEach(function(mesh) {\n    /// Create new mesh if we got back a cached original.\n    if (isCached) mesh = new THREE.Mesh(mesh.geometry, mesh.material);\n\n    /// Scale, position and rotate.\n    mesh.scale.set(scale, scale, scale);\n    if (rotation) {\n      mesh.rotation.order = \"ZXY\";\n      mesh.rotation.set(rotation.x, rotation.y, rotation.z);\n    }\n    mesh.position.set(position.x, position.y, position.z);\n\n    /// Add to export\n    this.getOutput().meshes.push(mesh);\n  });\n}\n\n/// DataRenderer inheritance:\nZoneRenderer.prototype = Object.create(DataRenderer.prototype);\nZoneRenderer.prototype.constructor = ZoneRenderer;\n\n/**\n * Renders all zone meshes in a GW2 map described by the map's \"zon2\" chunk.\n * Output fileds generated:\n *\n * - *meshes* An array of THREE.Mesh objects visualizing all zone models refered by this map.\n *\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nZoneRenderer.prototype.renderAsync = function(callback) {\n  let self = this;\n\n  /// Set up output array\n  self.getOutput().meshes = [];\n\n  let zoneChunkData = this.mapFile.getChunk(\"zon2\").data;\n  let parameterChunkData = this.mapFile.getChunk(\"parm\").data;\n  // let terrainChunkData = this.mapFile.getChunk(\"trn\").data;\n  let mapRect = parameterChunkData.rect;\n\n  /// Zone data\n  let zones = zoneChunkData.zoneArray;\n  let zoneDefs = zoneChunkData.zoneDefArray;\n\n  /// Render each zone\n  let lastPct = -1;\n\n  /// Main render loop, render each zone\n  function stepZone(i) {\n    let pct = Math.round((100.0 * i) / zones.length);\n    if (lastPct !== pct) {\n      self.logger.log(\n        T3D.Logger.TYPE_PROGRESS,\n        \"Loading 3D Models (Zone)\",\n        pct\n      );\n      lastPct = pct;\n    }\n\n    if (i >= zones.length) {\n      callback();\n      return;\n    }\n\n    /// Main zone render function call\n    self.renderZone(zones[i], zoneDefs, mapRect, stepZone.bind(self, i + 1));\n  }\n\n  stepZone(0);\n};\n\nmodule.exports = ZoneRenderer;\n\n/// / Not used: zone defintion per chunk data \"images\" 32*32 points\n/*\n//Total map dx and dy\nvar d = terrainChunkHeader.data;\nvar pd = parameterChunkHeader.data;\nvar dx = (pd.rect.x2-pd.rect.x1);\nvar dy = (pd.rect.y2-pd.rect.y1);\n\n//Each chunk dx and dy\n\nvar c =1;\nvar cdx = c*dx/d.dims.dim1;\n\nvar cdy = c*dy/d.dims.dim2;\n\nvar cdx = dx/(d.numChunksD_1*2);\nvar cdy =dy/(d.numChunksD_2*2);\n\nfor(var i=0; i<zoneDefs.length; i++){\n\tvar zoneDef = zoneDefs[i];\n\n\t//TODO: opt!\n\tzoneDef.layerDefs.forEach(function(layer){\n\n\t\tlayer.modelArray.forEach(function(model){\n\n\t\t});\n\n\t});\n\n\tvar chunkMat = new THREE.MeshBasicMaterial(\n\t\t{\n\t\t\tcolor: 0x00ff00,\n\t\t\twireframe:true,\n\t\t \topacity: 1.0,\n\t\t}\n\t);\n\n\t//TODO: opt!\n\n\tif(\n\t\tzoneDef.token == 597  ||\n\t\tzoneDef.token == 1369  ||\n\t\tzoneDef.token == 903\n\t){\n\n\t\tzoneDef.pageTable.pageArray.forEach(function(page){\n\t\t\tvar flags = page.flags;\n\t\t\tvar coord = page.chunkCoord;\n\n\t\t\t//Hightlight this coord\n\t\t\tvar rect = {};\n\n\t\t\t//var globalOffsetX = pd.rect.x2 - cdx;\n\t\t\tvar globalOffsetX = pd.rect.x1 + cdx/2;\n\t\t\tvar chunkOffsetX = coord[0] * cdx;\n\n\t\t\trect.x1  = globalOffsetX + chunkOffsetX;\n\n\t\t\t///Adjust for odd / even number of chunks\n\t\t\tif(d.numChunksD_2 % 2 == 0){\n\n\t\t\t\tvar globalOffsetY = -pd.rect.y1;\n\t\t\t\tvar chunkOffsetY = -coord[1] * cdy;\n\n\t\t\t\trect.y1  =  chunkOffsetY + globalOffsetY;\n\t\t\t}\n\t\t\telse{\n\n\t\t\t\tvar globalOffsetY =  -pd.rect.y1;\n\t\t\t\tvar chunkOffsetY = -coord[1] * cdy;\n\n\t\t\t\trect.y1 = globalOffsetY +  chunkOffsetY;\n\t\t\t}\n\n\t\t\trect.x2 = rect.x1+cdx;\n\t\t\trect.y2 = rect.y1+cdy;\n\n\t\t\tRenderUtils.renderRect(rect, 4000,chunkMat, 4000);\n\n\t\t\t//for(var j=0; j<flags.length; j++){\n\t\t\t//\tif(flags[j]>0){\n\t\t\t//\t\tconsole.log(\"Found flag\",flags[j],\"@ zoneDef\",zoneDef.token,\"coord\",coord,\"index\",j);\n\t\t\t//\t}\n\t\t\t//}\n\t\t});\n\n\t}\n\n} */\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst HEAD_STRUCT = [\n  \"type\",\n  \"cstring:4\",\n  \"chunkDataSize\",\n  \"uint32\",\n  \"chunkVersion\",\n  \"uint16\",\n  \"chunkHeaderSize\",\n  \"uint16\",\n  \"offsetTableOffset\",\n  \"uint32\"\n];\n\n/**\n * Settings for resolving conflicting chunk names in different files.\n * @private\n * @property DUPLICATE_SETTINGS\n * @type {Object}\n */\nlet DUPLICATE_SETTINGS;\n\n// Replacement for DUPLICATE_SETTINGS, based on the name of the root property.\nconst PACKTOCHUNK = [\n  { pack: \"MODL\", chunk: \"ANIM\", root: \"ModelFileAnimation\" },\n  { pack: \"MODL\", chunk: \"GAME\", root: \"ModelFileGame\" },\n  { pack: \"MODL\", chunk: \"SKEL\", root: \"ModelFileSkeleton\" },\n  { pack: \"MODL\", chunk: \"TOOL\", root: \"ModelFileTool\" },\n  { pack: \"cntc\", chunk: \"Main\", root: \"PackContent\" },\n  { pack: \"mMet\", chunk: \"Main\", root: \"PackMapMetadata\" },\n  { pack: \"AMAT\", chunk: \"TOOL\", root: \"AmatToolParams\" },\n  { pack: \"cmaC\", chunk: \"main\", root: \"CollideModelManifest\" }\n];\n\n// Builds the DUPLICATE_SETTINGS based on the provided T3D.formats.\n// Required to be done dynamically since the 32 bit and 64bits have different ordering\nfunction genDuplicateSettings() {\n  // Early return if the settings have been already generated\n  if (DUPLICATE_SETTINGS) return;\n\n  function getRootName(definition) {\n    let a = new definition();\n    return Object.keys(a).filter(v => {\n      return a[v] === a.__root && v !== \"__root\";\n    })[0];\n  }\n\n  DUPLICATE_SETTINGS = {};\n  for (let setting of PACKTOCHUNK) {\n    let regex = new RegExp(`^${setting.root}(V[0-9]*)?$`);\n    let chunkDef = T3D.formats.filter(v => {\n      return v.name === setting.chunk;\n    });\n\n    for (let defsIdx in chunkDef) {\n      let defs = chunkDef[defsIdx].versions;\n      let lastVersion = defs[Object.keys(defs).pop()];\n      let rootName = getRootName(lastVersion);\n      if (rootName.match(regex)) {\n        if (!DUPLICATE_SETTINGS[setting.chunk]) {\n          DUPLICATE_SETTINGS[setting.chunk] = [];\n        }\n        DUPLICATE_SETTINGS[setting.chunk][defsIdx] = setting.pack;\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Basic chunk parsing functionality for Guild Wars 2 file chunks\n *\n * @constructor\n * @param {DataStream} ds A DataStream containing deflated chunk binary data.\n * @param {Number} addr Offset of chunk start within the DataStream\n */\nclass GW2Chunk {\n  constructor(ds, addr) {\n    // Early returns if already called, it defines the DUPLICATE_SETTINGS variable\n    genDuplicateSettings();\n\n    /**\n     * @property {DataStream} ds The DataStream data source used by this chunk.\n     */\n    this.ds = ds;\n\n    /**\n     * @property {Number} addr The address to this Chunk within ds.\n     */\n    this.addr = addr;\n\n    /**\n     * @property {Object} data The typed data read from the body of this chunk.\n     */\n    this.data = null;\n\n    /**\n     * @property {Number} headerLength The length in bytes of the chunk header.\n     */\n    this.headerLength = NaN;\n\n    /**\n     * @property {Object} header Chunk header data.\n     */\n    this.loadHead();\n  }\n\n  /**\n   * Parses the chunk header data, populating the header property.\n   */\n  loadHead() {\n    this.ds.seek(this.addr);\n    this.header = this.ds.readStruct(HEAD_STRUCT);\n\n    this.headerLength = this.ds.position - this.addr;\n  }\n\n  /**\n   * @param  {String} fileType The main type of the pack file containing this chunk.\n   * Used for resolving chunk naming conflicts between pack file types.\n   * @return {Array}\tDataStream formatted array describing the data\n   * sctructures of this chunk\n   */\n  getDefinition(fileType) {\n    /// Normally we're looking for the 0th occurance\n    /// But some chunk names occur multiple times and we're interrested\n    /// in the N:th occurance of the definition.\n    ///\n    /// I've no idea how this is automated, for now just use the\n    /// settings object I've put together from experience.\n    let useNthIndex = 0;\n\n    /// If this chunk has multiple definitions\n    /// get to know what def to use...\n    let fileTypes = DUPLICATE_SETTINGS[this.header.type];\n    if (fileTypes) {\n      useNthIndex = -1;\n\n      /// Check what file name entry matches this file name\n      for (let i = 0; i < fileTypes.length && useNthIndex === -1; i++) {\n        let ft = fileTypes[i];\n\n        if (ft === fileType) {\n          useNthIndex = i;\n        }\n      }\n\n      /// We didnt find this file name!\n      /// TODO: if you get this error, please update the DUPLICATE_SETTINGS above\n      if (useNthIndex === -1) {\n        throw new Error(\"We didnt find this file name!\");\n        //debugger;\n      }\n    }\n\n    let defsFound = 0;\n    for (let i = 0; i < T3D.formats.length; i++) {\n      let f = T3D.formats[i];\n\n      /// Chunk name needs to match\n      if (f.name === this.header.type) {\n        /// There needs to be a chunk def version matching the one specifiend\n        ///\n        /// AND If this is the Nth occurance of the chunk definition\n        /// and we're looking for the Nth occurance, return it.\n        ///\n        /// chunkVersion in the dat uses 0 indexing\n        if (defsFound === useNthIndex && f.versions[this.header.chunkVersion]) {\n          return new f.versions[this.header.chunkVersion]().__root;\n        }\n\n        defsFound++;\n      }\n    }\n  }\n\n  /**\n   * Parses the chunk main data, populating the data property.\n   *\n   * @param  {String} fileType The main type of the pack file containing this chunk.\n   * Used for resolving chunk naming conflicts between pack file types when\n   * looking up the structure definition for this chunk.\n   */\n  loadData(fileType) {\n    let def = this.getDefinition(fileType);\n\n    if (def) {\n      this.ds.seek(this.addr + this.headerLength);\n      this.data = this.ds.readStruct(def);\n    } else {\n      T3D.Logger.log(\n        T3D.Logger.TYPE_WARNING,\n        \"Could not find a definition for chunk\",\n        this.header.type,\n        \"version\",\n        this.header.chunkVersion,\n        \"file name\",\n        fileType\n      );\n    }\n  }\n\n  /**\n   * Retrieves the next chunk is the datastream. In practice this means the next chunk\n   * within the same pack file.\n   *\n   * @return {GW2Chunk} The next chunk if any, otherwise null.\n   */\n  next() {\n    try {\n      // Calculate actual data size, as mChunkDataSize\n      // does not count the size of some header variables\n      return new GW2Chunk(this.ds, this.addr + 8 + this.header.chunkDataSize);\n    } catch (e) {\n      /// Out of bounds probably\n    }\n    return null;\n  }\n}\n\nmodule.exports = GW2Chunk;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst Chunk = require(\"./GW2Chunk\");\n\nconst HEAD_STRUCT = [\n  \"identifier\",\n  \"cstring:2\",\n  \"unknownField1\",\n  \"uint16\",\n  \"unknownField2\",\n  \"uint16\",\n  \"pkFileVersion\",\n  \"uint16\",\n  \"type\",\n  \"cstring:4\"\n];\n\n/**\n * Basic header and chunk parsing functionality for Guild Wars 2 pack files (PF)\n *\n * @constructor\n * @param {DataStream} ds A DataStream containing deflated file binary data.\n * @param {Number} addr Offset of file start within the DataStream\n * @param {boolean} noChunks If true, the file does not parse its\n * chunks on creation.\n */\nclass GW2File {\n  constructor(ds, addr, noChunks) {\n    /**\n     * @property {DataStream} ds The DataStream data source used by this file.\n     */\n    this.ds = ds;\n\n    /**\n     * @property {Number} addr The address to this File within ds.\n     */\n    this.addr = addr;\n\n    /// Not used anymore I think\n    this.data = null;\n\n    /**\n     * @property {Number} headerLength The length in bytes of the file header.\n     */\n    this.headerLength = NaN;\n\n    /**\n     * All {{#crossLink \"GW2Chunk\"}}chunks{{/crossLink}} contained in the file.\n     *\n     * @property chunks\n     * @type GW2Chunk[]\n     */\n    this.chunks = [];\n\n    /**\n     * @property {Object} header Chunk header data.\n     */\n    this.readHead();\n\n    if (!noChunks) {\n      this.readChunks();\n    }\n  }\n\n  /**\n   * Parses the file header data, populating the header property.\n   */\n  readHead() {\n    this.ds.seek(this.addr);\n    this.header = this.ds.readStruct(HEAD_STRUCT);\n    this.headerLength = this.ds.position - this.addr;\n  }\n\n  /**\n   * Parses the file headers and populates the chunks property.\n   */\n  readChunks() {\n    /// Reset chunks\n    this.chunks = [];\n\n    // var structs = this.getChunkStructs && this.getChunkStructs();\n\n    /// Load basic Chunk in order to read the chunk header.\n    let ch = new Chunk(this.ds, this.headerLength + this.addr);\n\n    // while(structs && ch!=null && ch.header.type){\n    while (ch !== null && ch.header.type) {\n      /// Load data and pass file type if we need to determine what chunk entry to use\n      /// (Some chunks in different files share the same chunk name)\n      ch.loadData(this.header.type);\n      this.chunks.push(ch);\n\n      /// Load next basic Chunk in order to read the chunk header.\n      ch = ch.next();\n    }\n  }\n\n  /**\n   * Get a GW2Chunk from this file\n   *\n   * @param  {String} type The name, or type of the desired chunk.\n   * @return {GW2Chunk} The first GW2Chunk in this file matching the type name, or null if no matching GW2Chunk was found.\n   */\n  getChunk(type) {\n    for (let i = 0; i < this.chunks.length; i++) {\n      if (this.chunks[i].header.type.toLowerCase() === type.toLowerCase()) {\n        return this.chunks[i];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Provides a list of known header types and their parsing structure. Should be defined by each file type individually.\n   *\n   * @return {Object} An object mapping chunk identifiers to DataStream structure descriptors.\n   */\n  getChunkStructs() {\n    return {};\n  }\n}\n\nmodule.exports = GW2File;\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n\tguid 1683952224941671000 is fucked up floor in SAB HUB\n\tmaterialFilename for that mesh is 564821, shared with lots of stuff\n\tlod 1 and 2 are both 0\n\tmaterial flags is 2056\n*/\n\n/**\n * Collection of methods for generating THREE materials and textures\n * from Guild Wars 2 data formats.\n * @namespace MaterialUtils\n */\n\n/**\n * Builds a custom vertex shader for a given number of uv cannels.\n * WIP not implemented yet!\n *\n * @memberof MaterialUtils\n * @param  {Number} numUv Number of UV channels used by this shader\n * @return {String}       Genereted vertex shader source\n */\nfunction buildVS(numUv) {\n  let vdefs = \"\";\n  let adefs = \"\";\n  let reads = \"\";\n  for (let i = 0; i < numUv; i++) {\n    vdefs += \"varying vec2 vUv_\" + (i + 1) + \";\\n\";\n\n    /// uv and uv2 are defined by THREE\n    if (i > 1) adefs += \"attribute vec2 uv\" + (i + 1) + \";\\n\";\n\n    reads += \"vUv_\" + (i + 1) + \" = uv\" + (i > 0 ? i + 1 : \"\") + \";\\n\";\n  }\n\n  return (\n    adefs +\n    vdefs +\n    \"void main()\\n\" +\n    \"{\\n\" +\n    reads +\n    \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\" +\n    \"gl_Position = projectionMatrix * mvPosition;\\n\" +\n    \"}\"\n  );\n}\n\n/**\n * Generate a texture of a specified color, used to be part of THREEjs\n *\n * @memberof MaterialUtils\n * @param {Number} width\n * @param {Number} height\n * @param {THREE.Color} color\n * @returns {THREE.DataTexture}\n */\nfunction generateDataTexture(width, height, color) {\n  // create a buffer with color data\n  let size = width * height;\n  let data = new Uint8Array(4 * size);\n  let r = Math.floor(color.r * 255);\n  let g = Math.floor(color.g * 255);\n  let b = Math.floor(color.b * 255);\n  let a = 255;\n\n  for (let i = 0; i < size; i++) {\n    let stride = i * 4;\n\n    data[stride] = r;\n    data[stride + 1] = g;\n    data[stride + 2] = b;\n    data[stride + 3] = a;\n  }\n  // used the buffer to create a DataTexture\n  return new THREE.DataTexture(data, width, height, THREE.RGBAFormat);\n}\n\n/**\n * Builds a custom pixel shader for a given number of uv cannels.\n * WIP not implemented yet!\n *\n * @memberof MaterialUtils\n * @param  {Array}  textures  THREE textures\n * @param  {Number} numUv     Number of UV channels used by this shader\n * @param  {Number} alphaTest Texture see-trough alpha treshold\n * @param  {any} lightMap  TODO\n * @returns {string}\n */\nfunction buildPS(textures, numUv, alphaTest, lightMap) {\n  let t1uv = \"vUv_\" + (textures[0].uvIdx + 1);\n\n  let discard = \"\";\n\n  if (alphaTest) {\n    discard = \"    if (c1.a < 0.5) \\n\" + \"       discard;\\n\";\n  }\n\n  /// Color from 1st text or lighted by 2nd?\n  let writeColor = \"gl_FragColor = c1;\\n\";\n\n  if (lightMap) {\n    let texIdx = 0;\n    // var t2uv = \"vUv_4\";//+(3-textures[texIdx].uvIdx+1);\n    let t2uv = \"vUv_1\"; // + (textures[texIdx].uvIdx+1);\n    // console.log(\"t2uv\",t2uv);\n\n    writeColor =\n      \"   vec4 c2 = texture2D( texture\" +\n      (texIdx + 1) +\n      \", \" +\n      t2uv +\n      \" );\\n\" +\n      \"     gl_FragColor = c2;\\n\";\n    // \"     gl_FragColor = vec4(c2.rgb * c1.r/.5, c2.a);\\n\";\n  }\n\n  let uniforms = \"\";\n  textures.forEach(function(t, idx) {\n    uniforms += \"uniform sampler2D texture\" + (idx + 1) + \";\\n\";\n  });\n  /* uniforms += \"uniform sampler2D texture1;\\n\";\n\tif(lightMap)\n\t\tuniforms += \"uniform sampler2D texture2;\\n\"; */\n\n  let varyings = \"\";\n  for (let i = 0; i < numUv; i++) {\n    varyings += \"varying vec2 vUv_\" + (i + 1) + \";\\n\";\n  }\n\n  return (\n    uniforms +\n    varyings +\n    \"void main( void ) {\\n\" +\n    \"    vec4 c1 = texture2D( texture1, \" +\n    t1uv +\n    \" );\\n\" +\n    discard +\n    writeColor +\n    \"}\"\n  );\n}\n\n/**\n * WIP, concept for generatin materials to render multi UV chanelled meshes.\n *\n * @memberof MaterialUtils\n * @param  {Array} \ttextures  THREE texture\n * @param  {Number} numUV     Number of UV channels used by this shader\n * @param  {Number} alphaTest Texture see-trough alpha treshold\n * @return {THREE.ShaderMaterial} Generated shader\n */\nfunction getUVMat(textures, numUV, alphaTest) {\n  let lightMap = false;\n  let uniforms = {};\n\n  textures.forEach(function(t, idx) {\n    uniforms[\"texture\" + idx] = { type: \"t\", value: t };\n  });\n\n  if (textures.length > 1) {\n    lightMap = true;\n  }\n\n  let attributes = {};\n\n  for (let i = 2; i < numUV; i++) {\n    attributes[\"uv\" + (i + 1)] = { type: \"v2\", value: [] };\n  }\n\n  let vs = buildVS(numUV);\n\n  return new THREE.ShaderMaterial({\n    uniforms: uniforms,\n    vertexShader: vs,\n    fragmentShader: buildPS(textures, numUV, alphaTest, lightMap),\n    attributes: attributes,\n    side: THREE.FrontSide\n  });\n}\n\n/**\n * Builds a THREE texture from a ModelMaterialData by reading settings and\n * loading any required data from the localReader. Uses sharedTextures for\n * texture caching.\n *\n * This method is full of guesses and estimations, and could be improved on\n * a lot, allowing rendering of multi UV channeled materials, or special\n * materials like custom color chanelled gear.\n *\n * @memberof MaterialUtils\n * @param  {ModelMaterialData} material \tA value object often automaticaly\n *                                       \tgenerated by a\n *                                       \t{{#crossLink \"GW2Chunk\"}}{{/crossLink}}\n *                                       \tstructure definitions can be found in\n *                                       \tAllFormats.js, look for the latest\n *                                       \tversion of ModelMaterialData\n *\n * @param  {GW2File} materialFile   A GW2File instance, must be of type AMAT\n * @param  {LocalReader} localReader The LocalReader to load the file contents from.\n * @param  {Object} sharedTextures  Value Object for keeping the texture cache\n * @return {THREE.Material}         A THREE Material with the generated contents and settings.\n */\nfunction getMaterial(material, materialFile, localReader, sharedTextures) {\n  if (!materialFile) return;\n\n  let dxChunk = materialFile.getChunk(\"dx9s\");\n  let grChunk = materialFile.getChunk(\"grmt\");\n\n  /// Append all textures to the custom material\n  let finalTextures = [];\n\n  // Some materials don't use textures..\n  if (\n    material &&\n    material.textures.length /* && material.textures[texIndex] */\n  ) {\n    /// TODO: check for flags!\n    ///\n    /// techinques[] -> passes[] -> effects[] -> samplerIndex[]\n    ///\n    // console.log(\"num effects\",dxChunk.data.techniques[0].passes[0].effects.length);\n\n    // if(grChunk.data.flags!=76)\n    //\treturn;\n\n    /// 3 teqs : high medium low\t\t\t\t\t\t\t\tGRAPHICS LEVEL SETTINGS\n    /// 1 passes\t\t\t\t\t\t\t\t\t\t\t\tDON'T CARE\n    /// 15 effects\t\t\tEach effect has a pixel shader \t\tHOW??\n    /// 1 or 2 sampler indices \t\t\t\t\t\t\t\t\tUSE ALL! (Multi material)\n\n    let effects = dxChunk.data.techniques[0].passes[0].effects;\n    // var effect = effects[10];\n    let effect = effects[0];\n\n    //let shader = dxChunk.data.shaders[effect.pixelShader];\n\n    /* effects.forEach(function (eff) {\n\t\t\tif(eff.samplerIndex.length > effect.samplerIndex.length)\n\t\t\t\teffect = eff;\n\t\t}); */\n    // var samplerIdx = effect.samplerIndex[0];\n\n    let samplerTextures = [];\n    let textureToken;\n    let samplerTex;\n    for (let i = 0; i < effect.samplerIndex.length; i++) {\n      let samplerIdx = effect.samplerIndex[i];\n      let sampler = dxChunk.data.samplers[samplerIdx];\n\n      /// SHOULD NEVER HAPPEN, hide mesh!\n      if (!sampler) continue; // return;\n\n      textureToken = sampler && grChunk.data.texTokens[sampler.textureIndex];\n      if (!textureToken) textureToken = \"0-0\";\n      /* else\n\t\t\t\ttextureToken =textureToken.val; */\n\n      /// Find the texture reffered by this sampler\n      samplerTex = null;\n\n      material.textures.forEach(function(tex /*, index*/) {\n        /// Seems like only 1st part of token is used...\n        if (\n          !samplerTex &&\n          tex.token.split(\"-\")[0] === textureToken.split(\"-\")[0]\n        ) {\n          // console.log(\"TEX match\",tex.token, textureToken)\n          samplerTex = tex;\n        }\n      });\n\n      /// Add this sampler's texture to the collection of all textures\n      if (samplerTex) {\n        samplerTextures.push(samplerTex);\n      } else {\n        /// FALLBACK, just guess what texture we should use\n        if (sampler) {\n          samplerTextures.push(material.textures[sampler.textureIndex]);\n        } else if (material.textures.length > 0) {\n          samplerTextures.push(material.textures[0]);\n        } else return;\n      }\n    } /// END for each sampler index in effect\n\n    /// We now have all textures\n    // console.log(\"textures from sampler\", samplerTextures);\n\n    /// Fallback to using whatever texture there is.\n    if (samplerTextures.length <= 0) {\n      return;\n      // mainTex =  material.textures[0];\n    }\n\n    // console.log(\"num samplers \",samplerTextures.length);\n    samplerTextures.forEach(function(texture, idx) {\n      if (!texture) return;\n\n      /// Set texture \"URL\"\n      let texURL = texture && texture.filename;\n\n      /// Load texture from RAM or local reader:\n      finalTextures[idx] = getTexture(texURL, localReader, sharedTextures);\n      if (finalTextures[idx]) {\n        finalTextures[idx].uvIdx = texture.uvPSInputIndex;\n      }\n    });\n  } /// End if material and texture\n\n  let finalMaterial;\n\n  /// Create custom shader material if there are textures\n  if (finalTextures) {\n    // TODO: make this work!\n    //eslint-disable-next-line no-constant-condition\n    if (false && finalTextures.length > 0) {\n      finalMaterial = getUVMat(\n        finalTextures,\n        material.texCoordCount,\n        grChunk.data.flags !== 16460\n      );\n    } else {\n      let ft = false;\n      let nt = false;\n      material.textures.forEach(function(t) {\n        // Flag for diffuse map\n        if (!ft && t.token.split(\"-\")[0] === \"1733499172\") ft = t;\n\n        // Flag for normal map\n        if (!nt && t.token.split(\"-\")[0] === \"404146670\") nt = t;\n      });\n\n      if (!ft || ft.filename <= 0) return;\n\n      finalMaterial = new THREE.MeshPhongMaterial({\n        side: THREE.FrontSide,\n        map: getTexture(ft.filename, localReader, sharedTextures)\n      });\n      if (nt) {\n        let normalMap = getTexture(nt.filename, localReader, sharedTextures);\n        normalMap.flipY = true;\n        finalMaterial.normalMap = normalMap;\n      }\n\n      finalMaterial.textureFilename = ft.filename;\n      if (grChunk.data.flags !== 16460) {\n        // console.log(\"Setting alpha flag for \",grChunk.data.flags)\n        finalMaterial.alphaTest = 0.05;\n      }\n    }\n  }\n\n  /// Fallback material is monocolored red\n  else {\n    finalMaterial = new THREE.MeshBasicMaterial({\n      side: THREE.FrontSide,\n      color: 0xff0000,\n      shading: THREE.FlatShading\n    });\n  }\n\n  finalMaterial.needsUpdate = true;\n\n  /// Set material props\n  /// disable for now in order for custom shaders not to fuck up\n\n  if (material) {\n    let alphaMask0 = 0x0001; // + 0x0100 + 0x0200;\n    let alphaMask1 = 0x0010;\n    let alphaMask2 = 0x0100 + 0x0200;\n    //let alphaMask2b = 0x0200;\n\n    grChunk = materialFile.getChunk(\"grmt\");\n\n    // Enable alpha test for transparent flags\n    if (\n      material.materialFlags & alphaMask0 ||\n      material.materialFlags & alphaMask1 ||\n      material.materialFlags & alphaMask2 // && solidColor != null\n    ) {\n      // return;\n      // mesh.material.transparent = true;\n      // mesh.material.opacity = 2.0;\n      // var clr = solidColor;\n      // var propAlpha = 0;\n      /// Backgroud color adds to alpha\n      // if( mesh.materialFlags == 2569  ){\n      /// This is rly just guesswork\n      /// Check material flag  2568 (as int) and compare material filename 27353 to 20041\n      /// Same flags but some have alpha and some don't\n      // if( mesh.materialFlags & alphaMask2b  ){\n      //\tpropAlpha =  (clr[3] - 128)/128;\n      //\t//propAlpha = Math.max(0,propAlpha);\n      // }\n      // mesh.material.alphaTest = Math.max(0, 0.1 );//- propAlpha*2);\n    }\n\n    /// GRCHUNK -> DATA -> FLAGS\n\n    /// HAS LIGHT - TEX - ? - EMISSIVE16460\n    ///\n\n    /// 56533 LOD FOR TOMBSTONE?\n\n    //\t16460\t\t\t0100 0000 0100 1100\t\t\t\"standard\" stuff rendering OK in SAB (no alpha test)\n\n    //\n    //\t16452(SAB)\t\t0100 0000 0100 0100\t\t\tyellow numbers in sab signs\n    //\t16448(SAB)\t\t0100 0000 0100 0000\t\t\tfaces on rocks, cloudmen, skybox portal images, holes in walls, floor plates...\n    //\t\t\t\t\t\t\t\t\t\t\t\tno lighting??\n    //\n    //\t 8268\t\t\t0010 0000 0100 1100\n    //\t 3392\t\t\t0000 1101 0100 0000\t\t\tMoto machine light bulbs\n    //\t 2380\t\t\t0000 1001 0100 1100\n    //\t 2368\t\t\t0000 1001 0100 0000\t\t\tFountain water with rings, portal border and circular \"light\"\n    //\t  332\t\t\t0000 0001 0100 1100\n    //\t  324\t\t\t0000 0001 0100 0100\t\t\tMoto face sprites\n    //\n    //\t  320(SAB)\t\t0000 0001 0100 0000\t\t\tportal textures (normal maps ish)\n    //\n    //\t   76\t\t\t0000 0000 0100 1100\t\t\tLOTS OF STUFF\n    //\t   \t\t\t\t\t\t\t\t\t\t\tTree leaves, ground, hills, some roofs, flags, street lights\n    //\t   \t\t\t\t\t\t\t\t\t\t\tsheild textures, some fences, water tops, waterfall\n    //\n    //\t   \t\t\t\t\t\t\t\t\t\t\tIN KHYLO \"everything with alpha\"\n    //\n    //\n    //\t   68\t\t\t0000 0000 0100 0100\t\t\tSome flowers (lo res?) fountain edges foam\n    //\n    //\t   64(SAB)\t\t0000 0000 0100 0000\t\t\tclouds, sun iamge\n\n    let lightMask = 8;\n\n    let knownFileFlags = [\n      16460,\n      16452,\n      16448,\n      8268,\n      3392,\n      2380,\n      2368,\n      332,\n      324,\n      320,\n      76,\n      68,\n      64\n    ];\n\n    if (knownFileFlags.indexOf(grChunk.data.flags) < 0) {\n      T3D.Logger.log(\n        T3D.Logger.TYPE_WARNING,\n        \"unknown GR flag\",\n        grChunk.data.flags\n      );\n    }\n\n    if (!(grChunk.data.flags & lightMask)) {\n      // debugger;\n      // console.log(\"no light\");\n      finalMaterial = new THREE.MeshBasicMaterial({\n        side: THREE.FrontSide,\n        map: finalMaterial.map\n      });\n    }\n\n    if (grChunk.data.flags !== 16460) {\n      finalMaterial.alphaTest = 0.05;\n    }\n  } /// End if material\n\n  return finalMaterial;\n}\n\n/**\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\n * Any loaded tetures are added to sharedTextures, allowing for texture caching and fewer reads.\n *\n * @memberof MaterialUtils\n * @param  {Number} texURL         The fileId or baseId of the file to load image data from.\n * @param  {LocalReader} localReader    The LocalReader to load the file contents from.\n * @param  {Object} sharedTextures Value Object for keeping the texture cache\n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nfunction getTexture(texURL, localReader, sharedTextures) {\n  let finalTexture;\n\n  /// Read texture from shared array of loaded textures\n  /// or read it from URL and add to shared ones!\n  if (texURL && sharedTextures[texURL]) {\n    /// Just read from already loaded textures.\n    finalTexture = sharedTextures[texURL];\n  } else if (texURL) {\n    /// Load and add to shared array.\n    finalTexture = loadLocalTexture(localReader, texURL);\n\n    /// Set standard texture functionality.\n    finalTexture.wrapT = THREE.RepeatWrapping;\n    finalTexture.wrapS = THREE.RepeatWrapping;\n    finalTexture.flipY = false;\n\n    sharedTextures[texURL] = finalTexture;\n  }\n\n  return finalTexture;\n}\n\n/**\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\n * If you're loading multiple textures, make sure to use\n * {{#crossLink \"MaterialUtils/getTexture\"}}{{/crossLink}} that allows you to cache textures.\n *\n * @memberof MaterialUtils\n * @param {LocalReader} localReader - The LocalReader to load the file contents from.\n * @param {Number} fileId - The fileId or baseId of the file to load image data from.\n * @param {Number} mapping - What THREE mapping the returned texture will use, not implemented.\n\n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nfunction loadLocalTexture(localReader, fileId, mapping, defaultColor, onerror) {\n  if (defaultColor === undefined) {\n    defaultColor = Math.floor(0xffffff * Math.random());\n  }\n\n  /// Temporary texture that will be returned by the function.\n  /// Color is randomized in order to differentiate different textures during loading.\n  let texture = generateDataTexture(\n    1, // Width\n    1, // Height\n    new THREE.Color(defaultColor) // Color\n  );\n\n  // Threejs r71 is using these settings by default, r72+ changed it\n  texture.minFilter = THREE.LinearMipMapLinearFilter;\n  texture.magFilter = THREE.LinearFilter;\n  texture.generateMipmaps = true;\n  texture.flipY = true;\n\n  /// Only allow non-zero fileId, otherwise jsut return static texture\n  if (parseInt(fileId) <= 0) {\n    if (onerror) onerror();\n    return texture;\n  }\n\n  /// Load file using LocalReader.\n  localReader.loadTextureFile(fileId, function(\n    inflatedData,\n    dxtType,\n    imageWidth,\n    imageHeigth\n  ) {\n    /// Require infalted data to be returned.\n    if (!inflatedData) {\n      if (onerror) onerror();\n      return;\n    }\n\n    /// Create image using returned data.\n    let image = {\n      data: new Uint8Array(inflatedData),\n      width: imageWidth,\n      height: imageHeigth\n    };\n\n    /// Use RGBA for all textures for now...\n    /// TODO: don't use alpha for some formats!\n    texture.format =\n      //eslint-disable-next-line no-constant-condition\n      dxtType === 3 || dxtType === 5 || true\n        ? THREE.RGBAFormat\n        : THREE.RGBFormat;\n\n    /// Update texture with the loaded image.\n    texture.image = image;\n    texture.needsUpdate = true;\n  });\n\n  /// Return texture with temporary content.\n  return texture;\n}\n\nmodule.exports = {\n  buildVS: buildVS,\n  generateDataTexture: generateDataTexture,\n  buildPS: buildPS,\n  getUVMat: getUVMat,\n  getMaterial: getMaterial,\n  loadLocalTexture: loadLocalTexture\n};\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst base32Max = Math.pow(2, 32);\n\n/**\n * Collection Math and sorting methods\n * @namespace MathUtils\n */\n\n/**\n * Takes an integer and calculates what the 16 bit float\n * representation of the binary data used to read the integer is.\n *\n * @memberof MathUtils\n * @param  {Number} h Integer value\n * @return {Number} Float value\n */\nfunction f16(h) {\n  let s = (h & 0x8000) >> 15;\n  let e = (h & 0x7c00) >> 10;\n  let f = h & 0x03ff;\n\n  if (e === 0) {\n    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n  } else if (e === 0x1f) {\n    return f ? NaN : (s ? -1 : 1) * Infinity;\n  }\n\n  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\n}\n\n/**\n * Calculates the number of binary ones present in the data used to\n * generate the input integer.\n *\n * @memberof MathUtils\n * @param  {Number} bits Integer\n * @return {Number}      Number of binary ones in the data\n */\nfunction popcount(bits) {\n  let SK5 = 0x55555555;\n  let SK3 = 0x33333333;\n  let SKF0 = 0x0f0f0f0f;\n  // let SKFF = 0xff00ff\n\n  bits -= (bits >> 1) & SK5;\n  bits = (bits & SK3) + ((bits >> 2) & SK3);\n  bits = (bits & SKF0) + ((bits >> 4) & SKF0);\n  bits += bits >> 8;\n\n  return (bits + (bits >> 15)) & 63;\n}\n\n/**\n * Calculates the 64 bit integer value of two 32 bit integers. Only works up to\n * the limit of the javascript Number maximum value.\n *\n * @memberof MathUtils\n * @param  {Number[]} arr     Input integers, length should be 2.\n * @return {Number}      64 bit representation of the two integers.\n */\nfunction arr32To64(arr) {\n  /// Re-read as uint64 (still little endian)\n  /// Warn: this will not work for ~50+ bit longs cus all JS numbers are 64 bit floats...\n  return base32Max * arr[1] + arr[0];\n}\n\n/**\n * Sorts an array and returns unique values only.\n *\n * @memberof MathUtils\n * @param  {Array} arr_in     Input array\n * @param  {Function} comparator A comparator function between the objects in arr_in\n * @return {Array}            Sorted and unique value.\n */\nfunction sort_unique(arr_in, comparator) {\n  let arr = Array.prototype.sort.call(arr_in, comparator);\n\n  let u = {};\n  let a = [];\n  for (let i = 0, l = arr.length; i < l; ++i) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (u.hasOwnProperty(arr[i])) {\n      continue;\n    }\n    a.push(arr[i]);\n    u[arr[i]] = 1;\n  }\n\n  return a;\n}\n\nmodule.exports = {\n  f16: f16,\n  popcount: popcount,\n  arr32To64: arr32To64,\n  sort_unique: sort_unique\n};\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @namespace ParserUtils\n */\n\n/**\n * Collection of methods used for parsing complex data types from the .dat\n *\n * Most of these methods are only refered by the automatically generated script\n * AllFormats.js\n *\n */\n\nmodule.exports = {\n  /**\n   * Generates a function for reading an array using DataStream\n   *\n   * @param  {Array} structDef DataStream formatted structure definition\n   *                           for the items in the array.\n   * @param  {Number} maxCount The maximum allowed length of the array.\n   *                           Allows any length if left unspecified.\n   * @return {Function}        The generated parsing function.\n   */\n  getArrayReader: function(structDef, maxCount) {\n    return function(ds, struct) {\n      let ret = [];\n      try {\n        let arr_len = ds.readUint32();\n        let offset = ds.readUint32();\n        if (offset === 0) {\n          return ret;\n        }\n        let arr_ptr = ds.position - 4 + offset;\n        let pos = ds.position;\n\n        if (maxCount && arr_len > maxCount) {\n          throw \"Array length \" +\n            arr_len +\n            \" exceeded allowed maximum \" +\n            maxCount;\n        }\n\n        ds.seek(arr_ptr);\n        ret = ds.readType([\"[]\", structDef, arr_len], struct);\n        ds.seek(pos);\n      } catch (e) {\n        console.warn(\"getArrayReader Failed loading array\", e);\n        console.warn(\n          \"getArrayReader Failed loading array, structDef\",\n          structDef\n        );\n      }\n      return ret;\n    };\n  },\n\n  /**\n   * Generates a function for reading a refered array using DataStream\n   *\n   * @param  {Array} structDef DataStream formatted structure definition\n   *                           for the items in the array.\n   * @return {Function}        The generated parsing function.\n   */\n  getRefArrayReader: function(structDef) {\n    return function(ds) {\n      let ret_arr = [];\n\n      /// Read array of offsets\n      let arr_len = ds.readUint32();\n      let arr_ptr = ds.position + ds.readUint32();\n\n      if (arr_len === 0) {\n        return ret_arr;\n      }\n\n      let orgPos = ds.position;\n\n      /// Go to pointer and read an array of offsets!\n      ds.seek(arr_ptr);\n      let offsets = ds.readInt32Array(arr_len);\n\n      // p_data is after having read array\n      // var pointer = p_data - 4;\n      let pointer = orgPos - 4;\n\n      // auto offset  = *reinterpret_cast<const int32*>(pointer);\n      ds.seek(pointer);\n      let offset = ds.readUint32(); /// this should be the same as arr_ptr\n\n      // pointer     += offset;\n      pointer += offset;\n\n      for (let i = 0; i < offsets.length; i++) {\n        if (offsets[i] !== 0) {\n          let pos = pointer + i * 4 + offsets[i];\n          ds.seek(pos);\n\n          try {\n            ret_arr.push(ds.readStruct(structDef));\n          } catch (e) {\n            // debugger;\n            ret_arr.push(null);\n            console.warn(\n              \"getRefArrayReader could not find refered data at offset\",\n              offsets[i],\n              e\n            );\n          }\n        }\n      } /// End for each offset\n\n      ds.seek(orgPos);\n      return ret_arr;\n    };\n  },\n\n  /**\n   * Generates a function for reading a 64bit initeger. For now just reads each\n   * 32 bit integer and glues together as a string.\n   *\n   * @return {Function}        The generated parsing function.\n   */\n  getQWordReader: function() {\n    // let base32Max = 4294967296;\n    return function(ds /*, struct */) {\n      return ds.readUint32() + \"-\" + ds.readUint32();\n\n      // let p0 = ds.readUint32();\n      // let p1 = ds.readUint32();\n      // return base32Max * p1 + p0;\n    };\n  },\n\n  /**\n   * Generates a function for reading a string of 8 bit chars.\n   *\n   * @return {Function}        The generated parsing function.\n   */\n  getStringReader: function() {\n    return function(ds /*, struct*/) {\n      let ptr = ds.position + ds.readUint32();\n      let pos = ds.position;\n\n      /// Go to pointer\n      ds.seek(ptr);\n\n      let ret = ds.readCString();\n\n      /// Go back to where we were\n      ds.seek(pos);\n\n      return ret;\n    };\n  },\n\n  /**\n   * Generates a function for reading a string of 16 bit chars.\n   *\n   * @return {Function}        The generated parsing function.\n   */\n  getString16Reader: function(stringOffset) {\n    return function(ds /*, struct*/) {\n      let ptr = ds.position + ds.readUint32() + (stringOffset || 0);\n      let pos = ds.position;\n\n      /// Go to pointer\n      ds.seek(ptr);\n\n      let ret = \"\";\n      let num;\n      while (ds.position + 2 < ds.byteLength && (num = ds.readUint16()) !== 0) {\n        ret += String.fromCharCode(num);\n      }\n      // ds.readCString();\n\n      /// Go back to where we were\n      ds.seek(pos);\n\n      return ret;\n    };\n  },\n\n  /**\n   * Generates a function for reading a pointer.\n   *\n   * @param  {Array} structDef DataStream formatted structure definition\n   *                           for the item pointed to.\n   * @return {Function}        The generated parsing function.\n   */\n  getPointerReader: function(structDef) {\n    return function(ds /*, struct*/) {\n      let offset = ds.readUint32();\n\n      if (offset === 0) {\n        return {};\n      }\n\n      let ptr = ds.position - 4 + offset;\n      let pos = ds.position;\n\n      /// Go to pointer\n      ds.seek(ptr);\n\n      let ret = ds.readStruct(structDef);\n\n      /// Go back to where we were\n      ds.seek(pos);\n\n      return ret;\n    };\n  },\n\n  /**\n   * Generates a function for reading a filename/file Id.\n   *\n   * @return {Function}        The generated parsing function.\n   */\n  getFileNameReader: function() {\n    return function(ds /*, struct*/) {\n      let pos;\n      try {\n        let ptr = ds.position + ds.readUint32();\n        pos = ds.position;\n\n        /// Go to pointer\n        ds.seek(ptr);\n\n        let fileRef = ds.readStruct([\n          \"m_lowPart\",\n          \"uint16\", // uint16 m_lowPart;\n          \"m_highPart\",\n          \"uint16\", // uint16 m_highPart;\n          \"m_terminator\",\n          \"uint16\" // uint16 m_terminator;\n        ]);\n\n        /// Getting the file name...\n        /// Both need to be >= than 256 (terminator is 0)\n        let ret =\n          0xff00 * (fileRef.m_highPart - 0x100) +\n          (fileRef.m_lowPart - 0x100) +\n          1;\n        // var ret = (fileRef.m_highPart - 0x100) * 0xff00 + (fileRef.m_lowPart - 0xff);\n\n        if (ret < 0) {\n          ret = 0;\n          // console.log(\"FR negative\", fileRef.m_highPart, fileRef.m_lowPart, fileRef.m_terminator);\n          // debugger;\n        }\n\n        /// Go back to where we were\n        ds.seek(pos);\n\n        return ret;\n      } catch (e) {\n        /// Go back to where we were\n        ds.seek(pos);\n\n        return -1;\n      }\n    };\n  }\n};\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require(\"../format/file/GW2File\");\nconst MaterialUtils = require(\"./MaterialUtils\");\nconst MathUtils = require(\"./MathUtils\");\n\n// TODO: Remove this local cache!!\nlet matFiles = {};\n\n/**\n * Object describing the meaning of the bits in fvf integers.\n * @property fvfFormat\n * @private\n * @type {Object}\n */\nlet fvfFormat = {\n  Position: 0x00000001 /** < 12 bytes. Position as three 32-bit floats in the order x, y, z. */,\n  Weights: 0x00000002 /** < 4 bytes. Contains bone weights. */,\n  Group: 0x00000004 /** < 4 bytes. Related to bone weights. */,\n  Normal: 0x00000008 /** < 12 bytes. Normal as three 32-bit floats in the order x, y, z. */,\n  Color: 0x00000010 /** < 4 bytes. Vertex color. */,\n  Tangent: 0x00000020 /** < 12 bytes. Tangent as three 32-bit floats in the order x, y, z. */,\n  Bitangent: 0x00000040 /** < 12 bytes. Bitangent as three 32-bit floats in the order x, y, z. */,\n  TangentFrame: 0x00000080 /** < 12 bytes. */,\n  UV32Mask: 0x0000ff00 /** < 8 bytes for each set bit. Contains UV-coords as two 32-bit floats in the order u, v. */,\n  UV16Mask: 0x00ff0000 /** < 4 bytes for each set bit. Contains UV-coords as two 16-bit floats in the order u, v. */,\n  Unknown1: 0x01000000 /** < 48 bytes. Unknown data. */,\n  Unknown2: 0x02000000 /** < 4 bytes. Unknown data. */,\n  Unknown3: 0x04000000 /** < 4 bytes. Unknown data. */,\n  Unknown4: 0x08000000 /** < 16 bytes. Unknown data. */,\n  PositionCompressed: 0x10000000 /** < 6 bytes. Position as three 16-bit floats in the order x, y, z. */,\n  Unknown5: 0x20000000 /** < 12 bytes. Unknown data. **/\n};\n\n/**\n * Collection of methods used for generating THREE meshes from Guild Wars 2 data formats.\n * @namespace RenderUtils\n */\n\n/**\n * Creates a mesh representing a single plane.\n *\n * @memberof RenderUtils\n * @param  {Object} rect     An object with x1,x2,y1 and y2 properties.\n * @param  {Number} yPos     Vertical position of the rectangle.\n * @param  {THREE.Material} material \tMesh material to apply.\n * @param  {Number} dy       Mesh height.\n * @return {THREE.Mesh}      The generated mesh.\n */\nfunction renderRect(rect, yPos, material, dy) {\n  let dx = rect.x1 - rect.x2;\n  let dz = rect.y1 - rect.y2;\n  if (!dy) dy = 1;\n\n  let cx = (rect.x1 + rect.x2) / 2;\n  let cz = (rect.y1 + rect.y2) / 2;\n  let cy = yPos;\n\n  let geometry = new THREE.BoxGeometry(dx, dy, dz);\n\n  material =\n    material ||\n    new THREE.MeshBasicMaterial({\n      color: 0xff0000,\n      wireframe: true\n    });\n  let plane = new THREE.Mesh(geometry, material);\n  plane.overdraw = true;\n\n  plane.position.x = cx;\n  plane.position.y = cy;\n  plane.position.z = cz;\n\n  return plane;\n}\n\n/**\n * Load image data into a THREE.Texture from a file within the GW2 .dat file using a LocalReader.\n *\n * @deprecated Please use the original function from MaterialUtils\n * @memberof RenderUtils\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Number} fileId The fileId or baseId of the file to load image data from.\n * @param {Number} mapping What THREE mapping the returned texture will use, not implemented.\n * @param  {Array} defaultColor RGBA array of 4 integers. The default solid color of the mesh, should texture loading fail.\n * @param {Function} onerror Error callback, not implemented.\n *\n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nfunction loadLocalTexture(localReader, fileId, mapping, defaultColor, onerror) {\n  T3D.Logger.log(\n    T3D.Logger.TYPE_WARNING,\n    \"RenderUtils.loadLocalTexture is deprecated ! Please use the one from MaterialUtils.\"\n  );\n  return MaterialUtils.loadLocalTexture(\n    localReader,\n    fileId,\n    mapping,\n    defaultColor,\n    onerror\n  );\n}\n\n/**\n * Returns a THREE representation of the data contained by a GW2 model file.\n * The data is read using a LocalReader reference into the GW2 .dat.\n *\n * @memberof RenderUtils\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Object} chunk Model GEOM chunk.\n * @param {Object} modelDataChunk Model MODL chunk.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n *\n * @return {Array} Each geometry in the model file represented by a textured THREE.Mesh object\n */\nfunction renderGeomChunk(\n  localReader,\n  chunk,\n  modelDataChunk,\n  sharedTextures,\n  showUnmaterialed\n) {\n  let rawMeshes = chunk.data.meshes;\n  let meshes = [];\n  let mats = modelDataChunk.data.permutations[0].materials;\n\n  rawMeshes.forEach(function(rawMesh) {\n    let rawGeom = rawMesh.geometry;\n    let fvf = rawGeom.verts.mesh.fvf; // rawGeom.fvf;\n\n    let numVerts = rawGeom.verts.vertexCount; // rawGeom.vertexCount;\n\n    let rawVerts = rawGeom.verts.mesh.vertices; // rawGeom.vertices\n\n    let indices = rawGeom.indices.indices;\n\n    let geom = new THREE.BufferGeometry();\n\n    let vertDS = new DataStream(rawVerts.buffer);\n\n    // Dirty step length for now:\n    let stride = rawVerts.length / numVerts;\n\n    // Each vertex\n    // DO UV as well\n    let vertices = new Float32Array(numVerts * 3);\n    // let tangents = null;\n    let normals = null;\n    let uvs = [];\n\n    /// Calculate the distance to the first pair of UV data from the\n    /// start of the vertex entry\n    ///\n    let distToNormals =\n      !!(fvf & fvfFormat.Position) * 12 +\n      !!(fvf & fvfFormat.Weights) * 4 +\n      !!(fvf & fvfFormat.Group) * 4;\n\n    let distToTangent =\n      distToNormals +\n      !!(fvf & fvfFormat.Normal) * 12 +\n      !!(fvf & fvfFormat.Color) * 4;\n\n    let distToBittangent = distToTangent + !!(fvf & fvfFormat.Tangent) * 12;\n\n    let distToTangentFrame =\n      distToBittangent + !!(fvf & fvfFormat.Bitangent) * 12;\n\n    let distToUV = distToTangentFrame + !!(fvf & fvfFormat.TangentFrame) * 12;\n\n    /// Check if the UV is 32 bit float or 16 bit float.\n    let uv32Flag = (fvf & fvfFormat.UV32Mask) >> 8;\n    let uv16Flag = (fvf & fvfFormat.UV16Mask) >> 16;\n    let isUV32 = !!uv32Flag;\n    let hasUV = !!uv16Flag || !!uv32Flag;\n\n    /// Popcount (count the number of binary 1's) in the UV flag\n    /// to get the number of UV pairs used in this vertex format.\n    let masked = isUV32 ? uv32Flag : uv16Flag;\n    let numUV = MathUtils.popcount(masked);\n\n    numUV = Math.min(numUV, 1.0);\n\n    /// Create typed UV arrays\n    if (hasUV) {\n      for (let i = 0; i < numUV; i++) {\n        uvs[i] = new Float32Array(numVerts * 2);\n      }\n    }\n\n    if (fvf & fvfFormat.Normal) {\n      // console.log(\"HAS Normal\");\n    }\n\n    if (fvf & fvfFormat.Tangent) {\n      // console.log(\"HAS Tangent\");\n    }\n\n    if (fvf & fvfFormat.Bitangent) {\n      // console.log(\"HAS Bitangent\");\n    }\n    if (fvf & fvfFormat.TangentFrame) {\n      // console.log(\"HAS TangentFrame\");\n    }\n\n    /// Read data from each vertex data entry\n    for (let i = 0; i < numVerts; i++) {\n      /// Go to vertex memory position\n      vertDS.seek(i * stride);\n\n      /// Read position data\n      /// (we just hope all meshes has 32 bit position...)\n      let x = vertDS.readFloat32();\n      let z = vertDS.readFloat32();\n      let y = vertDS.readFloat32();\n\n      /// Write position data, transformed to Tyria3D coordinate system.\n      vertices[i * 3 + 0] = x; // - c.x;\n      vertices[i * 3 + 1] = -y; // + c.y;\n      vertices[i * 3 + 2] = -z; // + c.z;\n\n      /// Read data at UV position\n      if (hasUV) {\n        for (let uvIdx = 0; uvIdx < numUV; uvIdx++) {\n          vertDS.seek(i * stride + distToUV + uvIdx * (isUV32 ? 8 : 4));\n\n          /// Add one UV pair:\n\n          let u, v;\n          if (isUV32) {\n            u = vertDS.readUint32();\n            v = vertDS.readUint32();\n          } else {\n            u = MathUtils.f16(vertDS.readUint16());\n            v = MathUtils.f16(vertDS.readUint16());\n          }\n\n          /// Push to correct UV array\n          uvs[uvIdx][i * 2 + 0] = u;\n          uvs[uvIdx][i * 2 + 1] = v;\n        }\n      } /// End if has UV\n    } /// End each vertex\n\n    /// Each face descripbed in indices\n    let faces = new Uint16Array(indices.length);\n    for (let i = 0; i < indices.length; i += 3) {\n      // This is ONE face\n      faces[i + 0] = indices[i + 2];\n      faces[i + 1] = indices[i + 1];\n      faces[i + 2] = indices[i + 0];\n    } // End each index aka \"face\"\n\n    /// Add position, index and uv props to buffered geometry\n    geom.addAttribute(\"position\", new THREE.BufferAttribute(vertices, 3));\n    // geom.addAttribute( 'index', new THREE.BufferAttribute( faces, 1) );\n    geom.setIndex(new THREE.BufferAttribute(faces, 1));\n\n    if (normals) {\n      console.log(\"adding normals\");\n      geom.addAttribute(\"normal\", new THREE.BufferAttribute(normals, 3));\n      geom.normalizeNormals();\n      geom.normalsNeedUpdate = true;\n    } else {\n      /// Calculate normals\n      geom.computeVertexNormals();\n    }\n\n    if (hasUV) {\n      for (let uvIdx = 0; uvIdx < numUV; uvIdx++) {\n        /// Names are \"uv\", \"uv2\", \"uv3\", ... , \"uvN\"\n        let uvName = \"uv\" + (uvIdx > 0 ? uvIdx + 1 : \"\");\n\n        /// Set \"custom\" attribute uvN\n        geom.addAttribute(uvName, new THREE.BufferAttribute(uvs[uvIdx], 2));\n\n        /// Flag for update\n        geom.attributes[uvName].needsUpdate = true;\n      }\n\n      /// Not needed anymore?\n      geom.uvsNeedUpdate = true;\n    }\n\n    /// Tell geometry to update its UVs and buffers\n    geom.buffersNeedUpdate = true;\n\n    /// DONE READING VERTEX DATA\n\n    /// Get material used for this mesh\n    let matIdx = rawMesh.materialIndex;\n    let mat = mats[matIdx];\n    let materialFile = null;\n\n    if (mat && matFiles[mat.filename]) {\n      materialFile = matFiles[mat.filename];\n    }\n\n    let finalMaterial = MaterialUtils.getMaterial(\n      mat,\n      materialFile,\n      localReader,\n      sharedTextures\n    );\n\n    /// IF we could not find a material abort OR use a wireframe placeholder.\n    if (!finalMaterial) {\n      if (showUnmaterialed) {\n        finalMaterial = new THREE.MeshLambertMaterial({\n          color: 0x5bb1e8,\n          wireframe: false,\n          side: THREE.DoubleSide\n        });\n      } else {\n        return;\n      }\n    }\n\n    /// Create the final mesh from the BufferedGeometry and MeshBasicMaterial\n    let finalMesh = new THREE.Mesh(geom, finalMaterial);\n\n    /// Set material info on the returned mesh\n    if (mat) {\n      finalMesh.materialFlags = mat.materialFlags;\n      finalMesh.materialFilename = mat.filename;\n    }\n\n    finalMesh.materialName = rawMesh.materialName;\n\n    /// Use materialFilename, materialName, and material.textureFilename in order to build export\n\n    /// Set lod info on the returned mesh\n    finalMesh.numLods = rawMesh.geometry.lods.length;\n    finalMesh.lodOverride = modelDataChunk.data.lodOverride;\n\n    /// Set flag and UV info on the returned mehs\n    finalMesh.flags = rawMesh.flags;\n    finalMesh.numUV = numUV;\n\n    /// Add mesh to returned Array\n    meshes.push(finalMesh);\n  }); /// End rawMeshes forEach\n\n  return meshes;\n}\n\n/**\n * Loads mesh array from Model file and sends as argument to callback.\n *\n * @memberof RenderUtils\n * @async\n * @param  {Number} filename Name of the model file to load data from.\n * @param  {Array} solidColor RGBA array of 4 integers\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n\n * @param  {Function} callback Fired once all meshes have been loaded.\n * two arguments are passed to the callback function.\n *\n * The first argument is an Array with each textured THREE.Mesh objects.\n *\n * The second argument is the bounding spehere of this model file.\n *\n */\n\nfunction loadMeshFromModelFile(\n  filename,\n  solidColor,\n  localReader,\n  sharedTextures,\n  showUnmaterialed,\n  callback\n) {\n  // Short handles prop attributes\n  let finalMeshes = [];\n\n  /// Load file\n  localReader.loadFile(filename, function(inflatedData) {\n    try {\n      if (!inflatedData) {\n        throw \"Could not find MFT entry for \" + filename;\n      }\n\n      let ds = new DataStream(inflatedData);\n\n      let modelFile = new GW2File(ds, 0);\n\n      // MODL for materials -> textures\n      let modelDataChunk = modelFile.getChunk(\"modl\");\n\n      // GEOM for geometry\n      let geometryDataChunk = modelFile.getChunk(\"geom\");\n\n      /// Hacky fix for not being able to adjust for position\n      let boundingSphere = modelDataChunk.data.boundingSphere;\n      let bsc = boundingSphere.center;\n      boundingSphere.radius += Math.sqrt(\n        bsc[0] * bsc[0] + Math.sqrt(bsc[1] * bsc[1] + bsc[2] * bsc[2])\n      );\n\n      /// Load all material files\n      let allMats = modelDataChunk.data.permutations[0].materials;\n\n      //eslint-disable-next-line no-inner-declarations\n      function loadMaterialIndex(mIdx, matCallback) {\n        if (mIdx >= allMats.length) {\n          matCallback();\n          return;\n        }\n\n        let mat = allMats[mIdx];\n\n        /// Skip if file is loaded\n        if (matFiles[mat.filename]) {\n          loadMaterialIndex(mIdx + 1, matCallback);\n          return;\n        }\n\n        localReader.loadFile(mat.filename, function(inflatedData) {\n          if (inflatedData) {\n            let ds = new DataStream(inflatedData);\n            let materialFile = new GW2File(ds, 0);\n            matFiles[mat.filename] = materialFile;\n          }\n\n          loadMaterialIndex(mIdx + 1, matCallback);\n        });\n      }\n\n      loadMaterialIndex(0, function() {\n        /// Create meshes\n        let meshes = renderGeomChunk(\n          localReader,\n          geometryDataChunk,\n          modelDataChunk,\n          sharedTextures,\n          showUnmaterialed\n        );\n\n        // Build mesh group\n        meshes.forEach(function(mesh) {\n          /// Material flags\n          let knownflags = [\n            /*\n\t\t\t\t\t\t\t1-5\n\t\t\t\t\t\t\tHas Tex?\tIDK\t\t\tLight?\t\tAlpha?\n\n\t\t\t\t\t\t\t5-8\n\t\t\t\t\t\t\t0\t\t\t0\t \t\tIDK\t\t \tWater?\n\n\t\t\t\t\t\t\t9-12\n\t\t\t\t\t\t\tHas Tex?\t0\t\t\tAlpha?\t\tAlpha?\n\n\t\t\t\t\t\t\t13\n\t\t\t\t\t\t\tIDK KEV\n\t\t\t    \t\t*/\n\n            0, // 0 0000 0000 0000\t\tGround / Wall splashes\n            8, // 0 0000 0000 1000\t\tBroken Khylo roof DDS\n            9, // 0 0000 0000 1001\t\tTree leaves\n\n            520, // 0 0010 0000 1000\t\tSome LOD modules, fires, smoke, inside of tents (some DSS textures)\n\n            2056, // 0 1000 0000 1000\t\tSolid objects, also broken animations\n\n            /// Solids here are unhappy, or are they? could be animations etc\n            2057, // 0 1000 0000 1001\t\tWindmill sails, bushes, trees, but also a statue and a few pieces of wall\n\n            2060, // 0 1000 0000 1100\t\tA few solid objects, like wooden barricades, one(!) painting\n            2061, // 0 1000 0000 1101\t\tA few bushes, two paintings\n\n            2312, // 0 1001 0000 1000\t\tOpaque Clock tower main walls AND IVY\n            2316, // 0 1001 0000 1100\t\tBushes, inner flower walkway a ramp and a box\n\n            // Number 10\n            2568, // 0 1010 0000 1000\t\tLots of solids; walls, tents also some tent details WITH alpa\n\n            // Number 11\n            2569, // 0 1010 0000 1001\t\tSolids like walls and roofs and appernt non solids like ropes\n\n            2572, // 0 1010 0000 1100\t\tSolid wooden beems, lamp posts\n            2573, // 0 1010 0000 1101\t\tLamp holders, bushes, fences, apparent non solids\n            2584, // 0 1010 0001 1000\t\tFountain Well water\n\n            2824, // 0 1011 0000 1000\t\tWindows, sign arrows, cloth roofs (non solids) BUT straw roofs\n            2828, // 0 1011 0000 1100\t\tA few fence post (non solids)\n            2840, // 0 1011 0001 1000\t\tFountain running water + pipe water\n\n            4617, // 1 0010 0000 1001\t\tFound nothing\n            6664 // 1 1010 0000 1000\t\tTwo groups of solid boxes\n          ];\n\n          // let alphaMask0 = 0x0001 // + 0x0100 + 0x0200;\n          // let alphaMask1 = 0x0010\n          // let alphaMask2 = 0x0100 + 0x0200\n          // let alphaMask2b = 0x0200\n\n          let texMask = 0x8 + 0x0800;\n\n          if (knownflags.indexOf(mesh.materialFlags) !== 11) {\n            // return;\n          }\n\n          // No smoke etc\n          if (mesh.materialFlags === 520) {\n            // return;\n          }\n\n          // Must have texture\n          if (!showUnmaterialed && !(mesh.materialFlags & texMask)) {\n            return;\n          }\n\n          // NO lods\n          if (mesh.flags === 4 || mesh.flags === 1 || mesh.flags === 0) {\n            // return;\n          }\n\n          // Add to final colection\n          finalMeshes.push(mesh);\n        }); /// END FOR EACH meshes\n\n        callback(finalMeshes, boundingSphere);\n      }); /// END LOAD MATERIALS CALLBACK\n    } catch (e) {\n      console.warn(\"Failed rendering model \" + filename, e);\n      let mesh = new THREE.Mesh(\n        new THREE.BoxGeometry(200, 2000, 200),\n        new THREE.MeshNormalMaterial()\n      );\n      mesh.flags = 4;\n      mesh.materialFlags = 2056;\n      mesh.lodOverride = [1000000, 1000000];\n      finalMeshes.push(mesh);\n\n      /// Send the final meshes to callback function\n      callback(finalMeshes);\n    }\n  }); /// END FILE LOADED CALLBACK FUNCTION\n}\n\n/**\n * Gets a mesh array from Model file and sends as argument to callback. Uses a cache of meshes in order\n * to never read the same model file twice.\n *\n * @memberof RenderUtils\n * @async\n * @param  {Number} filename The fileId or baseId of the Model file to load\n * @param  {Array} color RGBA array of 4 integers\n * @param  {LocalReader} localReader The LocalReader object used to read data from the GW2 .dat file.\n * @param {Object} sharedMeshes  Value Object for keeping the texture cache.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n * @param  {Function} callback Fired once all meshes have been loaded.\n * three arguments are passed to the callback function.\n *\n * The first argument is an Array with each textured THREE.Mesh objects.\n *\n * The second argument is a boolean, true indicates that these meshes were not\n * loaded from the dat file, but retrieved from the run time cache.\n *\n * The third argument is the bounding spehere of this model file.\n */\nfunction getMeshesForFilename(\n  filename,\n  color,\n  localReader,\n  sharedMeshes,\n  sharedTextures,\n  showUnmaterialed,\n  callback\n) {\n  /// If this file has already been loaded, just return a reference to the meshes.\n  /// isCached will be set to true to inform the caller the meshes will probably\n  /// have to be cloned in some way.\n  if (sharedMeshes[filename]) {\n    callback(\n      sharedMeshes[filename].meshes,\n      true,\n      sharedMeshes[filename].boundingSphere\n    );\n  }\n\n  /// If this file has never been loaded, load it using loadMeshFromModelFile\n  /// the resulting mesh array will be cached within this model's scope.\n  else {\n    loadMeshFromModelFile(\n      filename,\n      color,\n      localReader,\n      sharedTextures,\n      showUnmaterialed,\n      function(meshes, boundingSphere) {\n        /// Cache result if any.\n        if (meshes) {\n          sharedMeshes[filename] = {\n            meshes: meshes,\n            boundingSphere: boundingSphere\n          };\n        }\n\n        /// Allways fire callback.\n        callback(meshes, false, boundingSphere);\n      }\n    );\n  }\n}\n\n/**\n * WIP, Tries to find all fileIds refered by a model file.\n *\n * @memberof RenderUtils\n * @async\n * @param  {Number}   filename    Model file Id\n * @param  {LocalReader}   localReader LocalReader instance to read from\n * @param  {Function} callback   First argument is list of used file IDs\n */\nfunction getFilesUsedByModel(filename, localReader, callback) {\n  let fileIds = [filename];\n\n  /// Load model file\n  localReader.loadFile(filename, function(inflatedData) {\n    try {\n      if (!inflatedData) {\n        throw \"Could not find MFT entry for \" + filename;\n      }\n\n      let ds = new DataStream(inflatedData);\n      let modelFile = new GW2File(ds, 0);\n\n      // MODL for materials -> textures\n      let modelDataChunk = modelFile.getChunk(\"modl\");\n\n      /// Get materials used by model\n      let mats = modelDataChunk.data.permutations[0].materials;\n\n      /// Add each material file AND referenced TEXTURES\n      mats.forEach(function(mat) {\n        /// Add material file id\n        let matFileName = mat.filename;\n        fileIds.push(matFileName);\n\n        /// Add each texture file id\n        mat.textures.forEach(function(tex) {\n          fileIds.push(tex.filename);\n        });\n      });\n    } catch (e) {\n      console.warn(\"Could not export any data\", e);\n    }\n\n    callback(fileIds);\n  });\n}\n\nmodule.exports = {\n  renderRect: renderRect,\n  loadLocalTexture: loadLocalTexture,\n  renderGeomChunk: renderGeomChunk,\n  loadMeshFromModelFile: loadMeshFromModelFile,\n  getMeshesForFilename: getMeshesForFilename,\n  getFilesUsedByModel: getFilesUsedByModel\n};\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = {\n  /// TODO: port fog from in-engine\n\n  getFragmentShader: function() {\n    return [\n      \"uniform vec2 uvScale;\",\n      \"uniform vec2 offset;\",\n      \"uniform sampler2D texturePicker;\",\n      \"uniform sampler2D texturePicker2;\",\n      \"uniform sampler2D texture1;\",\n      \"uniform sampler2D texture2;\",\n      \"uniform sampler2D texture3;\",\n      \"uniform sampler2D texture4;\",\n\n      THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"],\n\n      \"varying vec2 vUv;\",\n      \"varying vec3 vecNormal;\",\n\n      \"vec3 blend(\",\n      \"vec4 texture1, float a1, vec4 texture2, float a2,\",\n      \"vec4 texture3, float a3, vec4 texture4, float a4)\",\n      \"{\",\n      \"float depth = 2.0;\",\n      \"float alphaMult = 1.0;\",\n      \"float alphaAdd  = 0.0;\",\n      \"a1 *= 4.0;\",\n      \"a2 *= 4.0;\",\n      \"a3 *= 4.0;\",\n      \"a4 *= 4.0;\",\n      \"a1 =  a1+(1.5+texture1.a);\",\n      \"a2 =  a2+(1.5+texture2.a);\",\n      \"a3 =  a3+(1.5+texture3.a);\",\n      \"a4 =  a4+(1.5+texture4.a);\",\n      \"float ma = max(a1,a2);\",\n      \"ma = max(ma,a3);\",\n      \"ma = max(ma,a4);\",\n      \"ma -= depth;\",\n      \"float b1 = max(a1 - ma, 0.0);\",\n      \"float b2 = max(a2 - ma, 0.0);\",\n      \"float b3 = max(a3 - ma, 0.0);\",\n      \"float b4 = max(a4 - ma, 0.0);\",\n      \"return (\",\n      \"texture1.rgb * b1 + texture2.rgb * b2 +\",\n      \"texture3.rgb * b3 + texture4.rgb * b4 \",\n      \") / (b1 + b2 + b3 + b4);\",\n      \"}\",\n\n      \"void main( void ) {\",\n      \"vec2 position = vUv*uvScale;\",\n      \"float edge = 1.0/1024.0;\",\n      \"vec2 compPos = edge + (vUv*0.25 + offset) * (1.0-edge*2.0);\",\n      \"vec4 tp1 = texture2D( texturePicker, compPos);\",\n      \"vec4 tp2 = texture2D( texturePicker2, compPos);\",\n      \"vec4 composite = tp1;\",\n      \"vec4 t1 = texture2D( texture1, position );\",\n      \"vec4 t2 = texture2D( texture2, position );\",\n      \"vec4 t3 = texture2D( texture3, position );\",\n      \"vec4 t4 = texture2D( texture4, position );\",\n      \"vec3 color = blend(\",\n      \"t1, tp1.a,\",\n      \"t2, tp1.b,\",\n      \"t3, tp1.g,\",\n      \"t4, tp1.r\",\n      \");\",\n      \"color *= 0.5+tp2.r;\",\n      \"gl_FragColor = vec4(color,1.0);\",\n      THREE.ShaderChunk[\"logdepthbuf_fragment\"],\n      \"}\"\n    ].join(\"\\n\");\n  },\n  getVertexShader: function() {\n    return [\n      \"varying vec2 vUv;\",\n      \"varying vec3 vecNormal;\",\n      THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"],\n      \"void main()\",\n      \"{\",\n\n      \"vUv =  uv;\",\n      \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n      \"vecNormal = (modelMatrix * vec4(normal, 0.0)).xyz;\",\n      \"gl_Position = projectionMatrix * mvPosition;\",\n      THREE.ShaderChunk[\"logdepthbuf_vertex\"],\n      \"}\"\n    ].join(\"\\n\");\n  }\n};\n","//require(\"../../../vendor/three/PointerLockControls\");\nvar SceneUtils = require(\"./SceneUtils\");\n\n\nvar velocity = new THREE.Vector3();\nvar moveUp = false;\nvar moveForward = false;\nvar moveBackward = false;\nvar moveLeft = false;\nvar moveRight = false;\nvar isOnObject = false;\nvar canJump = false;\nvar raycaster;\nvar controls;\nvar speed = 500;\nvar sensitivity = 500;\nvar bodyHeight = 70;\nvar isFly = true;\nvar mapReady = false;\n\nvar FlyControls = function(){\n\t///this. .. = \n\t//this.();\n};\n\nFlyControls.prototype.updateURL = function(){\n\t/// Write position to UI (fugly but whatevs)\n\tvar pos = controls.getObject().position;\n\t\n\tvar pitch =  Math.round(controls.getPitchObject().rotation.x*10000)/10000;\n\tvar yaw =   Math.round(controls.getObject().rotation.y*10000)/10000;\n\t\n\tvar mapFileName = $(\"#mapPicker\").val();\n\n\tvar positionURL = {\n\t\tmap: mapFileName,\n\t\tx: Math.round(pos.x*1000)/1000,\n\t\ty: Math.round(pos.y*1000)/1000,\n\t\tz: Math.round(pos.z*1000)/1000,\n\t\tpitch: pitch,\n\t\tyaw: yaw,\n\t\tloadZone: $(\"#loadZone\").prop(\"checked\"), \n\t\tloadProp: $(\"#loadProp\").prop(\"checked\"), \n\t\tshowHavok: $(\"#showHavok\").prop(\"checked\"),\n\t};\n\n\t//Write position to URL\n\twindow.location.hash = $.param(positionURL);\n\n}\n\nFlyControls.prototype.getControls=function(){\n\treturn controls;\n}\n\nFlyControls.prototype.setSpeed=function(value){\n\tspeed = value;\n}\n\nFlyControls.prototype.toggleFly=function(){\n\tisFly = !isFly;\n}\n\nFlyControls.prototype.setSensitivity=function(value){\n\tcontrols.setSensitivity(value);\n}\n\nFlyControls.prototype.invertMouse = function(){\n\tcontrols.invertMouse();\n};\n\nFlyControls.prototype.update=function(delta){\n\tif( controls.enabled ){\n\n\n\n\t\tvar underwater = controls.getObject().position.y<0;\n\n\t\tif(isFly || underwater){\n\t\t\t/// Free fly\n\t\t\tvar object = controls.getObject();\n\t\t\tvelocity.x = 0;\n\t\t\tvelocity.y = 0;\n\n\t\t\t// TODO: handle water better\n\t\t\tvelocity.z = 0;\n\n\t\t\t\n\t\t\tif( moveForward || moveBackward){\n\t\t\t\tvar dirSpeed = moveForward ? speed : -speed;\n\t\t\t\tcontrols.getDirection( velocity );\n\t\t\t\tvelocity.normalize();\n\t\t\t\t\n\t\t\t\t\n\t\t        //vector.applyEuler(camera.rotation, camera.rotation.order).normalize();\n\t\t        velocity.multiplyScalar(dirSpeed);\n\n\t\t        object.position.set(\n\t\t\t\tobject.position.x + velocity.x * delta,\n\t\t\t\tobject.position.y + velocity.y * delta,\n\t\t\t\tobject.position.z + velocity.z * delta);\n\t\t\t}\n\n\t\t\tif( moveLeft || moveRight){\n\t\t\t\tvar dirSpeed = moveRight ? speed : -speed;\n\t\t\t\tobject.translateX( dirSpeed * delta );\n\t\t\t}\n\n\t\t\tif(moveUp){\n\t\t\t\tcontrols.getObject().translateY( speed * delta );\n\t\t\t}\n\t\t} /// End if fly\n\n\t\telse{\n\t\t\t\n\t\t\t\n\t\t\tif ( moveForward ) \t\t\tvelocity.z = -speed;\n\t\t\telse if ( moveBackward ) \tvelocity.z = speed;\n\t\t\telse \t\t\t\t\t\tvelocity.z = 0;\n\n\t\t\tif ( moveLeft ) \t\t\tvelocity.x = -speed;\n\t\t\telse if ( moveRight ) \t\tvelocity.x = speed;\n\t\t\telse \t\t\t\t\t\tvelocity.x = 0;\n\n\t\t\n\t\t\tvar intersections;\n\n\t\t\t//if( velocity.y < 0 ){\n\t\t\t\traycaster.ray.origin.copy( controls.getObject().position );\n\t\t\t\t\n\t\t\t\t/// Check for object under us\n\t\t\t\tintersections = raycaster.intersectObjects( SceneUtils.getCollisions() );\n\n\t\t\t\t/// If there are any, valocity will be set to 0 or higher, if not gravity will pull\n\t\t\t\tisOnObject = intersections.length > 0;\n\t\t\t/*}\n\t\t\telse if( velocity.y > 0){\n\t\t\t\tisOnObject = false;\n\t\t\t}*/\n\n\t\t\n\t\t\tif ( isOnObject === true ) {\n\t\t\t\tvelocity.y = Math.max( 0, velocity.y );\n\n\t\t\t\t/// Move up to avoid sinking trough ground\n\t\t\t\tvar eps = 1;\n\t\t\t\tcontrols.getObject().translateY( bodyHeight - intersections[0].distance - eps);\n\n\t\t\t\t//canJump = true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvelocity.y -= speed * 2 * delta; \n\t\t\t}\n\n\t\t\tcontrols.getObject().translateX( velocity.x * delta );\n\t\t\tcontrols.getObject().translateY( velocity.y * delta );\n\t\t\tcontrols.getObject().translateZ( velocity.z * delta );\n\n\t\t}/// End if not fly\n\t\t\n\n\n\t\t\n\n\t\treturn true;\n\t}\n\n\treturn false;\n\n}\n\nFlyControls.prototype.lock=function(){\n\tvar element = document.body;\n\n\t// Ask the browser to lock the pointer\n\telement.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;\n\n\tif ( false &&  /Firefox/i.test( navigator.userAgent ) ) {\n\n\t\tvar fullscreenchange = function ( event ) {\n\n\t\t\tif ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {\n\n\t\t\t\tdocument.removeEventListener( 'fullscreenchange', fullscreenchange );\n\t\t\t\tdocument.removeEventListener( 'mozfullscreenchange', fullscreenchange );\n\n\t\t\t\telement.requestPointerLock();\n\t\t\t}\n\n\t\t}\n\n\t\tdocument.addEventListener( 'fullscreenchange', fullscreenchange, false );\n\t\tdocument.addEventListener( 'mozfullscreenchange', fullscreenchange, false );\n\n\t\telement.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;\n\n\t\telement.requestFullscreen();\n\n\t} else {\n\n\t\telement.requestPointerLock();\n\n\t}\n}\n\nFlyControls.prototype.setMapReady=function(value){\n\tmapReady = value;\n};\n\nFlyControls.prototype.init=function(){\n\tvar havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;\n\n\tif ( havePointerLock ) {\n\n\t\tvar self = this;\n\t\tvar element = document.body;\n\n\t\tdocument.exitPointerLock = document.exitPointerLock ||\n\t\t\t   document.mozExitPointerLock ||\n\t\t\t   document.webkitExitPointerLock;\n\t\t\n\n\t\tvar pointerlockchange = function ( event ) {\n\n\t\t\tif(!mapReady)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tif ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {\n\n\t\t\t\tcontrolsEnabled = true;\n\t\t\t\tcontrols.enabled = true;\n\n\t\t\t\t$(\"#output\").fadeOut(300);\n\n\n\t\t\t} else {\n\t\t\t\t$(\"#output\").fadeIn(300);\n\n\t\t\t\tself.updateURL();\n\n\t\t\t\tcontrols.enabled = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar pointerlockerror = function ( event ) {\n\t\t\t//instructions.style.display = '';\n\n\t\t}\n\n\t\t// Hook pointer lock state change events\n\t\tdocument.addEventListener( 'pointerlockchange', pointerlockchange, false );\n\t\tdocument.addEventListener( 'mozpointerlockchange', pointerlockchange, false );\n\t\tdocument.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );\n\n\t\tdocument.addEventListener( 'pointerlockerror', pointerlockerror, false );\n\t\tdocument.addEventListener( 'mozpointerlockerror', pointerlockerror, false );\n\t\tdocument.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );\n\n\t\tSceneUtils.getRenderer().domElement.addEventListener( 'mousedown', function ( event ) {\n\t\t\tif(mapReady)\n\t\t\t\tself.lock();\n\t\t}, false );\n\t\t$(\"#outputWrapper\").on( 'mousedown', function ( event ) {\n\t\t\tif(mapReady)\n\t\t\t\tself.lock();\n\t\t});\n\n\t\tdocument.addEventListener( 'mouseup', function ( event ) {\n\t\t\tdocument.exitPointerLock();\n\t\t\tcontrols.enabled = false;\n\t\t}, false );\n\n\t\t\n\n\t} else {\n\n\t\treturn false;\n\n\t}\n\n    controls = new THREE.PointerLockControls( SceneUtils.getCamera(), 0.002 );\n    \t\n\tSceneUtils.getScene().add( controls.getObject() );\n\n    var onKeyDown = function ( event ) {\n\n\t\tswitch ( event.keyCode ) {\n\n\t\t\tcase 38: // up\n\t\t\tcase 87: // w\n\t\t\t\tmoveForward = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 37: // left\n\t\t\tcase 65: // a\n\t\t\t\tmoveLeft = true; break;\n\n\t\t\tcase 40: // down\n\t\t\tcase 83: // s\n\t\t\t\tmoveBackward = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 39: // right\n\t\t\tcase 68: // d\n\t\t\t\tmoveRight = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 32: // space\n\t\t\t\t// Used fo moving up in fly mode and jumping in FPS mode\n\t\t\t\tmoveUp = true;\n\t\t\t\t\n\t\t\t\t// Used for jumping in non-fly mode\n\t\t\t\tif ( canJump === true ){\n\t\t\t\t\tvelocity.y += speed;\n\t\t\t\t\tcanJump = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t}\n\n\t};\n\n\tvar onKeyUp = function ( event ) {\n\n\t\tswitch( event.keyCode ) {\n\n\t\t\tcase 38: // up\n\t\t\tcase 87: // w\n\t\t\t\tmoveForward = false;\n\t\t\t\tbreak;\n\n\t\t\tcase 37: // left\n\t\t\tcase 65: // a\n\t\t\t\tmoveLeft = false;\n\t\t\t\tbreak;\n\n\t\t\tcase 40: // down\n\t\t\tcase 83: // s\n\t\t\t\tmoveBackward = false;\n\t\t\t\tbreak;\n\n\t\t\tcase 39: // right\n\t\t\tcase 68: // d\n\t\t\t\tmoveRight = false;\n\t\t\t\tbreak;\n\n\t\t\tcase 32: // space\n\t\t\t\tmoveUp = false;\n\t\t\t\t//Allowing tapping space to mid air jump again\n\t\t\t\tcanJump = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t};\n\n\tdocument.addEventListener( 'keydown', onKeyDown, false );\n\tdocument.addEventListener( 'keyup', onKeyUp, false );\n\n\traycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, bodyHeight );\n\n\treturn true;\n\t\n};\n\n\nmodule.exports = FlyControls;","var cameraOpts = {\n\tfov : 60,\tnear : 10, foglength:5000\n};\n\nvar scene, skyScene;\nvar camera, oCamera;\nvar currentCamera, skyCamera; \nvar renderer = null;\n\nvar collisions = [];\nvar nonCollisions = [];\nvar terrainChunks = [];\nvar lights = [];\n\nvar skyObjects = [];\n\nvar fogDistance = 0;\n\nvar renderCounter = 0;\n\nfunction traverseLODs( object ) {\n\tif ( object instanceof THREE.LOD ) {\n\t\tobject.update( camera );\n\t}\n}\n\nmodule.exports = {\n\tsetupScene : function() {\n\t\t/// Create scene instance\n\t\tscene = new THREE.Scene();\n\t\tskyScene = new THREE.Scene();\n\n\t\t/// Create a camera, aim and place it.\n\t\tvar sceneWidth = window.innerWidth;// -  $(\"#UI\").width();\n\n\t\tcurrentCamera = camera = new THREE.PerspectiveCamera(cameraOpts.fov,\n\t\t\tsceneWidth / window.innerHeight,\n\t\t\tcameraOpts.near, fogDistance );\n\n\t\tskyCamera = new THREE.PerspectiveCamera(cameraOpts.fov,\n\t\t\tsceneWidth / window.innerHeight,\n\t\t\tcameraOpts.near, 1000000);\n\t\t\t\n\t\t\t\t\n\n\t\t/// Add ambient lighting\n\t\t\n\t\tvar globalAmbient = new THREE.AmbientLight(0);\n\t\tscene.add(globalAmbient);\n\t\t\n\n\t\tvar directionalLight = new THREE.DirectionalLight( 0xffffff, 0.7 );\n\t\tdirectionalLight.position.set( 0, 0, 1 );\n\t\tscene.add( directionalLight );\n\t\t\n\n\t\tvar directionalLight = new THREE.DirectionalLight( 0xffffff, 0.3 );\n\t\tdirectionalLight.position.set( -1, 1, -1 );\n\t\tscene.add( directionalLight );\n\n\t\t//Fog\n\t\tscene.fog = new THREE.Fog(0xffffff, Math.max(1,fogDistance - cameraOpts.foglength), fogDistance);\n\n\t\t// LOD updates scene by itself before render is called, don't do it twice!\n\t\t//scene.matrixAutoUpdate = false;\n\t\t//scene.autoUpdate = false;\n\t\t\n\t\t/// Create canvas rendering output\n\t\trenderer = new THREE.WebGLRenderer({\n\t\t\t/*alpha:true*/\n\t\t\tsortObjects:false,\n\t\t\tstencil:false,\n\t\t\tpremultipliedAlpha:false,\n\t\t\tantialiasing: true ,\n\t\t\t//preserveDrawingBuffer:true\n\t\t});\n\t\trenderer.sortObjects = false;\n\t\trenderer.setSize(sceneWidth, window.innerHeight);\n\n\t\trenderer.autoClear = false;\n\n\t\trenderer.domElement.style.position = \"absolute\";\n\n\t\t/// Add renderer to html DOM\n\t\tdocument.body.appendChild(renderer.domElement);\n\n\t\t/// Listen to window size chaning\n\t\t$( window ).resize(this.resize);\n\n\t\tthis.render();\n\n\n\t},\n\n\tsetPerspective: function(){\n\t\tcurrentCamera = camera;\n\t\tthis.render();\n\t},\n\n\tsetOrthographic: function(l,r,t,b,n,f){\n\n\t\tvar sceneWidth = window.innerWidth;// -  ( $(\"#UI\").is(\":visible\") && $(\"#UI\").width() );\n\n\t\tvar aspect = sceneWidth / window.innerHeight;\n\n\t\tvar dx = Math.abs(l-r);\n\t\tvar dy = Math.abs(t-b);\n\n\t\tif( dx/dy < aspect ){\n\t\t\tvar targetDx = dy * aspect;\n\t\t\tvar fac = targetDx/(1.0*dx);\n\t\t\tl *= fac;\n\t\t\tr *= fac;\t\n\t\t}\n\t\telse{\n\t\t\tvar targetDy = dx / aspect;\n\t\t\tvar fac = targetDy/(1.0*dy);\n\t\t\tt *= fac;\n\t\t\tb *= fac;\t\n\t\t}\n\t\t\n\t\t///Margin\n\t\tvar m = 1.01;\n\t\tl*=m; r*=m; t*=m; b*=m;\n\n\t\toCamera = new THREE.OrthographicCamera(l,r,t,b,n,f);\n\t\toCamera.position.set( 0*(l+r)/2.0, -f/2.0, 0*(t+b)/2.0 );\n\t\toCamera.rotation.set(Math.PI/2.0,0,0,\"YXZ\");\t\t\n\n\t\t//this.applyCameraRotationTo(oCamera);\n\n\t\tcurrentCamera = oCamera;\n\n\t\tthis.render();\n\n\t},\n\n\tsetHSLa: function(h,s,l,a){\n\t\tvar dh = 0.2;\n\t\tfor(var i=0; i<5; i++){\n\t\t\tif(lights[i]){\n\t\t\t\tlights[i].color.setHSL(h,s,l);\n\t\t\t\tlights[i].intensity = a;\n\t\t\t\th=(h+dh)%1;\t\n\t\t\t}\n\t\t}\n\t},\n\n\tsetRenderVisible: function(value){\n\t\tif(value)\n\t\t\trenderer.domElement.style.display = \"block\";\n\t\telse\n\t\t\trenderer.domElement.style.display = \"none\";\n\t},\n\n\tapplyCameraRotationTo: function(o){\n\t\tif(camera.parent){\n\t\t\tvar rx = camera.parent.rotation.x;\n\t\t\tvar ry = camera.parent.parent.rotation.y;\n\t\t\to.rotation.set(rx,ry,0,\"YXZ\");\t\t\n\t\t}\n\t},\n\n\trender: function(){\n\t\tif(renderer !== null){\n\n\t\t\t/// Always update matrix\n\t\t\t//scene.updateMatrixWorld();\n\n\t\t\t/// Only calculate distances every n:th render\n\t\t\tif(++renderCounter == 10){\n\t\t\t\trenderCounter = 0;\n\t\t\t\tscene.traverse( traverseLODs );\n\t\t\t}\n\n\n\t\t\trenderer.clear(renderer.getClearColor());\n\n\t\t\t/// Render skybox\n\t\t\tif(camera == currentCamera){\n\t\t\t\tthis.applyCameraRotationTo(skyCamera);\n\t\t\t\trenderer.render(skyScene, skyCamera);\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//this.applyCameraRotationTo(oCamera);\t\n\t\t\t}\n\n\t\t    /// Render everything else\n\t\t\trenderer.render(scene, currentCamera);\n\t\t}\n\t},\n\n\tclear: function(){\n\n\t\tcollisions.forEach(function(elem){\n\t\t\tscene.remove(elem);\n\t\t});\n\n\t\tnonCollisions.forEach(function(elem){\n\t\t\tscene.remove(elem);\n\t\t});\n\n\t\tlights.forEach(function(elem){\n\t\t\tscene.remove(elem);\n\t\t});\n\n\t\tskyObjects.forEach(function(elem){\n\t\t\tskyScene.remove(elem);\n\t\t});\n\t\t\n\t\tnonCollisions = [];\n\t\tcollisions = [];\n\t\tlights = [];\n\t\tskyObjects = [];\n\t\tterrainChunks = [];\n\t},\n\n\tresize: function(){\n\t\tvar sceneWidth = window.innerWidth;//-  ( $(\"#UI\").is(\":visible\") && $(\"#UI\").width() );\n\n\t\tcamera.aspect = sceneWidth / window.innerHeight;\n\t\tskyCamera.aspect = sceneWidth / window.innerHeight;\n\n\t\trenderer.setSize(sceneWidth, window.innerHeight);\n\n\t\tcamera.updateProjectionMatrix();\n\t\tskyCamera.updateProjectionMatrix();\n\n\n\t\tmodule.exports.render();\n\t},\n\n\tsetAmbientAdd: function(value){\n\t\tlights.forEach(\n\t\t\tfunction(elem){\n\t\t\t\tvar v = value;\n\t\t\t\tif(elem.added){\n\t\t\t\t\tv -= elem.added;\n\t\t\t\t}\n\t\t\t\tif(elem instanceof THREE.AmbientLight){\n\t\t\t\t\telem.color.addScalar(v);\n\t\t\t\t}\n\t\t\t\telem.added = value;\n\t\t\t}\n\t\t);\n\t\tmodule.exports.render();\n\t},\n\n\tsetFog: function(distance){\n\t\tfogDistance = distance;\n\t\tif(scene && scene.fog){\n\t\t\tscene.fog.far = distance;\n\t\t\tscene.fog.near = Math.max(1,distance - cameraOpts.foglength);\n\t\t}\n\t\tif(camera){\n\t\t\tcamera.far = distance;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t/// Update terrain material\n\t\t\tterrainChunks.forEach(function(mesh){\n\t\t\t\tmesh.material.uniforms[\"fogNear\"].value = scene.fog.near;\n\t\t\t\tmesh.material.uniforms[\"fogFar\"].value = scene.fog.far;\n\t\t\t\tmesh.material.needsUpdate = true;\n\t\t\t})\n\t\t}\n\t\tthis.render();\n\t\t\n\t},\n\n\tshowProgressPanel: function(cb){\n\t\tvar pp = $(\"#progressPanel\");\n\n\t\tif(pp.is(\":visible\")){\n\t\t\tif(cb)\n\t\t\t\tcb();\n\t\t\treturn;\n\t\t}\n\n\t\tpp.find(\".progressTitle\").html(\"Loading\");\n\t\tpp.find(\".progress\").html(\"...\");\n\n\t\tthis.showPanel(pp, cb);\n\t},\n\n\tshowMapPanel: function(cb){\n\t\tthis.showPanel($(\"#mapPanel\"), cb);\n\t},\n\n\tshowPanel: function(panelIn, cb){\n\t\tvar currentPanel = $(\"#output\").find(\".ui-panel:visible\");\n\n\t\tthis.swapPanels(currentPanel, panelIn, true, cb);\n\n\t},\n\n\tswapPanels: function(panelOut, panelIn, dir, cb){\n\t\tvar t = 400 * 0;\n\t\tvar ease = \"swing\";\n\n\t\t/// Fix height\n\t\tpanelOut.parent().css({height:panelOut.parent().height()});\n\t\tpanelIn.removeClass(\"hidden\");\n\t\tvar h = panelIn.height();\n\t\tpanelIn.addClass(\"hidden\");\n\n\n\t\t/// Set slide in start values\n\t\tpanelIn.css({right:dir?-500:'auto', left:dir?'auto':-500});\n\n\t\t\n\t\t/// Current element slide out\n\t\tpanelOut.css({right:dir?-500:'auto'});\n\n\t\tvar animateOutProp, animateInProp;\n\t\tif(dir){\n\t\t\tanimateOutProp = {left:-500};\n\t\t\tanimateInProp = {right:0};\n\t\t}\n\t\telse{\n\t\t\tanimateOutProp = {right:-500};\n\t\t\tanimateInProp = {left:0};\n\n\t\t}\n\n\t\tpanelOut.animate(animateOutProp, t, ease, function(){\n\n\t\t\t/// Hide Current element\n\t\t\tpanelOut.addClass(\"hidden\");\n\n\t\t\t/// Parent height\n\t\t\tpanelOut.parent().animate({height:h}, t/2.0, ease, function(){\t\t\t\n\n\t\t\t\t/// Slide in next element\n\t\t\t\tpanelIn.removeClass(\"hidden\");\n\t\t\t\tpanelIn.animate(animateInProp, t, ease, cb);\n\n\t\t\t});\n\n\t\t});\n\t},\n\n\tgetScene: function(){ return scene; },\n\tgetSkyScene: function(){ return skyScene; },\n\tgetCamera: function(){ return camera; },\n\tgetRenderer: function(){ return renderer; },\n\tgetCollisions: function(){ return collisions; },\n\tgetNonCollisions: function(){ return nonCollisions; },\n\tgetTerrainChunks: function(){ return terrainChunks; },\n\tgetSkyObjects: function(){ return skyObjects; },\n\tgetLights: function(){ return lights; }\n}; \n","///  ----- Includes  ----- \nvar UI =  require(\"./UI.js\");\nvar SceneUtils = require(\"./SceneUtils.js\");\nvar FlyControls =  require(\"./FlyControls.js\");\nvar T3D = require(\"t3d-lib\");\n\n\n/**\n * Tyria 3D Web application\n * \n * The tyria3d.com web UI\n *\n * @main Tyria3DApp\n * @class Tyria3DApp\n * @static \n */\nvar Tyria3DApp = module.exports = function() {\n\n\tthis.map;\n\tthis.stats;\n\tthis.controller;\n\tthis.hasPointerLock;\n\tthis.ui;\n\n\tthis.lastTs = -1;\n\tthis.animating = false;\n\tthis.localReader = null;\n\tthis._mapRect = null;\n\tthis.mapAutoLoad = null;\n\n\tthis.animationTime = 350 * 0;\n\n\t/// Run UI stuff when document is rdy\n\t$(document).ready(this.onDocumentReady.bind(this));\n\n\t/**\n\t * @method initAnim\n\t */\n\tthis.initAnim = function(){\n\t\tvar self =  this;\n\t\t$(\".content  h1\").first().animate({\"margin-top\":20}, self.animationTime);\n\t\t$(\"nav\").slideUp(self.animationTime,function(){\n\t\t\t$(\"#intro\").delay(self.animationTime).fadeOut(self.animationTime,self.init.bind(self));\n\t\t});\n\t}\n\n\t/**\n\t * @method init\n\t */\n\tthis.init = function(){\n\t\tvar self = this;\n\n\t\tthis.mapAutoLoad = parseUri(window.location.hash.slice(1));\n\t\tconsole.log(this.mapAutoLoad);\n\n\t\t// Hide intro div\n\t\t$(\"#intro\").hide();\t\n\n\t\t/// Add stats (toggled by pressing \"i\")\n\t\tthis.stats = new Stats();\n\t\t$(\"body\").append( this.stats.domElement );\n\n\t\t/// Create fly controls, initare after UI DOM has been added.\n\t\tthis.controller = new FlyControls();\n\n\t\t/// Set up UI\n\t\tthis.ui = new UI( $(\"body\"), this.controller, this.loadMap.bind(self) );\n\t\tthis.ui.init();\n\n\t\t/// Create file picker, used to pick DAT file\n\t\tvar filePicker = $(\"<input type='file' class='hidden' />\");\n\t\tvar fileIcon = $(\"<button id='fileInputIcon' tabindex='-1'>Select a Guild Wars 2 .dat file</button>\");\n\t\tfileIcon.click(function () {\n\t\t    filePicker.trigger('click');\n\t\t});\n\t\t\n\t\t/// .dat file received from the file input, entry point!\n\t\tvar onReceiveFile = function(evt){\n\t\t\t\n\t\t\t/// Get loaded file reference from event\n\t\t\t///TODO: Check file length etc.\n\t\t\tvar files = evt.target.files;\n\t\t\tvar file = files[0];\n\n\t\t\tfilePicker.val('');\n\t\t\t\n\t\t\t/// Get a local reader\n\t\t\tself.localReader = T3D.getLocalReader(file, function(){\n\t\t\t\t\n\t\t\t\t/// Get the maps in the dat and put them in the UI.\n\t\t\t\t/// Show progress panel during load.\n\t\t\t\tSceneUtils.showProgressPanel(function(){\t\t\n\t\t\t\n\t\t\t\t\t$(\"#output\").find(\".progressTitle\").html(\"Finding maps (first visit only)\");\n\t\t\t\t\t$(\"#output\").find(\".progress\").html(\"initializing\");\n\n\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\t\tT3D.getMapListAsync(self.localReader, self.applyMapList.bind(self), false);\n\t\t\t\t\t},10);\n\t\t\t\t});\n\t\t\t}, undefined, undefined, \"js/T3D/t3dworker.js\");\n\n\t\t\t// SAVE MAP CODE WAS HERE\n\n\t\t};\n\n\t\t/// Add listener to file input\n\t\tfilePicker.change(onReceiveFile);\n\n\t\t/// Append file input elements to the DOM\n\t\t$(\"#filePanel\").append(filePicker);\n\t\t$(\"#filePanel\").append(fileIcon);\n\n\t\t/// Build deep map search interface\n\t\tvar deepSearchButton = $(\"<span class='link'>Scan all .dat entries for maps</span>\");\n\t\tdeepSearchButton.click( function(evt){\n\t\t\tif ( confirm(\n\t\t\t\t\t\"Searching the full .dat file will take roughly 10 minutes depending on file size.\\n\\n\"+\n\t\t\t\t\t\"Once complete the results will be stored locally and available every time you load this .dat.\\n\\n\"+\n\t\t\t\t\t\"Note that the vast majority of maps are probably already loaded.\"+\n\t\t\t\t\t\"Are you sure you want to search the .dat for maps?\"\n\t\t\t\t) ) {\n\n\t\t\t\tSceneUtils.showProgressPanel(function(){\t\t\n\t\t\t\n\t\t\t\t\t$(\"#output\").find(\".progressTitle\").html(\"Finding maps (first visit only)\");\n\t\t\t\t\t$(\"#output\").find(\".progress\").html(\"initializing\");\n\n\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\t\tT3D.getMapListAsync(self.localReader, self.applyMapList, true);\n\t\t\t\t\t},10);\n\t\t\t\t});\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t} );\n\n\t\t/// Append deep search elements to the DOM\n\t\tvar searchParagraph = $(\"<p class='instruction'>Missing maps? </p>\");\n\t\tsearchParagraph.append(deepSearchButton);\n\t\t$(\"#mapPanel\").append(searchParagraph);\n\n\t\t/// Key listeners connected to UI (toggle UI panel and stats)\n\t\tdocument.addEventListener( 'keydown', this.keyDownListener, false );\n\t\tdocument.addEventListener('mousewheel',this.mouseWheelListener, false); \n\n\t\t/// Set up scene holding visible objects, lights, camera and renderer.\n\t\tSceneUtils.setupScene();\n\n\t\t/// Keep rendered hidden until map is ready to render.\n\t\tSceneUtils.setRenderVisible(false);\n\t\t\n\t\t/// Initiate controlls, connection them to the scene.\n\t\tthis.hasPointerLock = this.controller.init();\n\n\t};\n\n\n\n\t/**\n\t * Called when a map is specified via the drop down\n\t * @method loadMap\n\t * @param  {[type]} fileName [description]\n\t * @param  {[type]} absolute [description]\n\t * @return {[type]}          [description]\n\t */\n\tthis.loadMap = function(fileName, absolute){\n\n\t\tvar self = this;\n\t\t\n\t\tvar showHavok;\n\t\tif( self.mapAutoLoad.showHavok != undefined ) {\n\t\t\tshowHavok = self.mapAutoLoad.showHavok;\n\t\t\t$(\"#showHavok\").prop(\"checked\", showHavok);\n\t\t} else {\n\t\t\tshowHavok = $(\"#showHavok\").prop(\"checked\");\n\t\t}\n\n\t\tvar loadProp;\n\t\tif( self.mapAutoLoad.loadProp != undefined ) {\n\t\t\tloadProp = self.mapAutoLoad.loadProp;\n\t\t\t$(\"#loadProp\").prop(\"checked\", loadProp);\n\t\t} else {\n\t\t\tloadProp = $(\"#loadProp\").prop(\"checked\");\n\t\t}\n\t\t\t\n\t\tvar loadZone;\n\t\tif( self.mapAutoLoad.loadZone != undefined ) {\n\t\t\tloadZone = self.mapAutoLoad.loadZone;\n\t\t\t$(\"#loadZone\").prop(\"checked\", loadZone);\n\t\t} else {\n\t\t\tloadZone = $(\"#loadZone\").prop(\"checked\");\n\t\t}\n\n\t\t/// Pop up the progres panel\n\t\tSceneUtils.showProgressPanel(function(){\n\n\t\t\t/// Disable controller and hide rendered during load\n\t\t\tself.controller.setMapReady(false);\n\t\t\tSceneUtils.setRenderVisible(false);\n\n\t\t\t/// Set up renderers\n\t\t\tvar renderers = [\n\t\t\t\t{\n\t\t\t\t\trenderClass: T3D.HavokRenderer,\n\t\t\t\t\tsettings:{\n\t\t\t\t\t\tvisible: showHavok\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\trenderClass: T3D.EnvironmentRenderer,\n\t\t\t\t\tsettings:{}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\trenderClass: T3D.TerrainRenderer,\n\t\t\t\t\tsettings:{\n\t\t\t\t\t\tanisotropy : SceneUtils.getRenderer().getMaxAnisotropy()\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t];\n\n\t\t    if( loadZone ){\n\t\t    \trenderers.push({\n\t\t    \t\trenderClass: T3D.ZoneRenderer,\n\t\t    \t\tsettings:{}\n\t\t    \t});\n\t\t    }\n\t\t    if( loadProp ){\n\t\t    \trenderers.push({\n\t\t    \t\trenderClass: T3D.PropertiesRenderer,\n\t\t    \t\tsettings:{}\n\t\t    \t});\n\t\t    }\n\n\t\t\t/// Call map renderer in order to get all 3d objects\n\t\t\tT3D.renderMapContentsAsync(self.localReader, fileName, renderers, self.onMapLoaded.bind(self));\n\n\t\t});\t\n\t}\n\n\t/**\n\t * Callback to transfer the parsed data to three-js\n\t * @return {void}\n\t */\n\tthis.onMapLoaded = function(mapData){\n\t\t/// Clear scene\n\t\tSceneUtils.clear();\n\n\t\t//ZoneRenderer\n\t\tif(mapData.ZoneRenderer != undefined){\n\t\t\tmapData.ZoneRenderer.meshes.forEach(function(elem){\n\t\t\t\tSceneUtils.getScene().add(elem); //Visible\n\t\t\t\tSceneUtils.getNonCollisions().push(elem);\n\t\t\t});\t\n\t\t}\n\n\t\t//PropertiesRenderer\n\t\tif(mapData.PropertiesRenderer != undefined){\n\t\t\tmapData.PropertiesRenderer.meshes.forEach(function(elem){\n\t\t\t\tSceneUtils.getScene().add(elem); //Visible\n\t\t\t\tSceneUtils.getNonCollisions().push(elem);\n\t\t\t});\t\n\t\t}\n\n\t\tmapData.EnvironmentRenderer.skyElements.forEach(function(elem){\n\t\t\tSceneUtils.getSkyScene().add(elem);\n\t\t\tSceneUtils.getSkyObjects().push(elem);\n\t\t});\t\t\n\t\t\n\t\t/// Add terrain tiles to a special list\n\t\t/// ( these need their fog updated in a specific way ).\n\t\tmapData.TerrainRenderer.terrainTiles.forEach(function(elem){\n\t\t\tSceneUtils.getScene().add(elem); //Visible\n\t\t\tSceneUtils.getTerrainChunks().push(elem); //Terrain\n\t\t\tSceneUtils.getCollisions().push(elem); //Collision\n\t\t});\t\n\n\t\tSceneUtils.getScene().add(mapData.TerrainRenderer.water);\n\t\tSceneUtils.getNonCollisions().push(mapData.TerrainRenderer.water); //Water\n\n\t\t/// Add all collisions to a special list\n\t\tif(mapData.HavokRenderer != undefined){\n\t\t\tmapData.HavokRenderer.meshes.forEach(function(elem){\n\t\t\t\tSceneUtils.getScene().add(elem);\n\t\t\t\tSceneUtils.getCollisions().push(elem);\n\t\t\t});\n\t\t}\n\n\t\t/// Add lights\n\t\tmapData.EnvironmentRenderer.lights.forEach(function(elem){\n\t\t\tSceneUtils.getScene().add(elem);\n\t\t\tSceneUtils.getLights().push(elem);\n\t\t});\n\n\t\t/// Set haze color \n\t\tvar hazeColor = mapData.EnvironmentRenderer.hazeColor;\n\t\tvar color = new THREE.Color(hazeColor[2]/255.0, hazeColor[1]/255.0, hazeColor[0]/255.0);\n\t\tSceneUtils.getRenderer().setClearColor( color, 1.0 );\n\t\tSceneUtils.getScene().fog.color.copy(color);\n\n\t\t/// Store bounds locally in order to display orto cam correctly\n\t\t_mapRect = mapData.TerrainRenderer.bounds;\n\n\t\t/// Enable UI\n\t\tthis.controller.setMapReady(true);\n\t\t$(\"#UI\").removeClass(\"hidden\");\n\n\t\t/// Set ambient light slider to 50% if there were no parsed lights in the map data.\n\t\t$(\"#ambientSlider\").slider(\"value\",mapData.EnvironmentRenderer.hasLight ? 0 : 0.5);\n\n\t\t/// Set view dist after all objects are in place\n\t\t$(\"#fogSlider\").slider(\"value\",35000);\n\n\t\t/// Data Renderer is done start animating!\n\t\tif(this.hasPointerLock){\n\t\t\tSceneUtils.showPanel($(\"#suspendedPanel\"));\n\t\t}\n\t\telse{\n\t\t\tSceneUtils.showPanel($(\"#errorPanel\"));\n\t\t}\n\t\t\n\t\t/// Set camera position\n\t\tvar controls = this.controller.getControls();\n\t\tcontrols.getObject().position.set(0, mapData.TerrainRenderer.bounds ? mapData.TerrainRenderer.bounds.y2 : 0, 0);\n\t\tcontrols.getPitchObject().rotation.x = -Math.PI/2;\n\t\t\n\t\t//Replace camera from autoload\n\t\tif(this.mapAutoLoad.x != undefined && this.mapAutoLoad.y != undefined && this.mapAutoLoad.z != undefined) {\n\t\t\tcontrols.getObject().position.set(this.mapAutoLoad.x, this.mapAutoLoad.y, this.mapAutoLoad.z);\n\t\t}\n\t\tif(this.mapAutoLoad.yaw != undefined && this.mapAutoLoad.pitch != undefined) {\n\t\t\tcontrols.getPitchObject().rotation.x = this.mapAutoLoad.pitch;\n\t\t\tcontrols.getObject().rotation.y = this.mapAutoLoad.yaw;\n\t\t}\n\n\t\t//Clean the autoload\n\t\tthis.mapAutoLoad = {};\n\n\t\t// Initial render, indep. of controller being active\n\t\tSceneUtils.render();\n\n\n\t\t// Show canvas\n\t\tSceneUtils.setRenderVisible(true);\n\n\t\t/// Animate scene\n\t\tif(!this.animating){\n\t\t\tthis.animating = true;\n\t\t\tthis.animate(0);\t\n\t\t}\n\n\t\tthis.controller.updateURL();\n\n\t}//End onload callback\n\n\n\t/**\n\t * @method  applyMapList\n\t * @param  {[type]} mapList [description]\n\t * @return {[type]}         [description]\n\t */\n\tthis.applyMapList = function(mapList){\n\t\tvar self = this;\n\n\t\tthis.mapAutoLoad = parseUri(window.location.hash.slice(1));\n\n\t\t/// Update picker elements\n\t\tvar picker = $(\"#mapPicker\");\n\t\tpicker.empty();\n\t\tpicker.append($(\"<option selected='true' disabled='disabled'>Pick Map</option>\")); \n\t\t\n\n\t\tvar compareName = function(a, b) {\n\t\t\tif (a.name < b.name)\n\t\t\t    return -1;\n\t\t\tif (a.name > b.name)\n\t\t\t    return 1;\n\t\t\treturn 0;\n\t\t};\n\n\t\tmapList.maps.sort(compareName);\n\t\t\n\t\tmapList.maps.forEach(function(g){\n\t\t\tvar group = $(\"<optgroup label='\"+g.name+\"' />\");\n\t\t\tpicker.append(group);\n\n\t\t\tg.maps.sort(compareName);\n\t\t\tg.maps.forEach(function(m){\n\t\t\t\tgroup.append(\"<option value='\"+m.fileName+\"'>\"+m.name+\"</option>\");\n\t\t\t});\n\t\t\t\n\t\t});\n\n\t\tSceneUtils.showMapPanel();\n\t\t\n\t\t//If there is some map autoloading we check if the map have been detected then trigger the load event\n\t\tif(self.mapAutoLoad['map'] != undefined){\n\t\t\t$(\"#mapPicker option\").each(function(){\n\t\t\t\tif(self.mapAutoLoad['map'] == this.value){\n\t\t\t\t\tvar e = $.Event(\"change\");\n\t\t\t\t\t$(\"#mapPicker\").val(this.value);\n\t\t\t\t\t$(\"#mapPicker\").trigger(e);\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tthis.mouseWheelListener = function(evt){\n\t\tvar dir = Math.sign(evt.wheelDelta);\n\t\tvar s = $(\"#moveSpeedSlider\");\n\t\tvar min =  s.slider(\"option\",\"min\")\n\t\tvar max = s.slider(\"option\",\"max\") \n\t\tvar range =max - min;\n\t\t\n\t\tvar val = range*dir*0.05 + s.slider( \"option\", \"value\" );\n\t\tval = Math.min(max,val);\n\t\tval = Math.max(min,val);\n\n\t\ts.slider(\"option\", \"value\", val);\n\t}\n\n\t/**\n\t * Main \"game\" loop, called trough requestAnimationFrame\n\t * @param  {[type]} timestamp [description]\n\t * @return {[type]}           [description]\n\t */\n\tthis.animate = function(timestamp) {\n\t\t\n\t\t/// Get time step\n\t\tvar delta = timestamp - this.lastTs;\n\t\tif(delta > 0){\n\t\t\t\n\t\t\tthis.lastTs = timestamp;\n\n\t\t\t/// Update current controller\n\t\t\tif( this.controller.update(delta*0.001) ){\n\n\t\t\t\t/// If controller returns true, render\n\t\t\t\tSceneUtils.render();\n\t\t\t}\n\n\t\t\t/// Update stats (FPS etc)\n\t\t\tthis.stats.update();\n\n\t\t}\n\n\t\twindow.requestAnimationFrame( this.animate.bind(this) );\n\t}\n\n\t/**\n\t * Settings and debugging key listener\n\t * @method keyDownListener\n\t * @param  {[type]} evt [description]\n\t * @return {[type]}     [description]\n\t */\n\tthis.keyDownListener = function(evt){\n\t\tif(evt.keyCode == 85){ // U\n\t\t\t$(\"#UI\").toggle();\n\t\t\tSceneUtils.resize();\n\t\t}\n\t\tif(evt.keyCode == 73){ // I\n\t\t\t$(\"#stats\").toggle();\n\t\t}\n\t\tif(evt.keyCode == 80){ // P\n\t\t\tSceneUtils.setPerspective();\n\t\t}\n\t\tif(evt.keyCode == 79){ // O\n\n\t\t\tvar r = _mapRect;\n\t\t\tif(r){\n\t\t\t\tvar xMin = r.x1;\n\t\t\t\tvar xMax = r.x2;\n\t\t\t\tvar yMin = r.y1;\n\t\t\t\tvar yMax = r.y2;\n\t\t\t\tSceneUtils.setOrthographic(xMin, xMax, yMin, yMax, 100000, -100000);\n\t\t\t}\n\t\t}\n\t\tif(evt.keyCode == 70){ // F\n\t\t\t$(\"#flyInput\").trigger('click');\n\t\t}\n\t}\n\n}\n\n\nTyria3DApp.prototype.onDocumentReady = function(){\n\n\tconsole.log(\"Tyria 3D API version \"+T3D.version);\n\tvar self = this;\n\n\t/// Detect Chrome and WebGL\n\t//var is_chrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;\n\tvar hasWebGL = T3D.hasWebGL();\n\n\t/// Hide blinking loader\n\t$(\"#frontpageLoader\").addClass(\"hidden\");\n\n\t/// Display error message for missing WebGL\n\tif (!window.WebGLRenderingContext || !hasWebGL) {\n    \t$(\"#errorGL\").removeClass(\"hidden\");\n  \t}\n\n  \t/// Display error message for non-Chrome browsers\n  \t// else if(!is_chrome){\n  \t// \t$(\"#errorChrome\").removeClass(\"hidden\");\n  \t// }\n\n  \t/// If everyting is ok, enable the button that shows the file picker.\n  \telse{\n\t\tif(window.location.hash.length > 1 ){\n\t\t\tself.initAnim();\n\t\t}\n\t\t$(\"#ILoveYouDiddi\").removeClass(\"hidden\").one(\"click\",self.initAnim.bind(self));\n  \t}\n}\n\nfunction parseUri(uri){\n\tvar data = uri.split(\"&\");\n\tvar result = {};\n\tif(uri.length < 1) { return result; };\n\tfor(elt of data){\n\t\telt = elt.split(\"=\");\n\t\tif(elt[1] == \"true\" || elt[1] == \"false\"){\n\t\t\tresult[elt[0]] = (elt[1] == \"true\");\n\t\t} else {\n\t\t\tresult[elt[0]] = Number(elt[1]);\n\t\t}\n\t}\n\treturn result;\n}\n\n/// Starting point\nvar App = new Tyria3DApp();","//var T3D = require(\"../../../vendor/T3D/T3D-1.0.3.js\");\nvar SceneUtils = require(\"./SceneUtils\");\n\nvar tShort = 200 * 0;\nvar tLong = 500 * 0;\n\n\nvar UI = function(holder, controller, loadMap){\n\tthis.holder = holder;\n\tthis.controller = controller;\n\tthis.loadMap = loadMap;\n};\n\nUI.prototype.selectMap=function(mapListObject){\n\t$(\"#mapPicker option\").filter(function() {\n\t    return $(this).val() == mapListObject.fileName; \n\t}).prop('selected', true);\n\t$(\"#mapPicker\").change();\n};\n\nUI.prototype.logProgress = function(){\n\tif(!UI.op)\n\t\tUI.op = $(\"#output\");\n\t\n\t/// Hack to keep the message about first time up.\n\tif( arguments[0] != \"Find type\")\n\t\tUI.op.find(\".progressTitle\").html(arguments[0]);\n\n\tif(parseFloat(arguments[1])){\n\t\tUI.op.find(\".progress\").html(arguments[1]+\"%\");\t\n\t}\n\telse{\n\t\tUI.op.find(\".progress\").html(arguments[1]);\t\n\t}\n\t\n}\n\nUI.prototype.init=function(){\n\tvar self = this;\n\n\t/// Connect to T3D\n\tT3D.Logger.logFunctions[T3D.Logger.TYPE_PROGRESS] = this.logProgress;\n\tT3D.Logger.logFunctions[T3D.Logger.TYPE_DEBUG] = function(){};\n\n\t/// Main UI\n\tvar $UI = $(\"<div id='UI' class='diagonalBG hidden' />\");\n\t\n\tthis.holder.append($UI);\n\n\t\n\n\t/// Messages output\n\tvar outputWrapper = $(\"<div id='outputWrapper'/>\");\n\toutputWrapper.css({top:-500}).delay(tShort).animate({top:0},tLong);\n\tvar output = $(\"<div id='output' class='diagonalBG'/>\");\n\t\n\toutputWrapper.append(output);\n\tthis.holder.append(outputWrapper);\n\n\t/// File picker\n\toutput.append($(\n\t\t\"<div class='ui-panel' id='filePanel'>\"+\n\t\t\"<p class='title'>\"+\n\t\t\"<span class='titleLink homeLink'>Home</span>\"+\n\t\t\"<span class='titleSeparator'> &#187 </span>\"+\n\t\t\"File\"+\n\t\t\"<span class='titleSeparator'> &#187 </span>\"+\n\t\t\"<span class='titleInactive'>Map</span>\"+\n\t\t\"</p>\"+\n\t\t\"<p class='instruction'>\"+\n\t\t\t\"Tyria 3D reads data from the Guild Wars 2 <span class='hightlight'>.dat file</span>. This file contains all the assets used to run the game and is located\"+\n\t\t\t\" in the Guild Wars 2 install directory, the same directory that the game executable is located in.\"+\n\t\t\"</p>\"+\n\t\t\"</div>\"\n\t));\n\n\n\t// Progress and mesages\n\tvar progressOutput = $(\"<div class='ui-panel hidden' id='progressPanel'>\"+\n\t\t\"<p class='progressTitle'></p>\"+\n\t\t\"<p class='progress'></p>\"+\n\t\t\"</div>\");\n\toutput.append(progressOutput);\n\n\tvar errorOutput = $(\"<div class='ui-panel hidden' id='errorPanel'>\"+\n\t\t\"Your browser doesn\\'t seem to support Pointer Lock API, \"+\n\t\t\"navigating the map will not be possible.<br/><br/>Pro tip: \"+\n\t\t\"<a href='https://www.google.com/chrome/browser/desktop/index.html' target='_blank'>\"+\n\t\t\"Donwload Google Chrome</a>.\"+\n\t\t\"</div>\");\n\toutput.append(errorOutput);\n\n\tvar suspendedPanel = $(\"<div class='ui-panel hidden' id='suspendedPanel'>\"+\n\t\t\t\"This view is suspended until you<br/><br/> \"+\n\t\t\t\"<strong>click and hold</strong> to look around<br /><br/>\"+\n\t\t\t\"or<br/><br />click the <strong>Lock Mouse</strong> button<br/><br/>\"+\n\t\t\t\"When this view is active, use <strong>W A S D</strong> and <strong>space</strong> to move and jump + air jump\"+\n\t\t\"</div>\");\n\toutput.append(suspendedPanel);\n\n\n\t// Map opts\n\tvar mapOpts = $(\"<div class='ui-panel hidden' id='mapPanel'>\"+\n\t\t\"<p class='title'>\"+\n\t\t\"<span class='titleLink homeLink'>Home</span>\"+\n\t\t\"<span class='titleSeparator'> &#187 </span>\"+\n\t\t\"<span id='mapBack' class='titleLink'>File</span>\"+\n\t\t\"<span class='titleSeparator'> &#187 </span>\"+\n\t\t\"Map\"+\n\t\t\"</p>\"+\n\t\t\"<p class='instruction' style='margin-bottom:0;'>\"+\n\t\t\t\"Select what data to load and pick a <span class='highlight'>Map</span>.\"+\n\t\t\"</p>\"+\t\t\n\t\t\"</div>\");\n\n\toutput.append(mapOpts);\n\n\t$(\"#mapBack\").click(function(evt){\n\t\tSceneUtils.swapPanels($(\"#mapPanel\"), $(\"#filePanel\"));\n\t});\n\n\t$(\".homeLink\").click(function(){\n\t\tlocation.reload();\n\t});\n\n\n\n\n\t/// UI to select what to load\n\tmapOpts.append($(\n\t\t\n\t\t\t\"<label class='noselect'>\"+\n\t\t\t\t\"<p class='label'>Zone Models</p>\"+\n\t\t\t\t\"<input type='checkbox' id='loadZone' tabindex='-1' />\"+\n\t\t\t\"</label>\"+\n\t\t\t\"<label class='noselect '>\"+\n\t\t\t\t\"<p class='label'>Prop Models</p>\"+\n\t\t\t\t\"<input type='checkbox' id='loadProp' tabindex='-1' checked='checked' />\"+\n\t\t\t\t//\"<input type='checkbox' id='loadProp' tabindex='-1' />\"+\n\t\t\t\"</label>\"+\n\t\t\t\"<label class='noselect '>\"+\n\t\t\t\t\"<p class='label'>Visible collision</p>\"+\n\t\t\t\t\"<input type='checkbox' id='showHavok' tabindex='-1' />\"+\n\t\t\t\"</label><br/>\"\n\t));\n\n\t\n\t/// UI to pick map file\n\tvar picker = $(\"<select id='mapPicker' tabindex='-1'/>\");\n\tpicker.append($(\"<option selected='true' disabled='disabled'>No .dat loaded</option>\")); \n\t\n\t\n\tT3D.MapFileList.maps.forEach(function(g){\n\t\tvar group = $(\"<optgroup label='\"+g.name+\"' />\");\n\t\tpicker.append(group);\n\t\tg.maps.forEach(function(m){\n\t\t\tgroup.append(\"<option value='\"+m.fileName+\"'>\"+m.name+\"</option>\");\n\t\t});\n\t\t\n\t});\n\t\n\n\tpicker.change(function(evt){\n\t\tvar val = picker.val();\n\t\tself.loadMap(val, evt.value);\n\n\t\tvar label = $(\"#mapPicker option\").filter(function() {\n\t    \treturn $(this).val() == val; \n\t\t}).html();\n\t\t$(\"#mapTitle\").html(label);\n\n\n\t\tpicker.blur();\n\t});\n\tmapOpts.append(picker);\t\n\n\n\tmapOpts.append( $(\"<p class='instruction'>\"+\n\t\t\t\"Enabling <span class='highlight'>Zone Models</span> allows you to view trees, plants and various 'nature' models. \"+\n\t\t\n\t\t\"</p><p class='instruction'>\"+\n\t\t\t\"Enabling <span class='highlight'>Prop Models</span> allows you to view most of the models in a map. \"+\n\t\t\n\t\t\"</p><p class='instruction'>\"+\t\n\t\t\t\"Enabling <span class='highlight'>Visible collision</span> allows you to view all the collision data in a map. \"+\n\t\t\t\" The collision data has no textures but will give you a hint of how the map looks with actual models,\"+\n\t\t\t\" consider enabling only Visible collision to reduce map loading times. \"+\n\t\t\t\" If you enabled Zone Models or Prop Models you probably don't want Visible collision.\"+\n\t\t\"</p>\") );\n\n\t/// END Map Picker\n\n\n\t// Move opts\n\tvar movementOpts = $(`<div class='ui-panel' id='optionsPanel'>\n\t\t\t<p class='title' id='mapTitle'></p>\n\t\t\t<p id='showMapSelection' class='optionsLink' tabindex='-1'>Back to map selection</p>\n\t\t\t\n\t\t\t<div>\n\t\t\t\t<br/>\n\t\t\t\t<span class='label'>View distance:</span><br/>\n\t\t\t\t<div class='slider' id='fogSlider' tabindex='-1'></div>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div>\n\t\t\t\t<span class='label'>&#128161;:</span>\n\t\t\t\t<div class='slider' id='ambientSlider' tabindex='-1'></div>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div>\n\t\t\t\t<span class='label'>Speed [Scroll Up/Down]:</span>\n\t\t\t\t<div class='slider' id='moveSpeedSlider' tabindex='-1'></div>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div>\n\t\t\t\t<span class='label'>Mouse sensitivity:</span>\n\t\t\t\t<div class='slider' id='mouseSensSlider' tabindex='-1'></div>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div>\n\t\t\t\t<label class='noselect halfLabel'><p class='label'>Fly [F]</p>\n\t\t\t\t<input id='flyInput' type='checkbox' tabindex='-1' checked='checked'></input></label>\n\t\t\t\t<label class='noselect halfLabel'><p class='label'>Invert mouse</p>\n\t\t\t\t<input id='invertInput' type='checkbox' tabindex='-1'></input></label>\n\t\t\t</div>\n\t\t\t\n\t\t\t<p class='uiText'>Toggle UI [U], Toggle Stats [I], Orthographic Cam [O], Perspective Cam [P]</p>\n\t\t\t<button id='mouseLockBtn' tabindex='-1'>Lock Mouse</button>\n\t\t\t\n\t\t\t\n\t\t\t<label class='hidden'><p class='label nomargin'>Location URL</p>\t\n\t\t\t<input class='hidden' id='locationInput' type='text'></input></label>\t\n\t\t</div>`);\n\n    $UI.append(movementOpts);\n\n    $(\"#showMapSelection\").click(function(){\n\n\t\t//Clear URL\n\t\twindow.location.hash = \"\";\n\n    \t$(\"#UI\").addClass(\"hidden\");\n    \tself.controller.setMapReady(false);\n    \tSceneUtils.swapPanels($(\"#suspendedPanel\"),$(\"#mapPanel\"));\n    \t$(\"canvas\").hide();\n    \t$(\"#mapPicker option\").prop('selected', false);\n    \t$(\"#mapPicker option\").first().prop('selected', true);\n    });\n\n    function onSpeedChange(evt, ui){\n    \tvar speed = Math.exp(ui.value);\n    \twindow.setTimeout(function(){\n    \t\tself.controller.setSpeed(speed);\t\n    \t},10);\t\n    }\n\n    function onSensChange(evt, ui){\n    \tvar sens = ui.value;\n    \twindow.setTimeout(function(){\n    \t\tself.controller.setSensitivity(sens);\n    \t},10);\n    }\n\n    function onFogChange(evt, ui){\n    \tSceneUtils.setFog(ui.value);\n    }\n\n    function onAmbientChange(evt, ui){\n    \tSceneUtils.setAmbientAdd(ui.value);\n    }\n\n    function onLightChange(evt, ui){\n    \twindow.setTimeout(function(){\n    \t\tSceneUtils.setHSLa(\n    \t\t\t0.27,\n    \t\t\t$(\"#saturationSlider\").slider(\"option\", \"value\"),\n    \t\t\t$(\"#lightnessSlider\").slider(\"option\", \"value\"),\n    \t\t\t$(\"#intensitySlider\").slider(\"option\", \"value\")\n\t\t\t);\n    \t\tSceneUtils.render();\n    \t},10);\n    }\n\n    \n\n    /// Sliders\n    $(\"#moveSpeedSlider\").slider({\n\t\tmin: 4, max: 10, step: 0.01,\n  \t\tchange: onSpeedChange\n    }).slider(\"value\",7.5);\n\n    $(\"#mouseSensSlider\").slider({\n\t\tmin: 0.0001, max: 0.01, step: 0.0001,\n  \t\tchange: onSensChange\n    }).slider(\"value\",0.002);\n    \n    $(\"#fogSlider\").slider({\n\t\tmin: 5000, max: 100000, step: 500,\n  \t\tchange: onFogChange\n    });\n\n    $(\"#ambientSlider\").slider({\n\t\tmin: 0, max: 1.0, step: 0.01,\n  \t\tchange: onAmbientChange\n    });\n\n    /// HSL\n    /*$(\"#saturationSlider\").slider({\n\t\tmin: 0, max: 1, step: 0.01,\n  \t\tchange: onLightChange\n    }).slider(\"value\",0.4);\n    $(\"#intensitySlider\").slider({\n\t\tmin: 0, max: 1, step: 0.01,\n  \t\tchange: onLightChange\n    }).slider(\"value\",0.5);\n    $(\"#lightnessSlider\").slider({\n\t\tmin: 0, max: 1, step: 0.01,\n  \t\tchange: onLightChange\n    }).slider(\"value\",0.5);*/\n\n    /// END Sliders\n\n\n    /// Toggle buttons\n    $(\"#invertInput\").change(function(){\n    \tself.controller.invertMouse();\n    })\n    $(\"#flyInput\").change(function(){\n    \t\n    \t/*if($(this).is(':checked'))\n    \t\t$(\"#fogSlider\").slider(\"value\",35000);\n    \telse \n    \t\t$(\"#fogSlider\").slider(\"value\",15000);*/\n    \t\t\n    \tself.controller.toggleFly();\n    })\n\n    $(\"#mouseLockBtn\").click(function(){\n    \tself.controller.lock();\n    });\n\n    /// END Toggle buttons\n\t$(\"#locationInput\").on('click',function(){ this.select(); });\n\n    // Instructions \n\t/*var instructions = $(\"<div class='ui-panel'>\"+\n\t\t\"<p class='title'>Instructions</p>\"+\n\t\t\"<p class='instruction'>Pick a map from the drop down menu.</p>\"+\n\t\t\"<p class='instruction'><strong>Click and hold</strong> to look around. \"+\n\t\t\"Use <strong>W A S D</strong> and <strong>space</strong> to move.</p>\"+\n\t\t\"<p class='instruction'>Enable experimental downward collision by unchecking <strong>fly</strong>.</p>\"+\n\t\t\"<p class='instruction'>Toggle this panel with <strong>U</strong>.</p>\"+\n\t\"</div>\");\n\t$UI.append(instructions);*/\n};\n\n\nmodule.exports = UI;"]}